#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{url}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{lmodern}


\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\lstdefinelanguage{grammar}{
otherkeywords={ | , \{ , \} , =},
morestring=[b]"
}

\lstdefinelanguage{fumurt}{
  morekeywords={program, function, action, thread, true, false},
  otherkeywords={:},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]"
}

\lstset{
numbers=left,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
frame=single,
basicstyle=\footnotesize\ttfamily,
breakatwhitespace=true,
showspaces=false,
showstringspaces=false,
showtabs=false}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize b5paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 25mm
\topmargin 27mm
\rightmargin 25mm
\bottommargin 30mm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Problem Statement
\end_layout

\begin_layout Standard
Multithreading is often problematic in that effects of timing and scheduling
 may lead to nondeterministic behavior.
 This again leads to race conditions and limits testability of the system,
 in a manner that might not be acceptable for critical systems.
\end_layout

\begin_layout Standard
The possibility of making a programming language with multithreading semantics
 more suitable to critical systems should be explored.
\end_layout

\begin_layout Standard
The student shall:
\end_layout

\begin_layout Enumerate
Provide a short summary of systematic approaches to multithreading
\end_layout

\begin_layout Enumerate
Define a language with syntax and semantics that support writing high-reliabilit
y, real-time multithreaded programs
\end_layout

\begin_layout Enumerate
Make a prototype implementation of this language
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Preface
\end_layout

\begin_layout Standard
This report describes a master thesis done as a part of the MSc Engineering
 Cybernetics course at NTNU.
 The master thesis represents 30 ECTS points.
 It was written in the spring semester of 2015.
\end_layout

\begin_layout Standard
It assumes that readers have prior experience working with programming languages
 and knows some common nomenclature.
\end_layout

\begin_layout Standard
8th of june, 2015
\end_layout

\begin_layout Standard
NTNU, Trondheim
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tormod Gjeitnes Hellen
\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
I want to thank:
\end_layout

\begin_layout Itemize
My parents, Knut Jacob Windelstad Hellen and Liv Signy Gjeitnes Hellen,
 who love me even though I call them way less than I should
\end_layout

\begin_layout Itemize
My flatmates, Caroline Einen and Ingerid Gjeitnes Hellen, who tolerate my
 mess
\end_layout

\begin_layout Itemize
My supervisor, Sverre Hendseth, whose suspender-belt combination taught
 me the value of redundancy.
 He was also a valuable source of calm, motivation and advice while working
 on the thesis
\end_layout

\begin_layout Itemize
My closest friends, Adrian Hjelvik and Jon-Håkon Bøe Røli, for making my
 days a little brighter and a little more indecent
\end_layout

\begin_layout Itemize
The faculty at TU Berlin's compiler bau course, Peter Pepper and Judith
 Rohloff, for teaching me how to write a compiler and for giving me points
 even though I failed the exam
\end_layout

\begin_layout Itemize
The Norwegian State Educational Loan Fund, which funded my education, this
 thesis and my other questionable endeavors
\end_layout

\begin_layout Itemize
A diverse set of characters who have brought me joy and taught me a lot
 about life
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
This report presents a programming language with deterministic multithreading
 and its compiler.
 The language demonstrates that when making IO and inter-thread communication
 sequential, most problems with multithreaded programming disappears, while
 most of the architectural and some of the performance benefits of multithreadin
g are preserved.
 Much difficulty in modern programming is a result of insufficient abstraction,
 and while the popular embedded programming languages are unlikely to be
 replaced anytime soon, effort still has to be made to figure out the next
 step in the language evolution.
 In the language presented, there are also other changes meant to aid in
 the programming of critical systems besides determinism: Threads are written
 much like functions, dependencies between functions not contained in each
 other are explicit and arguments are distinguished by name, not sequence.
 Finally, threads and objects shared between threads are all visible in
 a single place.
\end_layout

\begin_layout Section*
Sammendrag
\end_layout

\begin_layout Standard
Denne rapporten omhandler et programmerinsspråk med deterministisk multitråding
 og dette språkets kompilator.
 Språket demonstrerer at når en gjør IO og inter-tråd kommunikasjon sekvensielt,
 så forsvinner de fleste problemer med multitråding, mens de fleste arkitekturme
ssige og noen av de ytelsesmessige fordelene forblir.
 Mange av problemene i moderne programmering er et resultat av manglende
 abstraksjon, og selv om de populære språkene for mikrokontrollere ikke
 ser ut til å bli erstattet med det første, må vi fremdeles gjøre en innsats
 for å finne det neste steget i språkutviklingen.
 I det presenterte språket er det også andre forandringer ment å lette programme
ringen av kritiske systemer: Tråder skrives som funksjoner, avhengigheter
 mellom funksjoner som ikke er erklært i hverandre er uttalt og argumenter
 er skilt fra hverandre ved navn, ikke relativ posisjon.
 Til slutt er tråder og objekter delt mellom tråder synlig på ett sted.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
It is commonly understood that writing software is hard and that writing
 multithreaded software is even harder.
 This report concerns itself with a new language - Fumurt - with a functional,
 though incomplete, compiler.
 This language is intended as a viability test of some new language semantics
 and a starting point for further development.
 The semantics of the language are intended to ease development of multithreaded
 real-time and reactive applications and produce programs which require
 less testing and have fewer bugs than the existing state of the art.
\end_layout

\begin_layout Standard
Specifying a language and implementing a compiler are inherently difficult
 tasks.
 The former is an exercise in subjective judgment and trade-offs and the
 latter is a challenging exercise in software engineering.
 When starting to work with this thesis, a language was envisioned that
 made manual scheduling of threads easier than before, but it was decided
 that this placed too heavy of a burden on the programmer.
 The ideas that culminated in this report are the result of several weeks
 of reconsideration.
\end_layout

\begin_layout Standard
Fumurt is a language built with the intention that the programmer shall
 never be surprised.
 It strives to make the least possible demands on programmers ability to
 build mental models and memorize.
 Therefore Fumurt strives to imbue its syntax with as much meaning as possible
 and to concentrate declaration of concurrent code in one place (fork-join
 concurrency not affected).
 Language design inherently necessitates compromise and Fumurt compromises
 minimally on readability and predictability, sacrificing instead keyboard
 typing and rapid iteration.
 It favors predictability over performance and explicitness over terseness.
\end_layout

\begin_layout Section
Report Structure
\end_layout

\begin_layout Standard
The report is divided into chapters as follows:
\end_layout

\begin_layout Itemize
The Background chapter contains information needed to understand the rest
 of the report and a summary of the state of the art 
\end_layout

\begin_layout Itemize
The specification loosely outlines how the language should look and behave
\end_layout

\begin_layout Itemize
Analysis and Design discusses the high-level choices taken during implementation
 and the limitations of the current design
\end_layout

\begin_layout Itemize
Implementation documents how the compiler is written
\end_layout

\begin_layout Itemize
Testing contains examples of input source code and resulting error messages
 or runtime behavior
\end_layout

\begin_layout Itemize
Conclusion, Discussion and Future Work evaluates and reflects on the work
 done and presents recommendations for future work
\end_layout

\begin_layout Standard
The appendices are as follows:
\end_layout

\begin_layout Itemize
System manual describes how to compile and run the compiler from source
\end_layout

\begin_layout Itemize
User manual describes how to run the compiler from Java bytecode
\end_layout

\begin_layout Itemize
Code listing contains the source code
\end_layout

\begin_layout Standard
The report layout adheres to a recommendation by University College London
\begin_inset CommandInset citation
LatexCommand cite
key "UCLReportStructure"

\end_inset

, modified in consultation with supervisor.
\end_layout

\begin_layout Standard
The citation style is that of the Association for Computing Machinery.
\end_layout

\begin_layout Section*
A Note on Terminology
\end_layout

\begin_layout Standard
During the writing of this report, a word that described both statements
 and definitions was needed, and it was decided to call them both expressions,
 despite this not being the usual way to use that word.
\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Author's Prior Knowledge
\end_layout

\begin_layout Standard
The inner workings of the compiler are heavily influenced by a course the
 author took on compilers at the Technische Universität Berlin under Peter
 Pepper and Judith Rohloff.
 While no code is reused, the structure of the compiler is very similar.
\begin_inset CommandInset label
LatexCommand label
name "sec:TUB course"

\end_inset


\end_layout

\begin_layout Section
Concurrency Paradigms
\end_layout

\begin_layout Standard
It is commonly understood that writing software is hard.
 The development of programming languages is a response to this problem.
 The common pattern is that flexible features that are easily used to write
 code that is hard to reason about are replaced by, often several, less
 flexible features.
 After all, the less flexible a feature is, the more predictable its use
 is.
 Three examples: 
\end_layout

\begin_layout Itemize
goto replaced by sequence, selection and iteration 
\begin_inset CommandInset citation
LatexCommand cite
key "bohm1966flowStructuredProgramming"

\end_inset


\end_layout

\begin_layout Itemize
pointers replaced by indexes and references 
\end_layout

\begin_layout Itemize
mutable variables replaced by immutable values 
\end_layout

\begin_layout Standard
Interestingly, one can observe that as each feature becomes easier to reason
 about, the total number of features increase.
 For example, to eliminate mutation, one needs to also eliminate iteration.
 One way to do this is by using recursion, which is a full replacement for
 iteration.
 But recursion, while allowing immutability, is often harder for humans
 to understand 
\begin_inset CommandInset citation
LatexCommand cite
key "milne2002difficulties"

\end_inset

.
 To ameliorate this problem, a variety of mechanisms have been implemented,
 for example map and fold, which performs common functions previously performed
 utilizing iteration.
 In this manner, the number of features often increase in the interest of
 analyzability.
 Is this generally true? And if so, at what point does the drawbacks of
 increasing feature number outweigh the benefit of increased analyzability
 and predictability? Answering these questions is outside the scope of this
 report.
 Much progress has been made in making programs easier to understand and
 analyze in this fashion, yet there is always room for improvement.
 In later years, one feature in particular has risen to notability: Concurrency.
 In the past, concurrency has not been an issue for most programmers but
 as multi-processor (or multi-core) systems have gone mainstream, so has
 multithreaded programming
\begin_inset CommandInset citation
LatexCommand cite
key "sutter2005freeLunch"

\end_inset

.
 The problems inherent to concurrency can roughly be divided into two categories
: Communication and scheduling; making sure the correct information is shared
 between threads in a correct way and making sure tasks are done at correct
 times, respectively.
 One possibility is to let the programmer deal with these problems in an
 application-specific way.
 This is notoriously error-prone, however.
 Several abstractions have been devised for dealing with the two concurrency
 problems in a systematic manner, to the author's knowledge:
\end_layout

\begin_layout Itemize
Actors 
\begin_inset CommandInset citation
LatexCommand cite
key "hewitt1973universalActors"

\end_inset


\end_layout

\begin_layout Itemize
Communicating sequential processes 
\begin_inset CommandInset citation
LatexCommand cite
key "hoare1978communicatingCSP"

\end_inset


\end_layout

\begin_layout Itemize
Transactional memory
\begin_inset CommandInset citation
LatexCommand cite
key "herlihy1993transactional"

\end_inset


\end_layout

\begin_layout Itemize
Synchronous programming
\begin_inset CommandInset citation
LatexCommand cite
key "berry1992esterel"

\end_inset


\end_layout

\begin_layout Paragraph*
Actors
\end_layout

\begin_layout Standard
Actors are nondeterministic by definition.
 Each actor has a function that processes incoming messages.
 This function can run on its own thread, or a more lightweight system can
 be used.
 Regardless, the only way actors can exchange information is through messages.
 Each actor has a queue and each message received ends up at the back of
 this queue.
 When there is a message to process, the actor springs to life, processing
 messages (in the process probably sending some messages of its own) until
 its queue is empty again.
 Actors are similar to computers; actors are like processors with running
 software, and queues are like network buffers.
 This means that there is no need to adjust the actor system when there
 is a desire to spread the actors over several machines; communication over
 the network and communication over shared memory can both be abstracted
 away by the actor system.
 The two mainstream implementations of actors are Akka and Erlang.
\end_layout

\begin_layout Paragraph*
Communicating Sequential Processes
\end_layout

\begin_layout Standard
Communicating sequential processes (CSP) are also based on messages.
 The crucial difference is that in CSP there's no queue; the sending process
 blocks until the receiving process has received the message and, depending
 on whether this is desired, responded to the message.
 A very elegant property of CSP is that calling a function can be implemented
 as sending a message; the same syntax can be used for both.
 Two mainstream implementations of CSP are Go and Rust.
\end_layout

\begin_layout Paragraph*
Transactional memory
\end_layout

\begin_layout Standard
Transactional memory is implemented both in hardware and software, but hardware
 implementations are not widely available for consumer systems yet.
 The essence of transactional memory is the same that that of mutexes and
 locks - that is, shared memory where one prevent concurrent processes from
 accessing shared memory objects.
 The difference is that, where mutexes and locks assume that there will
 be memory collisions, transactional memory assumes that the normal state
 of the system is that no two threads write to the same memory at the same
 time.
 From the perspective of a thread, it looks like this:
\end_layout

\begin_layout Enumerate
The thread locks the variable (O), and makes a read copy (C1)
\end_layout

\begin_layout Enumerate
The thread performs whatever calculations it wants to perform with the variable
\end_layout

\begin_layout Enumerate
If the calculation involves writing to the variable, then the result is
 written to a write copy (C2)
\end_layout

\begin_layout Enumerate
Now the thread locks the variable (O), and checks whether it is equal to
 the read copy (C1).
 If 
\begin_inset Formula $O==C1$
\end_inset

, then the result from the calculation is still valid.
 If 
\begin_inset Formula $O!=C1$
\end_inset

 then the thread deletes the copies (C1 and C2) and reverts to step 1.
\end_layout

\begin_layout Enumerate
If the calculation involved writing to the variable (O), then the write
 copy is assigned to the variable(
\begin_inset Formula $O\leftarrow C2$
\end_inset

)
\end_layout

\begin_layout Enumerate
The thread now unlocks the variable (O)
\end_layout

\begin_layout Standard
For big structures, such as arrays, the copies made are usually only of
 the read (read-set) and written (write-set) parts of the variable, which
 reduces copying, and lets several threads modify the same variable at the
 same time as long they do not affect the same parts of the variable.
 In transactional memory, it is desired to hold locks in as short time intervals
 as possible.
 Assuming the calculation takes a long time and no other thread tries to
 write to the same variables, the performance gains can be significant.
 And since protecting variables like this has such a low cost except under
 write contention, this technique can be applied to all memory the threads
 share.
 Transactional memory has many popular implementations, but it is particularly
 heavily used in Haskell and Clojure.
\end_layout

\begin_layout Paragraph*
Synchronous Programming
\end_layout

\begin_layout Standard
Synchronous programming provides a synchronicity abstraction, the same as
 is used for logical circuits: Time is discretized and all operations during
 a time step are done instantly and computed from memory as it was at the
 beginning of the time step.
 Notice that the operations done in a time step does not affect each other.
 Synchronous programming is thus 
\emph on
deterministic
\emph default
.
 Synchronous programming is a rarity and the most mainstream implementation
 is Esterel, which is proprietary.
\end_layout

\begin_layout Paragraph*
The Decision Made for This Thesis
\end_layout

\begin_layout Standard
In the end a decision was made in favor of using a variation on the synchronous
 programming paradigm.
 There are trade-offs associated with choosing synchronous programming,
 but they were determined to be preferable to the alternatives.
 The main problems with synchronous programming are 
\end_layout

\begin_layout Enumerate
Difficulty in scaling beyond one physical machine.
 The cost of global synchronization grows with latency.
\end_layout

\begin_layout Enumerate
Performance loss due to processing resources idling as the synchronization
 abstraction requires all operations to use the same amount of time.
\end_layout

\begin_layout Standard
Synchronous programming therefore has substantial problems, yet for single-machi
ne systems it presents a way to achieve near-multi-threaded performance
 and multi-threaded architecture but with single-threaded predictability
 and therefore debugability.
 While the other abstractions place some of the responsibility for correct
 concurrent behavior on the programmer, synchronous programming takes care
 of all of that and replaces it with the responsibility for performance,
 as the program performs best if all threads has an equal amount of work.
 Let us discuss the problems of the other abstractions:
\end_layout

\begin_layout Itemize
Actors assume infinite message queues, with the failure mode being a loss
 of information.
 In a producer-consumer relationship, producer actors can overwhelm consumer
 actors.
 Actors are designed to mimic distributed systems and create a unified abstracti
on over these, with the limited guarantees that requires.
 Distributed systems have to correctly handle hardware failures, so loss
 of information is an acceptable failure mode for actors.
 However, this makes actors unsuitable for real-time systems as recovering
 from data loss and unpredictable memory usage are unacceptable trade-offs.
 Ordering of IO is also unpredictable.
\end_layout

\begin_layout Itemize
CSP systems use synchronous communication and therefore avoid the message
 queue problem of actors entirely.
 In exchange, they are open to deadlock, and the ordering of IO is unpredictable.
 CSP therefore requires brute force search for deadlocks, and debugging
 is harder than for single-threaded systems.
 Despite this, it is regarded as a solid choice for real time systems.
\end_layout

\begin_layout Itemize
Transactional memory, though it makes it look as if thread communication
 is easy, has its own problems.
 The unpredictability of the sequence of writing is a problem, as well as
 the unpredictable time it takes.
 Again, IO order is unpredictable.
\end_layout

\begin_layout Section
Compilers
\end_layout

\begin_layout Standard
A compiler is a program (one may regard it as a function) that accepts a
 program in a source format and outputs a corresponding program in a target
 format.
 The source and target format may differ in terms of encoding, language
 and any other way one may imagine.
 
\end_layout

\begin_layout Standard
This figure, reconstructed from 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2011engineering"

\end_inset

, illustrates the structure of a typical compiler:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename textbookcompiler.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Consider the steps:
\end_layout

\begin_layout Enumerate
The front end accepts source text and transforms it into an intermediate
 representation that is easier to work with.
 It is generally independent of the target format.
\end_layout

\begin_layout Enumerate
The optimizer improves the code as encoded in the intermediate representation.
 The improvement is usually done with regards to performance, code size
 or memory usage .
\end_layout

\begin_layout Enumerate
The back end accepts the intermediate representation and outputs the the
 program encoded therein translated to the target format.
 It can be independent of the source format, depending on how general and
 flexible the intermediate representation is.
\end_layout

\begin_layout Standard
Since the Fumurt compiler (described in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Implementation"

\end_inset

) does not deal with optimization and conversion to binary itself, but rather
 outsources this to a C++ compiler, all of the difficult material on instruction
 selection, scheduling and register allocation is of no relevance.
 The parts of relevance to this report is the front end and a relatively
 simple back end.
\end_layout

\begin_layout Standard
Consider the parts of the front end:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename textbookfrontend.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Itemize
Scanner: Transforms source text into a list of tokens (simple objects),
 possibly ignoring some symbols (such as spaces, comments, indentation etc.)
\end_layout

\begin_layout Itemize
Parser: Transforms a list of tokens into an intermediate representation,
 usually an abstract syntax tree.
 In the process, it checks whether the syntax of the program is correct.
\end_layout

\begin_layout Itemize
Context Sensitive Analysis: Checks the correctness of program semantics.
 Most interpreted languages skip this step and deal with semantic errors
 at runtime.
 The correct time to do semantic analysis is not a settled matter, but in
 a static compiler such as the one for Fumurt it is done at compilation.
 This step may or may not emit a modified intermediate representation, but
 a case in which it would be expected to do so would be when the language
 has type inference.
\end_layout

\begin_layout Standard
The back end is composed of successive passes, of which every step transform
 the input intermediate representation into an output that is closer to
 the target format.
 The number of passes required vary greatly and depend on the differences
 between the source and output formats.
 In the trivial case, where the input and output format is identical (for
 example C to C), the number of necessary passes would be zero.
\end_layout

\begin_layout Subsection*
Grammars
\begin_inset CommandInset label
LatexCommand label
name "sub:Grammars"

\end_inset


\end_layout

\begin_layout Standard
A grammar is a formal and complete description of the syntax of a language.
 It is mostly used for programming languages.
 It consists of the confusingly named 
\begin_inset Quotes eld
\end_inset

production rules
\begin_inset Quotes erd
\end_inset

.
 The standard used here is the Extended Backus-Naur Form of ISO/IEC 14977
\begin_inset CommandInset citation
LatexCommand cite
key "wirth1996extended"

\end_inset

.
\end_layout

\begin_layout Paragraph
Example:
\end_layout

\begin_layout Standard
Consider that a lower case letter can be described like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i"
 | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u"
 | "v" | "w" | "x" | "y" | "z" ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 signify the division of the two sides of the production rule, 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 signify alternation (intuitively 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

), quotes signify a string and 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 signify the end of the rule.
 Let us expand the example by describing a lower case word:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case word = lower case letter, {lower case letter};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the correctness of the word as it pertains to English is ignored.
 The comma signify a sequence, and contents of curly brackets can be repeated
 from zero up to an infinite amount of times.
 A lower case word, as it has been defined here, is simply one lower case
 letter, followed by zero or more lower case letters.
 Next, the same is done for sentences, again ignoring rules for English:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=grammar}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case sentence = lower case word, {(", ", lower case word) | (" ",
 lower case word)}, ".
 ";
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A lower case sentence is here a lower case word followed either by a comma
 plus space or just space, both followed by a new word.
 This is repeated as many times as desired and terminated by a period and
 a space.
\end_layout

\begin_layout Standard
Parentheses allows grouping of sequences.
 Here, it allows us to alternate between sequences of symbols rather than
 just single symbols.
 Finally:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=grammar}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case text = lower case sentence, {lower case sentence}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result is a very simple grammar, which allows us to partition up a text
 into sentences and words.
\end_layout

\begin_layout Subsection*
Abstract Syntax Trees
\end_layout

\begin_layout Standard
Now suppose it was desired to systematize a string of characters according
 to the grammar above.
 A data structure corresponding to the grammar would be appropriate.
 Consider the following figure:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abstract Syntax Tree.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
This is an abstract syntax tree, often abbreviated AST.
 An abstract syntax tree is a tree, in the computer science sense, that
 represents the production of the source string from the grammar.
 In code:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Text(val sentences:List[Sentence])
\end_layout

\begin_layout Plain Layout

class Sentence(val words:List[Word])
\end_layout

\begin_layout Plain Layout

class Word(val letters:List[Char])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parser Combinators
\end_layout

\begin_layout Standard
A parser combinator is a higher order function that accepts parsers as input
 and returns a new parser
\begin_inset CommandInset citation
LatexCommand cite
key "frost1989constructingParserCombinators"

\end_inset

.
 The overall effect is similar to a domain specific language for constructing
 recursive descent parsers.
 
\end_layout

\begin_layout Standard
A parser is a function that converts one data structure to a more sensible
 data structure.
 Usually, the output data structure is more restricted and systematic than
 the input one.
 
\end_layout

\begin_layout Paragraph
Example:
\end_layout

\begin_layout Standard
Consider a function that accepts the string 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 and returns an object of class equalToken or, if the string it is given
 is not 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, returns an error object.
 Such a function is then a parser.
 Such parsers can be combined to form a larger parser that can work as a
 scanner, that is a parser that converts a list of characters to a list
 of tokens (very simple objects).
 Let the previously discussed function be called the equalParser.
 Let a parser that works exactly the same, save for exchanging 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 be called the minusParser and let it return a minusToken upon success.
 Consider combining the equalParser with the minusParser using an 
\emph on
alternate parser combinator
\emph default
 (the 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 operator in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

).
 The resulting function would then first try the equalParser, and if that
 returned an error object, it would try the minusParser, returning an error
 object if both of these parsers fail.
 This new parser would not need to return a minusToken or equalToken, but
 can process the results from equalParser and minusParser into something
 new.
 In this example, two parsers have been formed and combined into a new parser
 using a parser combinator.
 This new parser can be part of a scanner.
 Indeed, the Fumurt scanner is formed like this (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "scanner combined"

\end_inset

).
\end_layout

\begin_layout Paragraph
A Note on Conflicting terminology:
\end_layout

\begin_layout Standard
Unfortunately there is a case of conflicting terminology concerning the
 term 
\begin_inset Quotes eld
\end_inset

parser
\begin_inset Quotes erd
\end_inset

.
 The parser is referred to in two senses: 
\end_layout

\begin_layout Enumerate
The parser as defined above.
 A function that converts one data structure to a more sensible data structure.
\end_layout

\begin_layout Enumerate
A parser as a compilation step that converts a list of tokens into an abstract
 syntax tree
\end_layout

\begin_layout Subsection
The Scala Standard Parser Combinator Library
\begin_inset CommandInset label
LatexCommand label
name "sub:The-Scala-Parser"

\end_inset


\end_layout

\begin_layout Standard
All the information here is also available at 
\begin_inset CommandInset citation
LatexCommand cite
key "ScalaParserCombinatorDoc"

\end_inset

.
\end_layout

\begin_layout Standard
The Scala Standard Parser Combinator Library introduces many parser combinators,
 most of whom are formulated as operators.
\end_layout

\begin_layout Standard
Let's discuss these operators:
\end_layout

\begin_layout Itemize
~ is used to combine parsers sequentially
\end_layout

\begin_layout Itemize
~> is used to combine parsers sequentially but ignore the result of the
 left parser
\end_layout

\begin_layout Itemize
~! is used to combine parsers sequentially but disallow backtracking.
\end_layout

\begin_layout Itemize
* applies the parser to the left as many times as it is successful, moving
 on at failure
\end_layout

\begin_layout Itemize
+ applies the parser to the left as many times as it is successful, moving
 on at failure.
 Must be applied at least once
\end_layout

\begin_layout Itemize
? applies the parser to the left zero or one time
\end_layout

\begin_layout Itemize
| used to combine parsers in a manner similar to logical 
\begin_inset Quotes eld
\end_inset

||
\begin_inset Quotes erd
\end_inset

.
 Tries to apply the left parser first.
 If the left parser fails, it will backtrack and attempt the right parser.
 If none work then an error is returned.
\end_layout

\begin_layout Itemize
^^ is used to apply a function to the successful result of the parser.
\end_layout

\begin_layout Itemize
^^^ is used to apply a function to the result of the parser, successful
 or not.
\end_layout

\begin_layout Section
A Quick Tour of Scala, the Compiler Implementation Language
\end_layout

\begin_layout Standard
In order to understand the code in the compiler, which is included in appendix
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Code-listing"

\end_inset

, it is helpful to understand the language it is written in.
 This section gives a quick introduction to Scala.
\end_layout

\begin_layout Subsection
Execution
\end_layout

\begin_layout Standard
There are three ways to execute Scala code:
\end_layout

\begin_layout Enumerate
In a read-evaluate-print loop (REPL).
\end_layout

\begin_layout Enumerate
Interpreted as a script.
\end_layout

\begin_layout Enumerate
As compiled Java bytecode.
\end_layout

\begin_layout Standard
The compiler is executed as compiled Java bytecode.
 Scala can look somewhat different when it is compiled versus when it is
 interpreted, due to the requirements imposed by the Java bytecode.
 As a result, methods need to be contained in an object if the code is intended
 for compilation, but in the REPL and in a script there are no such restrictions.
 In the REPL and script, statements are evaluated starting from the top,
 while a main method is required if the program is supposed to be compiled.
 This report uses only code meant to be compiled or code as it would look
 in a REPL.
 The two are easily distinguished by the latter's use of the 
\begin_inset Quotes eld
\end_inset

scala>
\begin_inset Quotes erd
\end_inset

 command prompt.
\end_layout

\begin_layout Subsection
Hello World
\end_layout

\begin_layout Standard
A simple Hello World example illustrates some main concepts.
\end_layout

\begin_layout Itemize
A singleton is called an 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

.
 These are sometimes called static classes in other languages
\end_layout

\begin_layout Itemize
Scope is demarcated using curly braces
\end_layout

\begin_layout Itemize
A method is defined using the 
\begin_inset Quotes eld
\end_inset

def
\begin_inset Quotes erd
\end_inset

 keyword
\end_layout

\begin_layout Itemize
Arguments are given using parentheses (separated by commas and identified
 by relative position)
\end_layout

\begin_layout Itemize
Types of values are written after the object name, separated with 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Unit, as a return type, means the method returns nothing
\end_layout

\begin_layout Itemize
Some types are container types, such as List[Int] or Array[String].
 These can hold any type through generics.
 In this case the square brackets means that args is an object of type Array,
 which in this case holds String.
 In other words, args is an array of strings.
\end_layout

\begin_layout Itemize
There are sequences, like Array or List
\end_layout

\begin_layout Itemize
lines need not be terminated with 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 (but it is optional)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object HelloWorld 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def main(args:Array[String]):Unit =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    println("Hello, world!")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Creating and Using Objects
\end_layout

\begin_layout Itemize
All values are objects, even native types
\end_layout

\begin_layout Itemize
Functions are objects, but methods are not
\end_layout

\begin_deeper
\begin_layout Itemize
Internally, functions are objects that implement an interface, for example
 Function1 for functions with one argument.
 This interface has a method 
\begin_inset Quotes eld
\end_inset

apply
\begin_inset Quotes erd
\end_inset

 where the actual 
\begin_inset Quotes eld
\end_inset

function
\begin_inset Quotes erd
\end_inset

, in the C sense of the word, is stored.
 This is completely transparent to the programmer, however.
\end_layout

\end_deeper
\begin_layout Itemize
Var lets you create mutable references to objects
\end_layout

\begin_layout Itemize
Val lets you create immutable references to objects
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def int1 = 3
\end_layout

\begin_layout Plain Layout

int1: Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val int2 = 2
\end_layout

\begin_layout Plain Layout

int2: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> var int3 = 7
\end_layout

\begin_layout Plain Layout

int3: Int = 7
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//reassignment to a def is illegal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> int1 = int1+1
\end_layout

\begin_layout Plain Layout

<console>:8: error: value int1_= is not a member of object $iw
\end_layout

\begin_layout Plain Layout

       int1 = int1+1
\end_layout

\begin_layout Plain Layout

       ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//so is reassignment to val
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> int2 = int2+1
\end_layout

\begin_layout Plain Layout

<console>:8: error: reassignment to val
\end_layout

\begin_layout Plain Layout

       int2 = int2+1
\end_layout

\begin_layout Plain Layout

            ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//reassignment to var is completely ok
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> int3 = int3+1
\end_layout

\begin_layout Plain Layout

int3: Int = 8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> int1+int2+int3
\end_layout

\begin_layout Plain Layout

res0: Int = 13
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//all values are objects
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> int1.+(int2.+(int3)) 
\end_layout

\begin_layout Plain Layout

res1: Int = 13 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//even functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val square = ((x:Int) => x*x) 
\end_layout

\begin_layout Plain Layout

square: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> square(3) 
\end_layout

\begin_layout Plain Layout

res2: Int = 9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> square.toString 
\end_layout

\begin_layout Plain Layout

res3: String = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//methods are not objects
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def cube(x:Int) = x*x*x
\end_layout

\begin_layout Plain Layout

cube: (x: Int)Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cube(3)
\end_layout

\begin_layout Plain Layout

res4: Int = 27
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cube.toString
\end_layout

\begin_layout Plain Layout

<console>:9: error: missing arguments for method cube;
\end_layout

\begin_layout Plain Layout

follow this method with `_' if you want to treat it as a partially applied
 function
\end_layout

\begin_layout Plain Layout

              cube.toString
\end_layout

\begin_layout Plain Layout

              ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Classes and Pattern Matching
\end_layout

\begin_layout Itemize
Classes work much like they do in Java
\end_layout

\begin_layout Itemize
Case classes are different than normal classes.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Their constructors can be used like normal functions.
 The 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 keyword is not necessary
\end_layout

\begin_layout Itemize
Their constructor parameters are exported
\end_layout

\begin_layout Itemize
One can use pattern matching on them.
 Pattern matching allows one to test which type an object has and extract
 its values, a reference to it or both.
\end_layout

\begin_deeper
\begin_layout Itemize
Pattern matching looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x:String = input match
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  case TypeA("specific string") => "specific string"
\end_layout

\begin_layout Plain Layout

  case TypeB(anystring, otherstring) => anystring + " " + otherstring
\end_layout

\begin_layout Plain Layout

  case TypeB(_,otherstring) => "only care about "+otherstring
\end_layout

\begin_layout Plain Layout

  case TypeB(_,_) => "only care about type"
\end_layout

\begin_layout Plain Layout

  case reference:TypeA => "the object looks like this: "+reference.toString
\end_layout

\begin_layout Plain Layout

  case reference @ TypeA(str) => "both the reference and the constructor
 parameter"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The wildcard 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 can be used to represent anything.
 In pattern matching it can be used much like 
\begin_inset Quotes eld
\end_inset

else
\begin_inset Quotes erd
\end_inset

 would in an if statement
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala>//classes in scala function much like classes in Java
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> class A(int:Int, str:String)
\end_layout

\begin_layout Plain Layout

defined class A
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val a = new A(3,"a string")
\end_layout

\begin_layout Plain Layout

a: A = A@66ae2a84
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//case classes, on the other hand, have more functionality.
 Their constructors are called like normal functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> case class B(str:String, int:Int)
\end_layout

\begin_layout Plain Layout

defined class B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val b = B("other string", 5)
\end_layout

\begin_layout Plain Layout

b: B = B(other string,5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//and one can pattern match on them
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> case class C(double:Double, int:Int)
\end_layout

\begin_layout Plain Layout

defined class C
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val c = C(3.0, 3)
\end_layout

\begin_layout Plain Layout

c: C = C(3.0,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def matchfunc(in:Any):Unit = in match
\end_layout

\begin_layout Plain Layout

     | {
\end_layout

\begin_layout Plain Layout

     |   case B(string,integer) => println(string + integer.toString)
\end_layout

\begin_layout Plain Layout

     |   case x:C => println(x.double.toString+x.int.toString)
\end_layout

\begin_layout Plain Layout

     |   case _ => println("unknown type")
\end_layout

\begin_layout Plain Layout

     | }
\end_layout

\begin_layout Plain Layout

matchfunc: (in: Any)Unit
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> matchfunc(b)
\end_layout

\begin_layout Plain Layout

other string5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> matchfunc(c)
\end_layout

\begin_layout Plain Layout

3.03
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inheritance
\end_layout

\begin_layout Itemize
A trait is like an interface, a class with only abstract methods, but one
 that can also have default implementations of methods
\end_layout

\begin_layout Itemize
Classes and trait inherit from each other using 
\begin_inset Quotes eld
\end_inset

extends [first super] with [second super] with [third super]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
A class can inherit multiple traits.
 In the case where two traits have the same signature for different method
 implementations, the last trait to be inherited is the one whose implementation
 will be used.
 Inheriting two classes is not allowed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> trait Super
\end_layout

\begin_layout Plain Layout

defined trait Super
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> trait Side
\end_layout

\begin_layout Plain Layout

defined trait Side
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> trait Side2 
\end_layout

\begin_layout Plain Layout

defined trait Side2 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> case class Sub(int:Int) extends Super with Side with Side2
\end_layout

\begin_layout Plain Layout

defined class Sub
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inheritance is used very sparingly in this thesis.
\end_layout

\begin_layout Subsection
Iteration
\end_layout

\begin_layout Itemize
While works like C while loops
\end_layout

\begin_layout Itemize
For is a sequence comprehension which works much like in Python.
\end_layout

\begin_deeper
\begin_layout Itemize
The indices of sequences are represented by 32 bit integers so 
\begin_inset Quotes eld
\end_inset

for(x <- -1 until Int.MaxValue){println(x)}
\begin_inset Quotes erd
\end_inset

 won't work since 
\begin_inset Quotes eld
\end_inset

-1 until Int.MaxValue
\begin_inset Quotes erd
\end_inset

 is a range with Int.MaxValue +1 elements.
 Put differently, the last element's index in this case is higher than the
 maximum value of 32-bit integers, which is not allowed.
\end_layout

\begin_layout Itemize
It is possible to iterate over any sequence with the for syntax
\end_layout

\end_deeper
\begin_layout Itemize
FoldLeft, foldRight and fold allow combination of a sequence's elements,
 going left to right, right to left and in an undefined direction, respectively
\end_layout

\begin_layout Itemize
Map and flatMap allows transformation of one sequence to another by applying
 a function to all elements.
 FlatMap allows the function to additionally eliminate elements whose results
 will thereby not be a part of the resulting list.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> var int = 0
\end_layout

\begin_layout Plain Layout

int: Int = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> while(int<10){println(int); int=int+1}
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

3
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

6
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

8
\end_layout

\begin_layout Plain Layout

9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> for(x <- 0 until 10){println(x)}
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

3
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

6
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

8
\end_layout

\begin_layout Plain Layout

9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val list = List(0,1,2,3,4,5,6,7,8,9)
\end_layout

\begin_layout Plain Layout

list: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> for(x <- list){println(x)}
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

3
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

6
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

8
\end_layout

\begin_layout Plain Layout

9
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fold, foldLeft, foldRight, map and flatMap examples:
\end_layout

\begin_layout Itemize
fold is supplied with a function which produces a single value from two
 input values, all three of the same type, fold repeatedly uses this to
 produce a single value from a list.
 It takes two arguments using currying syntax; the first is the starting
 value and the second is the function used to fold two elements into one.
 It can be executed in parallel.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 2).fold(0)((left,right) => left+right) 
\end_layout

\begin_layout Plain Layout

res1: Int = 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 2).par.fold(0)((left,right) => left+right) 
\end_layout

\begin_layout Plain Layout

res2: Int = 3 
\end_layout

\end_inset

If the fold is executed in parallel, having the starting argument be non-zero
 or otherwise have consequence in application will give unexpected results:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 2).fold(1)((left,right) => left+right)
\end_layout

\begin_layout Plain Layout

res1: Int = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 2).par.fold(1)((left,right) => left+right) 
\end_layout

\begin_layout Plain Layout

res3: Int = 6 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 2).par.fold(1)((left,right) => left+right)
\end_layout

\begin_layout Plain Layout

res2: Int = 5
\end_layout

\end_inset

This is generally true: Mixing necessarily sequential operations and parallel
 collections is a bad idea, and a highly unfortunate pitfall for newcomers
 to Scala.
\end_layout

\begin_layout Itemize
foldLeft and foldRight are equivalent, except that the iteration over the
 list goes in opposite directions.
 In contrast to fold, the input and output types can be unequal.
 These can not be done in parallel.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 9).foldLeft("numbers")((string,number) => string+number.toString)
\end_layout

\begin_layout Plain Layout

res1: String = numbers0123456789
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 9).foldRight("numbers")((number,string) => number.toString+string)
\end_layout

\begin_layout Plain Layout

res2: String = 0123456789numbers
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
map
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 9).map(x=>x*x)
\end_layout

\begin_layout Plain Layout

res1: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 4, 9, 16, 25,
 36, 49, 64, 81)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 9).par.map(x=>x*x)
\end_layout

\begin_layout Plain Layout

res2: scala.collection.parallel.immutable.ParSeq[Int] = ParVector(0, 1, 4, 9,
 16, 25, 36, 49, 64, 81)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
flatMap
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 9).flatMap(x=>if(x%2==0){None}else{Some(x)})
\end_layout

\begin_layout Plain Layout

res1: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 3, 5, 7, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (0 to 9).flatMap(x=>if(x%2==0){None}else{Some(x*x)})
\end_layout

\begin_layout Plain Layout

res2: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 9, 25, 49, 81)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Together:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 9).par.flatMap(x=>if(x%2==0){None} else{Some(x*x)}).fold(0)((left,righ
t)=>left+right) 
\end_layout

\begin_layout Plain Layout

res1: Int = 165 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Container Types
\end_layout

\begin_layout Standard
Scala has several container types, some more exotic than others.
\end_layout

\begin_layout Itemize
Option allows handling of values which may or may not have any content.
 Both 
\begin_inset Quotes eld
\end_inset

Some(3)
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

None
\begin_inset Quotes erd
\end_inset

 can be passed as a parameter of type Option[Int].
 Options can be mapped, in which case the unwrapping of the contents and
 subsequent re-wrapping is handled automatically.
\end_layout

\begin_layout Itemize
Either allows handling of values which are one of two types.
 It's applicability is therefore a superset of that of Option.
 Left(3) and Right(
\begin_inset Quotes eld
\end_inset

str
\begin_inset Quotes erd
\end_inset

) can be passed as a parameter of type Either[Int, String]
\end_layout

\begin_layout Itemize
Sets are somewhat similar to arrays in that their size is fixed.
 However, each element can have a unique fixed type.
 So 
\begin_inset Quotes eld
\end_inset

(3, 
\begin_inset Quotes eld
\end_inset

str
\begin_inset Quotes erd
\end_inset

, 5.0)
\begin_inset Quotes erd
\end_inset

 is a set with type (Int, String, Double).
 specific places in the set are accessed using 
\begin_inset Quotes eld
\end_inset

set._n
\begin_inset Quotes erd
\end_inset

, where n is the 1-indexed index.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala>//Option:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def maybeSquare(in:Option[Int]):Option[Int] = in.map(x => x*x)
\end_layout

\begin_layout Plain Layout

maybeSquare: (in: Option[Int])Option[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maybeSquare(Some(3))
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maybeSquare(None)
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//Either:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def squareOrCube(in:Either[Int,Int]) = in match 
\end_layout

\begin_layout Plain Layout

     | {
\end_layout

\begin_layout Plain Layout

     |   case Left(x) => x*x
\end_layout

\begin_layout Plain Layout

     |   case Right(x) => x*x*x
\end_layout

\begin_layout Plain Layout

     | }
\end_layout

\begin_layout Plain Layout

squareOrCube: (in: Either[Int,Int])Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> squareOrCube(Left(3))
\end_layout

\begin_layout Plain Layout

res2: Int = 9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> squareOrCube(Right(3))
\end_layout

\begin_layout Plain Layout

res3: Int = 27
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>//set:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def change(in:(Int, String, Double)):(Int, String, Double) = (in._1*in._1,
 in._2+"ing", in._3)
\end_layout

\begin_layout Plain Layout

change: (in: (Int, String, Double))(Int, String, Double)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> change((3, "str", 5.0))
\end_layout

\begin_layout Plain Layout

res4: (Int, String, Double) = (9,string,5.0)
\end_layout

\end_inset


\end_layout

\begin_layout Section
C++11
\end_layout

\begin_layout Standard
This section covers only the features needed in order to understand the
 C++ code the compiler generates.
 The features listed below may or may not have additional capabilities to
 those mentioned:
\end_layout

\begin_layout Itemize
std::atomic provides atomic transactions for integral types, boolean and
 pointers.
 This means a load and a store operations to this variable will never happen
 concurrently.
\end_layout

\begin_layout Itemize
std::mutex is a traditional mutual exclusion lock.
\end_layout

\begin_layout Itemize
std::condition_variable provides a variable that threads can wait on.
 Subsequently, one or all threads waiting can be awakened.
 A thread that wishes to use it must hold a unique_lock first.
 Also allows timeouts on waiting.
\end_layout

\begin_layout Itemize
std::unique_lock allows more sophisitcated use of locks.
 It is not a mutex, but instead provides more ways to acquire and release
 locks on mutexes, including timed attempts at gaining locks and releasing
 locks when leaving the scope of the unique_lock.
\end_layout

\begin_layout Itemize
std::thread provides a standardized wrapping around Pthread and similar
 OS-specific thread libraries.
\end_layout

\begin_layout Section
Regular Expressions
\end_layout

\begin_layout Standard
Regular expressions are programs used to match strings of text.
 More specifically, they are finite automata capable of parsing regular
 languages.
 In practice, what is called 
\begin_inset Quotes eld
\end_inset

regular expressions
\begin_inset Quotes erd
\end_inset

 are often capable of parsing more than just regular languages due to extra
 features.
 The IEEE POSIX standard specifies their syntax.
\end_layout

\begin_layout Standard
The following explains enough to understand their use in this thesis:
\end_layout

\begin_layout Itemize
Square brackets match a single character if that character is inside the
 square brackets.
 For instance, 
\begin_inset Quotes eld
\end_inset

[ab]
\begin_inset Quotes erd
\end_inset

 matches either 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, while 
\begin_inset Quotes eld
\end_inset

[a-z]
\begin_inset Quotes erd
\end_inset

 matches all Latin lower case characters.
\end_layout

\begin_layout Itemize
A question mark (
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

) signifies that the preceding element can be matched one or zero times.
\end_layout

\begin_layout Itemize
Parentheses marks a subexpression.
\end_layout

\begin_layout Itemize
Backward slash (
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

) escapes the following character, allowing characters that would usually
 be interpreted as operators to be interpreted as actual character and vice
 versa.
 For instance, 
\begin_inset Quotes eld
\end_inset


\backslash
.
\begin_inset Quotes erd
\end_inset

 matches a period, while 
\begin_inset Quotes eld
\end_inset


\backslash
d
\begin_inset Quotes erd
\end_inset

 matches any digit.
\end_layout

\begin_layout Itemize
A plus sign (
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

) signifies that there are one or more of the preceding element
\end_layout

\begin_layout Itemize
A star (
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

) signifies that there are zero or more of the preceding element
\end_layout

\begin_layout Itemize
A vertical bar (
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

) signify that either the character to the left or the right is matched
\end_layout

\begin_layout Subsection*
Example
\end_layout

\begin_layout Standard
Integers are matched with this regular expression: 
\begin_inset Quotes eld
\end_inset

[-+]?(0|[1-9]
\backslash
d*)
\begin_inset Quotes erd
\end_inset

.
 First, there can optionally be a plus or minus sign, then comes the characters
 in the parenthesis: Either 0 or a number between 1 and 9 followed by a
 string of digits.
 
\begin_inset Quotes eld
\end_inset

00201
\begin_inset Quotes erd
\end_inset

 will not match, but 
\begin_inset Quotes eld
\end_inset

201
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

-201
\begin_inset Quotes erd
\end_inset

 will match.
\end_layout

\begin_layout Section
Deterministic Multithreading
\begin_inset CommandInset label
LatexCommand label
name "sec:Deterministic-Multithreading"

\end_inset


\end_layout

\begin_layout Standard
All material here is based on 
\begin_inset CommandInset citation
LatexCommand cite
key "merrifield2015highCONSEQUENCE"

\end_inset

 unless otherwise stated.
 This section is to be understood as a discussion of contemporary approaches
 to multithreading determinism - they have not influenced this thesis because
 their determinism models are generally less strict.
 
\end_layout

\begin_layout Standard
Deterministic multithreading is an active area of research.
 Two components are necessary for determinism:
\end_layout

\begin_layout Itemize
A deterministic logical clock, which orders synchronization operations determini
stically
\end_layout

\begin_layout Itemize
A deterministic memory consistency model, which ensures unsynchronized load
 operations have deterministic results
\end_layout

\begin_layout Subsection
Deterministic Logical Clock
\end_layout

\begin_layout Standard
There are two main approaches to this:
\end_layout

\begin_layout Itemize
Round-robin scheduling
\end_layout

\begin_layout Itemize
Instruction-count based scheduling
\begin_inset CommandInset citation
LatexCommand cite
key "olszewski2009kendo"

\end_inset


\end_layout

\begin_layout Standard
Both concern themselves with which thread's turn it is to do synchronization
 calls.
 In normal pthread systems, it is the thread which calls first that, say,
 acquires the lock.
 Round robin scheduling means that it is the thread that has gotten it last
 that will get it next.
 In instruction-count scheduling, the next recipient of the lock is determined
 by which thread has completed the least amount of instructions, with a
 tie-breaker.
 Notice that in the latter model, synchronization call order is not necessarily
 robust in the face of changing inputs, as some inputs may require more
 instructions to be performed than others.
 
\end_layout

\begin_layout Subsection
Deterministic Memory Consistency Model
\end_layout

\begin_layout Standard
The memory consistency model concerns itself with making guarantees about
 the determinism of memory access.
 Total Store Order (TSO) guarantees that all writes are globally visible
 in deterministic order, yet makes no guarantees about when.
 In both Dthreads and Consequence described below, synchronization of memory
 is done whenever there is a synchronization (for example 
\emph on
lock()
\emph default
) operation, which ensures determinism since the position of these operations
 are determined by the logical clock.
 This read determinism is then a result of implementation; TSO does not
 require it.
 Alternatives to TSO (for example DRF0
\begin_inset CommandInset citation
LatexCommand cite
key "devietti2011rcdc"

\end_inset

 and LRC
\begin_inset CommandInset citation
LatexCommand cite
key "lu2014efficient"

\end_inset

) relax the total store order requirements to guaranteeing that a write
 with respect to a synchronization object is only visible to the next thread
 that holds the synchronization object.
 While the computational result is the same, the total store order requires
 less memory than relaxed models, since all shared memory needs only one
 copy and thread-local writes will always be applied and memory freed.
 In relaxed models, memory copies will have to be made whenever a thread
 releases a synchronization object and freed when the synchronization object
 is locked by a new thread.
 This means memory use scales with the amount of synchronization objects.
 That said, relaxed models can be faster than TSO since individual threads
 can be isolated until they need updates, even while other threads synchronize
 memory among themselves.
\end_layout

\begin_layout Subsection
Dthreads
\end_layout

\begin_layout Standard
Dthreads
\begin_inset CommandInset citation
LatexCommand cite
key "liu2011dthreads"

\end_inset

 is a deterministic replacement for Pthreads, using round-robin scheduling
 and total store order.
 DTHREADS work by giving each thread, as declared in C/C++, its own process
 and then cleverly hiding this by reimplementing functions such as 
\emph on
getpid()
\emph default
 to give the same answer for all processes that make up the program.
 All threads do work in a parallel phase, and upon an event that triggers
 synchronization, for instance the acquisition of a lock, a serial phase
 is entered.
 The updates that any single thread applies to shared memory will be applied
 in deterministic order in the serial phase.
 
\end_layout

\begin_layout Subsection
Consequence
\end_layout

\begin_layout Standard
Consequence
\begin_inset CommandInset citation
LatexCommand cite
key "merrifield2015highCONSEQUENCE"

\end_inset

 is, like Dthreads, an deterministic implementation for C/C++.
 It uses instruction-count based scheduling and provides total store order.
 Instruction-count based scheduling allows Consequence to be faster than
 Dthreads.
 The downside is that Consequence is nondeterministic in the face of changing
 input and also changes behavior when inserting debugging operations like
 print-statements.
 Consequence relies on Conversion, a kernel-implemented version control
 system, for the memory consistency model.
 Like in Dthreads, each thread is actually run in its own process.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
There are related work which also tries to make multithreaded programs easier
 to work with, using custom compilers or languages extensions.
 Among these are CoreDet and Deterministic Parallel Java.
 CoreDet is a custom compiler for C/C++ made by modifying LLVM.
 Deterministic Parallel Java is a language extension for Java.
 Given that they are about making multithreading easier they are worth mentionin
g, even though they have not influenced this thesis.
\end_layout

\begin_layout Subsection
CoreDet
\end_layout

\begin_layout Standard
CoreDet is 
\begin_inset Quotes eld
\end_inset

[a] compiler and runtime system that runs arbitrary multithreaded C/C++
 POSIX Threads programs deterministically
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bergan2010coredet"

\end_inset

.
\end_layout

\begin_layout Subsection
Deterministic Parallel Java
\end_layout

\begin_layout Standard
DPJ extends Java with a deterministic features.
 It is built on the idea of 
\emph on
regions.

\emph default
 The programmer divides memory into regions by annotating classes, and thereafte
r annotates methods with effect summaries stating which regions are read
 and written by a method.
 
\begin_inset Quotes eld
\end_inset

The compiler uses the class types and method effect summaries to check that
 all concurrent (read, write) and (write, write) pairs of accesses to the
 same region are disjoint
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "bocchino2009parallel"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DPJ"

\end_inset

.
\end_layout

\begin_layout Chapter
Specification
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
It was decided that an approach belonging to the tradition of synchronous
 programming would be the best choice for this thesis, as described in the
 background chapter.
 Given the importance of a familiar superficialities for language adoption
\begin_inset CommandInset citation
LatexCommand cite
key "meyerovich2013empiricalProgrammingLanguageAdoption"

\end_inset

, it was decided that the language should have a familiar C/Algol-style
 syntax, rather than invent or adopt something less common.
\end_layout

\begin_layout Subsubsection*
A Note on the Finality of This Specification
\end_layout

\begin_layout Standard
Much of what has been specified has not been implemented.
 While everything has been given thought, this thought has not been distributed
 equally, but concentrated on the basic things and that which has been implement
ed.
 Everything herein, especially that which is left unimplemented, is to be
 considered preliminary.
 Future work should not give this specification undue consideration.
\end_layout

\begin_layout Section
Language Design Goals
\end_layout

\begin_layout Standard
It is the goals of Fumurt to aid in producing correct programs suitable
 for real-time applications in general, and such multithreaded programs
 in particular.
\end_layout

\begin_layout Section
Runtime Execution Model
\begin_inset CommandInset label
LatexCommand label
name "sec:Runtime-Execution-Model"

\end_inset


\end_layout

\begin_layout Standard
The goal of the programming language is to make a multithreaded program
 behave as predictably as were it single-threaded and, more generally, to
 help create reliable applications.
 A corollary of this is that only changes of state that are visible to a
 single thread can happen concurrently.
 All IO and inter-thread communication are required happen in a statically
 determined sequence.
 One way to do this is to have the program have two alternating phases:
\end_layout

\begin_layout Itemize
Computational phase: In which computations local to a thread are performed.
\end_layout

\begin_layout Itemize
Communicative phase: In which IO is effected and shared variables are updated,
 all in a single-threaded manner.
\end_layout

\begin_layout Standard
In the computational phase, the order in which computations are performed
 on the processor is irrelevant as nothing is shared between the thread
 and the rest of the world.
 Since the threads have no effect on each other or the outside world in
 this phase, the only difference between concurrent execution and sequential
 execution is speed.
 In the communicative phase, however, execution has to be single threaded.
 This is similar to Dthreads
\begin_inset CommandInset citation
LatexCommand cite
key "liu2011dthreads"

\end_inset

, except here IO sequence is also deterministic and only one thread per
 synchronized variable have write rights to a synchronized variable.
 Having only one thread have write privileges means last-writer-wins semantics
 are avoided, in which everything but the last write since the start of
 the computational phase will never be visible to other threads.
 This seems like it would very rarely be the programmer's intended behavior.
\end_layout

\begin_layout Standard
Using this scheme, the application appears to be single threaded both to
 itself and to the rest of the world, all the while enabling separation
 of concerns and better utilization of multi-core systems.
 The following figure illustrates the principle:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename architecture.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
In terms of the actual execution a more detailed figure is offered:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailed.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Observe that in the computational stage parallel list transformations like
 map and fold or even futures can be made available, without affecting the
 outward behavior of the system, except for performance:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailedwithmap.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Futures and parallel list comprehensions are together applicable to all
 problems which can be divided into subproblems that can be done in parallel
 without communication.
 Futures are a bit of extra work to deal with, but the map-and-fold pattern,
 sometimes called mapReduce
\begin_inset CommandInset citation
LatexCommand cite
key "dean2008mapreduce"

\end_inset

, is easy to use and widely applicative to many problems.
\begin_inset CommandInset citation
LatexCommand cite
key "borthakur2011apache"

\end_inset

 Indeed, map-and-fold is intensely used in the Fumurt compiler.
 Supporting map-and-fold and futures reduces the performance problems of
 all threads waiting on each other significantly as long as it can be applied
 to the most time-consuming task.
\end_layout

\begin_layout Standard
The overall effect of this execution model is that phases per second becomes
 an important measure of responsiveness of the system.
\end_layout

\begin_layout Section
Inter-thread communication
\end_layout

\begin_layout Standard
Inter-thread communication is provided by synchronized variables.
 These are variables to which one thread has write rights, while all threads
 has read rights.
 The writes to a synchronized variable are effected so that all threads
 can read them during the communication phase.
 Having only one thread have write rights circumvents the entire problem
 of store order, and makes sure the programmer doesn't have to worry about
 the order in which a synchronized variable is written to by the different
 threads.
\end_layout

\begin_layout Section
Input and Output
\end_layout

\begin_layout Standard
Input and output sequence must be deterministic.
 To achieve this, output requests are placed in a queue, and are written
 to the output devices during the communicative phase.
 Whenever input is desired, the thread will immediately pause and wait for
 the communicative phase, during which the input will be returned to the
 thread.
 In the case where several pieces of input and output do not depend on each
 other, they can be combined to a composite IO action, whose effects will
 be performed in the same communicative phase.
 The syntax for this is left unspecified.
 
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
Syntax is by definition somewhat arbitrary but, as Brainfuck demonstrates,
 some syntaxes are better than others.
 The following goals were decided upon:
\end_layout

\begin_layout Itemize
Look modern and familiar.
 This is supposed to make it easier to learn, as well as more appealing
 to someone evaluating whether to learn it.
 
\end_layout

\begin_layout Itemize
Be simple.
 For ease of implementation.
\end_layout

\begin_layout Itemize
Be predictable, and aid the programmer in the understanding of the program.
\end_layout

\begin_layout Standard
A language made as part of a master thesis is simple by necessity.
 The two other goals require more explanation:
\end_layout

\begin_layout Subsection
Modern and Familiar
\end_layout

\begin_layout Standard
Fumurt adopts several conventions from contemporary languages:
\end_layout

\begin_layout Itemize
Separating expressions with line endings instead of special characters (for
 example semicolon).
\end_layout

\begin_layout Itemize
Employ 
\begin_inset Quotes eld
\end_inset

instanceOfType:Type
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

Type instanceOfType
\begin_inset Quotes erd
\end_inset

 when declaring the type of something.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 is used to perform definitions and mark the boundaries of blocks with brackets
\end_layout

\begin_layout Standard
This results in syntax with a distinctly modern look:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {x}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One might wish for brackets to be optional in such one-liners, though, 
\end_layout

\begin_layout Subsection
Predictable and Helpful
\end_layout

\begin_layout Standard
Although modern languages and their type systems have made the use of functions
 safe, the syntax of modern languages insufficiently aid the programmer
 in understanding what a function does, as it is called:
\end_layout

\begin_layout Itemize
Functions that perform IO or mutate shared variables are called actions
 and their names must begin with 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

, like so:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionPrintFoo:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("  FOO   ")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Similarly thread names begin with 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 and synchronized variable names begin with 
\begin_inset Quotes eld
\end_inset

synchronized
\begin_inset Quotes erd
\end_inset

.
 This means that one can observe much about the properties of a call or
 a variable where it is used without looking up the definitions.
\end_layout

\begin_layout Itemize
Function arguments, if there are more than one, are distinguished not by
 relative position, but by name (as is optionally available in Python).
 Here is presented a call to the if function and some calls to the toString
 function:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(condition=true, then=toString(1), else=toString(0))
\end_layout

\end_inset

Type classes are an alternative to named arguments, the idea being that
 you have one type per role a variable can play.
 There are multiple problems with this:
\end_layout

\begin_deeper
\begin_layout Itemize
It's unnecessarily verbose.
 Worst case, you'll end up with one type class declaration per argument.
\end_layout

\begin_layout Itemize
Because it's unnecessarily verbose, the temptation will be to use the same
 type class everywhere or just use a base class (like Integer) instead.
 Which would mean that we're back at square one.
\end_layout

\end_deeper
\begin_layout Section
Scope
\end_layout

\begin_layout Standard
Among the goals of this programming language is to help the programmer understan
d the program.
 One way this is done is to make dependencies between functions explicit
 via 
\emph on
inclusions
\emph default
.
 It is common among languages for changes in one function to affect the
 correctness of seemingly unrelated parts of the program.
 In the following example, changing the definition of function c affects
 the output of function a:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionA:Nothing = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  b()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionB:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  c()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionC:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("string")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While the above example is a bit contrived, it illustrates the problem.
 Using inclusions, the dependencies become explicit:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionA(b:Inclusion, c:Inclusion):Nothing = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  b(c=c)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionB(c:Inclusion):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  c()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionC:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("string")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that inclusions are not functions as arguments - the passed function
 and the name of the inclusion must have the same name; it is simply there
 to make dependencies between functions explicit.
\end_layout

\begin_layout Standard
In keeping with the goal of being modern and familiar, definitions of functions
 inside other definitions of functions are allowed.
 Recursive function definitions, that is.
 This means that developers can hide functions inside other functions when
 they are not needed outside them.
 Inclusions are not needed when functions are defined inside each other,
 as dependence is implied.
\end_layout

\begin_layout Section
Pointers
\end_layout

\begin_layout Standard
There are no pointers in the language.
 Any pointers required by C++ is to be hidden by Fumurt.
 This is because pointers are colloquially as well as formally
\begin_inset CommandInset citation
LatexCommand cite
key "milne2002difficulties"

\end_inset

 known to be hard to understand.
 Programmers should be able to specify specific memory ranges that can later
 be written to with functions.
 These are intended to be used only when the programmer needs to store data
 to specific addresses.
\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are functions with two arguments and the function name in between
 the arguments.
 There are multiple problems with them:
\end_layout

\begin_layout Enumerate
Convention suggests that their names should be information-anemically short,
 often one character.
 This is obviously problematic
\end_layout

\begin_layout Enumerate
It can be hard to figure out what role the different arguments have
\end_layout

\begin_layout Enumerate
Operator precedence for user-defined operators is tricky.
 For math operators there's convention, but for user-defined ones this may
 be confusing for users of those operators
\end_layout

\begin_layout Standard
A prime example of unhelpful operator names can be found in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

.
\end_layout

\begin_layout Standard
Any good solutions to this have not been found, to the author's knowledge,
 but it's hard to argue with the convenience of operators.
 Some predictability to operators are provided by enforcing the following
 rules:
\end_layout

\begin_layout Enumerate
Either the types of the two arguments has to be the same or one of the types
 have to be a container type of the other.
 For example Int and Int or List[Int] and Int.
\end_layout

\begin_layout Enumerate
There's no operator precedence, it has to be defined on a use-by-use basis
 using parentheses.
 Ambiguous use of operators are not allowed.
\end_layout

\begin_layout Section
Immutability
\end_layout

\begin_layout Standard
Mutable variables are a major source of bugs, and even experienced developers
 create bugs when a variable that would have held the correct information
 previously no longer holds that information.
 At the same time mutable variables are needed in order to share information
 across threads.
 Therefore mutable variables are disallowed, except the synchronized variables
 that are shared across threads.
 
\end_layout

\begin_layout Subsection
Loops
\end_layout

\begin_layout Standard
Loops are familiar for many people, yet are usually not included in languages
 with only immutable values, because their utility is pretty limited.
 However, they are convenient and they are equivalent to tail-recursion.
 The major advantages of tail recursion over looping is that the assignment
 and dependencies are explicit.
 And yet loops are far easier to understand
\begin_inset CommandInset citation
LatexCommand cite
key "milne2002difficulties"

\end_inset

.
 Loops that are as safe as tail recursion while being almost as friendly
 as common loops are possible:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

value y:Int = 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

value x:Int = loop(y=y,x=y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if(
\end_layout

\begin_layout Plain Layout

  condition=(y>0), 
\end_layout

\begin_layout Plain Layout

  then=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

  x = x*y 
\end_layout

\begin_layout Plain Layout

  y = y-1
\end_layout

\begin_layout Plain Layout

  continue
\end_layout

\begin_layout Plain Layout

  }, 
\end_layout

\begin_layout Plain Layout

  else=break)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All variables passed to the loop would then need to be copied.
 In the example above, the y modified inside the loop cannot be the same
 that is defined outside it.
 Such scoping of variables are common in function calls, and a similar mechanism
 can be used for loops.
\end_layout

\begin_layout Standard
An additional benefit of loops is that their use has constant memory consumption
 independent of number of iterations.
 While the same can be achieved for recursion using tail recursion with
 optimizing compilers, such compilers are still not the norm.
 Mutual tail recursion optimization is particularly rare.
 Since optimizations are not an immediate goal for the Fumurt compiler,
 loops would offer an important guarantee for the programmer.
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Subsection
Classes
\end_layout

\begin_layout Standard
In trying to be familiar, it is desirable to provide types along with their
 popular object oriented nomenclature.
 So classes are present, just that they are immutable.
 They are defined by their constructors, optionally with extra static methods:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class IntAndString(int:Integer, string:String) = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  function combine:String = {concatenate(left=toString(int), right=string)}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

value x = IntAndString(int=3, string="something")
\end_layout

\begin_layout Plain Layout

actionPrint(x.combine)
\end_layout

\begin_layout Plain Layout

actionPrint("==")
\end_layout

\begin_layout Plain Layout

actionPrint(concatenate(left=toString(x.int), right=x.string))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fumurt does not have inheritance, because while inheritance means you get
 code reuse, it also obscures the class that inherits.
 When one class inherits from a hierarchy, one needs to understand not only
 what's written about that class but also the entire hierarchy in order
 to understand the end result.
\end_layout

\begin_layout Standard
In order to aid the programmer in understanding their own and others' code,
 the names of types always lead with a capital letter.
 Conversely, leading with a capital letter for anything else is illegal.
\end_layout

\begin_layout Subsection
Interfaces
\end_layout

\begin_layout Standard
All classes are interfaces, but one can also create interfaces that aren't
 classes using the 
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 keyword.
 When implementing an interface one explicitly have to note what interfaces
 the class is implementing.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

interface IntAndString(int:Integer, string:String)
\end_layout

\begin_layout Plain Layout

//or
\end_layout

\begin_layout Plain Layout

class IntAndString(int:Integer, string:String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class IntAndStringAndBool(int:Integer, string:String, bool:Boolean) implements
 IntAndString
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Standard
Modules are singletons containing only immutable values, actions and functions.
 They can therefore serve as libraries.
 Their scope is handled the same way functions' scope is.
 This avoids the problem where singletons are global entities and functions'
 dependence on them are completely obscure.
\end_layout

\begin_layout Section
Program Declaration
\end_layout

\begin_layout Standard
The program declaration is meant to give a high level overview of the behavior
 of the program.
 It declares what threads are spawned, in what sequence their IO should
 be enacted, which synchronized variables exist and which threads have write
 permission to which variable.
\end_layout

\begin_layout Section
Built-in Functions
\end_layout

\begin_layout Standard
Fumurt provides the following built-in functions:
\end_layout

\begin_layout Itemize
toString(x) gives a string representation of x
\end_layout

\begin_layout Itemize
actionPrint(x) prints the string x
\end_layout

\begin_layout Itemize
actionMutate(variable, newValue) assigns the newValue to the synchronized
 variable 
\end_layout

\begin_layout Itemize
if(condition, then, else) returns result of 
\emph on
then
\emph default
 if 
\emph on
condition
\emph default
 is true and returns 
\emph on
else
\emph default
 if it is not
\end_layout

\begin_layout Itemize
plus(left, right) returns 
\begin_inset Formula $left+right$
\end_inset


\end_layout

\begin_layout Itemize
minus(left, right) returns 
\begin_inset Formula $left-right$
\end_inset


\end_layout

\begin_layout Itemize
divide(left, right) returns 
\begin_inset Formula $\frac{left}{right}$
\end_inset


\end_layout

\begin_layout Itemize
multiply(left, right) returns 
\begin_inset Formula $left*right$
\end_inset


\end_layout

\begin_layout Itemize
equal(left, right) returns 
\begin_inset Formula $left==right$
\end_inset


\end_layout

\begin_layout Chapter
Analysis and Design
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Choice of Intermediate Target
\end_layout

\begin_layout Standard
For easy debugging and wide selection of binary targets it was decided to
 first compile to an intermediate language and then let an external compiler
 perform the final transformation to binary form.
 This is a well-trodden path
\begin_inset CommandInset citation
LatexCommand cite
key "hall1993glasgowHaskellToC"

\end_inset

, and C is often used.
 Though many modern languages would be suitable for this, a wish list of
 features determined which language to choose:
\end_layout

\begin_layout Enumerate
No garbage collection or other other source of run-to-run variability.
\end_layout

\begin_layout Enumerate
Wide selection of final targets, including embedded.
\end_layout

\begin_layout Enumerate
Low overhead, whether in performance or memory.
 
\end_layout

\begin_layout Enumerate
A solid set of features to make transformation into the language easier.
 
\end_layout

\begin_layout Enumerate
Mature standard that is unlikely to break backwards compatibility.
\end_layout

\begin_layout Enumerate
One, preferably more, good and mature open source implementations available.
\end_layout

\begin_layout Enumerate
Possibility of running without an operating system.
\end_layout

\begin_layout Standard
C++ seems to satisfy all these criteria, and were therefore selected as
 the intermediate language.
 Its main competitor, C, has too few features, which means a compiler would
 have to make more difficult transformations and/or things like linked lists
 would have to be manually implemented.
 Such difficulties seem unnecessary.
\end_layout

\begin_layout Section
Choice of Compiler Implementation Language
\end_layout

\begin_layout Standard
Scala was chosen as the implementation language for the compiler partly
 because it's what the author used in the TU Berlin compiler bau course
 (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TUB course"

\end_inset

) and already had lots of experience in, but it also has some highly attractive
 qualities for making a compiler:
\end_layout

\begin_layout Itemize
Solid type checking which makes the code easier to work with, especially
 when refactoring
\end_layout

\begin_layout Itemize
A wide selection of functional abstractions, which allows compact code and
 eliminates simple but irritating bugs as well as access to imperative construct
s like loops etc.
 when this is more convenient
\end_layout

\begin_layout Itemize
A parser combinator library
\end_layout

\begin_layout Itemize
Fast execution time
\end_layout

\begin_layout Standard
Other languages under consideration were C, C++ and Haskell.
 C has inadequate abstractions and lackluster type checking.
 While C++ has much better abstractions, its type checking is still not
 strict enough to prevent many of the errors that would undoubtedly have
 been made during development.
 Haskell has all the features necessary, but the author had previously had
 problems learning it.
 It was also a concern that Haskell does not provide non-functional mechanisms,
 even when these are the best solution to a problem.
\end_layout

\begin_layout Section
Choice of C++ Compiler
\end_layout

\begin_layout Standard
There were two compilers under consideration: GCC and Clang.
 While Clang is in many ways the better compiler, GCC is installed by default
 on most Unix systems.
 That leaves Windows.
 After some trial and error, it was found that installing a C++11 compliant
 standard library was difficult on Windows, and that the by far easiest
 solution on Windows is to install Visual Studio and use the Microsoft Visual
 C++ compiler.
 In the end it was decided that the Fumurt compiler will compile the C++
 code using GCC, unless it is run on Windows, in which case it will ask
 the user to compile the C++ code using Visual C++ manually.
 This is quite clearly the lesser evil, rather than a particularly good
 solution.
\end_layout

\begin_layout Section
Synchronization Mechanisms in The Intermediate Language
\end_layout

\begin_layout Standard
Our execution model formulated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Runtime-Execution-Model"

\end_inset

 needs to be formulated in the compiled C++ code.
\end_layout

\begin_layout Itemize
Each thread gets its own printList (type std::list<std::string>), and actionPrin
ts are translated into printList.push_back.
 The same principle can be used for future output as well.
 When the threads are finished with the computational phase, the last thread
 to finish will print printList.pop_front until the printList is empty.
 The thread started first in the program statement gets its printList emptied
 first, and so on.
\end_layout

\begin_layout Itemize
A rendezvous pattern is used:
\end_layout

\begin_deeper
\begin_layout Enumerate
A macro NUMTOPTHREADS, with the number of threads defined in the program
 statement is defined
\end_layout

\begin_layout Enumerate
A static std::atomic<int> rendezvousCounter, which holds the number of threads
 that have arrived at the rendezvous point is defined.
\end_layout

\begin_layout Enumerate
A static std::mutex rendezvousSyncMutex and a static std::condition_variable
 cv are defined.
\end_layout

\begin_layout Enumerate
For each synchronized variable in the source code, one variable which holds
 the global state of this variable and one which holds the local state of
 this variable in the thread that is allowed to write to it is defined.
\end_layout

\begin_layout Enumerate
A [[noreturn]] static void threadName() is defined for each thread, holding
 its values.
 All arguments to thread in the source code are converted to static global
 variables.
 If the platform is Windows, 
\begin_inset Quotes eld
\end_inset

__declspec(noreturn)
\begin_inset Quotes erd
\end_inset

 is used instead of 
\begin_inset Quotes eld
\end_inset

[[noreturn]]
\begin_inset Quotes erd
\end_inset

, since Microsoft Visual C++ does not support C++11 syntax for attributes.
\end_layout

\begin_layout Enumerate
A main function is defined, inside of which:
\end_layout

\begin_deeper
\begin_layout Enumerate
rendezvousCounter is set to 0, threads (std::thread) are started with the
 thread functions (defined in previous step) as arguments and finally the
 main function enters a loop executing std::this_thread::sleep_for( std::chrono:
:seconds(1) ).
\end_layout

\end_deeper
\begin_layout Enumerate
static void waitForRendezvous(std::string name) which a thread calls when
 it is ready to wait, is defined.
 Inside of which:
\end_layout

\begin_deeper
\begin_layout Enumerate
The thread locks the rendezvousSyncMutex
\end_layout

\begin_layout Enumerate
Increments the rendezvousCounter
\end_layout

\begin_layout Enumerate
If the value in the rendezvousCounter is less than NUMTOPTHREADS, the thread
 waits using cv.wait, at which point rendezvousSyncMutex will be automatically
 unlocked.
 If the rendezvousCounter equals NUMTOPTHREADS, the thread prints all strings
 held in the printLists as described above, sets any global synchronized
 variables to its writer-local values, sets rendezvousCounter to 0 and finally
 notifies all other threads using cv.notify_all before exiting the function.
 rendezvousSyncMutex is unlocked on function exit.
 Example of a generated waitForRendezvous function:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=c++}
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static void waitForRendezvous(std::string name)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  std::unique_lock<std::mutex> lk(rendezvousSyncMutex);
\end_layout

\begin_layout Plain Layout

  ++rendezvousCounter;
\end_layout

\begin_layout Plain Layout

  if(rendezvousCounter.load() < NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cv.wait(lk);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if (rendezvousCounter.load() == NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    while(!printthreadPrintHello.empty())
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      std::cout << printthreadPrintHello.front();
\end_layout

\begin_layout Plain Layout

      printthreadPrintHello.pop_front();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	/*similarly for other thread print lists*/
\end_layout

\begin_layout Plain Layout

    synchronizedNumber = writeSynchronizedNumber; //where synchronizedNumber
 is the name of a synchonized variable
\end_layout

\begin_layout Plain Layout

	//similarly for other synchronized variables
\end_layout

\begin_layout Plain Layout

    rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

    cv.notify_all();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  /*abnormal situation diagnostics mechanism here*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
A Need for Annotation
\end_layout

\begin_layout Standard
Technically, the finished code can always be determined directly from the
 AST, but it was discovered that in order to do this in the Fumurt case,
 the same rules would have to be encoded into the code in several different
 places.
 In the current state of implementation, there are two rules that require
 annotation.
 The first was the rule for determining the C++ names of function and the
 second is the rule for naming arguments to threads.
 In both cases, Fumurt's semantics are very different from C++'s.
 There are four aspects to the naming: 
\end_layout

\begin_layout Enumerate
Actions and functions that are in other functions need to get new names
 because the hierarchy needs to be flattened
\end_layout

\begin_layout Enumerate
Actions need to be demultiplexed, as the C++ code they contain needs to
 be different depending on which thread calls that action.
 For instance, an actionPrint needs to be transformed to a push to a list
 whose name depends on the calling thread
\end_layout

\begin_layout Enumerate
Function calls need to be changed so they refer to the new names
\end_layout

\begin_layout Enumerate
Arguments to threads need to have new C++ names that will be globally unique.
 
\end_layout

\begin_layout Standard
This can be accomplished by doing two passes over the AST.
 In the first pass, all function definitions and thread arguments are annotated
 with their C++ names.
 In the last pass, all function calls are annotated with the C++ name of
 the function they call, copying from the annotation done in pass one.
 
\end_layout

\begin_layout Section
Limitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Limitations"

\end_inset


\end_layout

\begin_layout Standard
While the specification and design is satisfactory, there are many ways
 in which it could be improved:
\end_layout

\begin_layout Itemize
There are no compound statements, except in the right hand side of definitions
\end_layout

\begin_layout Itemize
Definition right hand demarcation of the begin..end [function/x] type (for
 example begin..end loop) should be optional, as it can be helpful when reading
 and writing deeply nested expressions, where exactly what it is that is
 ending can often be unclear.
\end_layout

\begin_layout Itemize
Performance of the current execution model may be a concern for some application
s.
 Allowing programmer-defined synchronization intervals would allow for greater
 performance without sacrificing predictability.
 The programmer could then specify that computation-heavy threads participate
 in only every Nth communication phase.
 In cases where the appropriate performance and responsiveness requires
 sacrifices to predictability, it seems prudent to evaluate the possibility
 of using an instruction-based logical clock system when the programmer
 specifies it.
 Systems such as Consequence
\begin_inset CommandInset citation
LatexCommand cite
key "merrifield2015highCONSEQUENCE"

\end_inset

 may make it possible to obtain greater performance in cases where the programme
r can allow predictability requirements to be relaxed.
 Likewise, software transactional memory could be interesting, particularly
 when a thread needs to wait on input from an unpredictable source, like
 a human, while the rest of the threads needs to be responsive.
\end_layout

\begin_layout Itemize
The design of Fumurt centers around predictability, but in order to guarantee
 any predictability we have to assume correctness of the underlying hardware.
 Fumurt is by design not fault-tolerant, because fault tolerance deals with,
 and causes, unpredictability.
 This is in many cases insufficient.
 It would be beneficial if it was possible to construct some system wherein
 multiple computers or chips running Fumurt code could be coordinated by
 a system that does deal with fault-tolerance.
 Erlang with OTP is often used for such applications, but no study has been
 carried out regarding how to combine Erlang and Fumurt.
\end_layout

\begin_layout Itemize
As it is, the design of Fumurt has some, but very little empirical underpinnings.
 User surveys concerning how the various aspects of the language are received
 , particularly by novice programmers, would shed light on whether all the
 ideas introduced in this report are actually good ideas.
 
\end_layout

\begin_layout Itemize
There is no appropriate response in the cases where the IO buffers can no
 longer fit in memory.
 A solution which would degrade performance but otherwise work well, would
 be to pause all threads trying to put IO into a full memory while letting
 the thread whose IO are to be effected first write directly to IO.
 Once that first thread is finished, the second thread whose IO shall be
 effected can write directly to IO and so on until all threads are ready
 to enter the communicative phase.
 This will serialize execution, which can degrade performance.
 In those cases where responsiveness is more important than strict IO sequential
ity, special mechanisms may be provided whereby the programmer can specify
 that in such cases IO buffers shall be emptied to IO during the computational
 phase.
\end_layout

\begin_layout Itemize
Recursion can cause a stack overflow, leading to a segmentation fault.
 With the exception of the recursion happening when a thread recurses on
 itself, no recursion is optimized away.
  This is problematic in a critical-application system.
 Some types of recursion are easy to optimize away, some less so.
 The appropriate behavior for the compiler towards recursion it can't optimize
 away is undetermined.
\end_layout

\begin_layout Itemize
There is no mechanism for direct access to memory, which is often needed
 in embedded programming
\end_layout

\begin_layout Itemize
There are no lists, arrays or similar sequences.
 Likewise, loops, values, operators and user-defined types are missing.
\end_layout

\begin_layout Chapter
Implementation
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The compiler consists of four parts: The scanner, parser, checker and code
 generator.
 There is no optimizer, although the requirement for no dynamic destruction
 or creation of threads allows us to use a loop in threads instead of just
 recursion.
 This is necessary because neither Clang nor GCC could correctly optimize
 that tail recursion into a loop in testing, leading to an inevitable stack
 overflow.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename compiler.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Consider the steps taken by the compiler:
\end_layout

\begin_layout Enumerate
The code is scanned.
 If there is an error it's printed and compilation ended.
 Note that neither scanner nor parser are advanced enough to detect more
 than one error at a time.
 
\end_layout

\begin_layout Enumerate
The tokens from the scanner is parsed.
 If there is an error it's printed and compilation ended.
 
\end_layout

\begin_layout Enumerate
The AST from the parser is handed to the checker, which looks for any semantic
 errors.
 If there are any, they are printed out and compilation ended.
\end_layout

\begin_layout Enumerate
The AST from from the parser is given to the code generator, which produces
 C++ code conforming to the C++11 standard.
\end_layout

\begin_layout Enumerate
GCC is used to compile the C++ code to native binaries.
\end_layout

\begin_layout Section
Scanner
\end_layout

\begin_layout Standard
Scanners, it should be noted, are sometimes called lexers.
 Drawing on experience from the TU Berlin course (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TUB course"

\end_inset

), the Scala Standard Parser Combinator Library was chosen.
 
\end_layout

\begin_layout Standard
Parsers for individual tokens are formed like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def intParser: Parser[IntegerT] = positioned( new Regex("""(0|[1-9]
\backslash
d*)""") ^^ {x => IntegerT(x.toInt)} )
\end_layout

\begin_layout Plain Layout

def equalParser: Parser[EqualT] = positioned( new Regex("=") ^^ {x => EqualT()}
 )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parsers are then combined into the final scanner using the alternate
 operator (
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "ScalaParserCombinatorDoc"

\end_inset

.
\end_layout

\begin_layout Standard
It all goes into a list of tokens.
 The tokens are defined like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

abstract class Token() extends Positional
\end_layout

\begin_layout Plain Layout

abstract class DefDescriptionT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class BasicValueT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class SyntaxT() extends Token
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class TrueT() extends BasicValueT {override def toString = "true"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Positional
\begin_inset CommandInset citation
LatexCommand cite
key "ScalaParserPositional"

\end_inset

 is a trait that gives the token a Position.
 The 
\begin_inset Quotes eld
\end_inset

positioned
\begin_inset Quotes erd
\end_inset

 call in the parsers assigns the Position to the token.
 This is all inherited from the parser combinator library, so it's hard
 to understand what's going on from looking at the source alone.
 The 
\begin_inset Quotes eld
\end_inset

positioned
\begin_inset Quotes erd
\end_inset

 call assigns the source code position of the input text to the token object
 produced by the parser, which allows us to output really nice error messages
 later on.
\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
scan(in:String):Either[NoSuccess, List[Token]] 
\emph default
takes the source file as a string and either outputs a list of tokens or
 an error message
\end_layout

\begin_layout Itemize

\emph on
scanInternal:Parser[Token]
\emph default
 is the internal scanner.
 The parser combinator library will use this to create a parser to serve
 as scanner at compile time
\end_layout

\begin_layout Itemize
x
\emph on
Parser: Parser[XT] 
\emph default
parses that particular type of token, for example 
\emph on
newlineParser: Parser[NewlineT]
\end_layout

\begin_layout Paragraph*
Classes
\end_layout

\begin_layout Itemize
The scanner uses token classes.
 These are held in Ast.scala
\end_layout

\begin_layout Section
Parser
\end_layout

\begin_layout Standard
Like in the scanner, the Scala Standard Parser Combinator Library was used.
 Unfortunately, the tasks of the parser is a bit more complicated than those
 of the scanner, and the code reflects this.
\end_layout

\begin_layout Subsection
Grammar
\end_layout

\begin_layout Standard
The grammar serves as a formal definition of the language.
 Though not needed in order to understand the language, it is included for
 completeness.
 Here's the EBNF (
\begin_inset CommandInset citation
LatexCommand cite
key "wirth1996extended"

\end_inset

) for the grammar, as implemented:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prog = paddedDef, {paddedDef}, EoF;
\end_layout

\begin_layout Plain Layout

paddedDef = {"
\backslash
n"}, def, {"
\backslash
n"};
\end_layout

\begin_layout Plain Layout

def = deflhs, "=", {"
\backslash
n"}, defrhs;
\end_layout

\begin_layout Plain Layout

deflhs = defdescription, id, args, ":", type;
\end_layout

\begin_layout Plain Layout

args = ("(", id, ":", type, {subsequentArg}) | "";
\end_layout

\begin_layout Plain Layout

subsequentArg = ",", id, ":", type;
\end_layout

\begin_layout Plain Layout

defrhs = "{", {"
\backslash
n"}, expression, {("
\backslash
n", {"
\backslash
n"}, expression)}, {"
\backslash
n"}, "}";
\end_layout

\begin_layout Plain Layout

expression = def | statement;
\end_layout

\begin_layout Plain Layout

statement = functionCall | basicStatement | identifierStatement;
\end_layout

\begin_layout Plain Layout

callargs = "(", (namedcallargs|callarg), ")";
\end_layout

\begin_layout Plain Layout

callarg = statement | "";
\end_layout

\begin_layout Plain Layout

namedcallargs = namedcallarg, subsequentnamedcallarg, {subsequentnamedcallarg};
\end_layout

\begin_layout Plain Layout

subsequentnamedcallarg = ",", namedcallarg;
\end_layout

\begin_layout Plain Layout

namedcallarg = id, "=", callarg;
\end_layout

\begin_layout Plain Layout

functionCall = id, callargs;
\end_layout

\begin_layout Plain Layout

identifierStatement = id;
\end_layout

\begin_layout Plain Layout

defdescription = "program" | "action" | "thread" | "function" | "value";
\end_layout

\begin_layout Plain Layout

basicStatement = boolean | string | integer | float;
\end_layout

\begin_layout Plain Layout

float = integer, ".", digit, {digit};
\end_layout

\begin_layout Plain Layout

integer = "0" | (digit excluding zero, {digit});
\end_layout

\begin_layout Plain Layout

digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
 ;
\end_layout

\begin_layout Plain Layout

digit = "0" | digit excluding zero ;
\end_layout

\begin_layout Plain Layout

upper case = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" |
 "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" |
 "W" | "X" | "Y" | "Z" ;
\end_layout

\begin_layout Plain Layout

lower case = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
 "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" |
 "w" | "x" | "y" | "z" ;
\end_layout

\begin_layout Plain Layout

id = lower case, {(upper case | lower case)}
\end_layout

\begin_layout Plain Layout

type = upper case, {(upper case | lower case)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For help understanding this, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Grammars"

\end_inset

.
\end_layout

\begin_layout Subsection
Code
\end_layout

\begin_layout Standard
This is where the grammar is encoded into the program:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def progParser: Parser[List[Definition]] = (paddedDefParser.+) <~ eofParser
\end_layout

\begin_layout Plain Layout

def paddedDefParser:Parser[Definition] = { newlineParser.* ~> defParser <~
 newlineParser.* }
\end_layout

\begin_layout Plain Layout

/*more here*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The relevant values are extracted from the result by using the 
\begin_inset Quotes eld
\end_inset

._x
\begin_inset Quotes erd
\end_inset

 methods, where x is a number.
 This is because the result of several consecutive parsers are combined
 into sets.
 
\begin_inset Quotes eld
\end_inset

._1
\begin_inset Quotes erd
\end_inset

 is then the first value of the set, etc.
 The structure of these sets are sometimes not immediately obvious.
 For the operators refer back to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

.
\end_layout

\begin_layout Standard
There are also a number of somewhat less exciting helper parsers, of which
 an example is provided:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def equalParser:Parser[Token] = accept(EqualT())
\end_layout

\begin_layout Plain Layout

def basicStatementParser:Parser[BasicValueStatement] = accept("expected
 string, integer, boolean or float", {
\end_layout

\begin_layout Plain Layout

case StringT(value) => StringStatement(value);
\end_layout

\begin_layout Plain Layout

case IntegerT(value)=> IntegerStatement(value)
\end_layout

\begin_layout Plain Layout

case TrueT() => TrueStatement()
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This shows how the parser error messages are generated.
\end_layout

\begin_layout Standard
The entirety produces an abstract syntax tree.
 Both the checker and the code generator operates on this AST, and it is
 the centerpiece of the implementation.
 Without understanding the AST, the rest of the implementation will appear
 cryptic at best:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Expression() extends Positional
\end_layout

\begin_layout Plain Layout

trait Callarg extends Positional
\end_layout

\begin_layout Plain Layout

trait Statement extends Expression
\end_layout

\begin_layout Plain Layout

trait BasicValueStatement extends Statement with Callarg with aCallarg with
 aStatement
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class Definition(val leftside:DefLhs, val rightside:DefRhs) extends
 Expression
\end_layout

\begin_layout Plain Layout

case class DefLhs(val description:DefDescriptionT, val id:IdT, val args:Option[A
rguments], val returntype:TypeT)
\end_layout

\begin_layout Plain Layout

case class Arguments(val args:List[Argument])
\end_layout

\begin_layout Plain Layout

case class Argument(val id:IdT, val typestr:TypeT)
\end_layout

\begin_layout Plain Layout

case class DefRhs(val expressions:List[Expression] )
\end_layout

\begin_layout Plain Layout

case class Empty();
\end_layout

\begin_layout Plain Layout

case class DefDescription(val value:Token)
\end_layout

\begin_layout Plain Layout

case class NamedCallarg(id:IdT, argument:Callarg)
\end_layout

\begin_layout Plain Layout

case class NamedCallargs(val value:List[NamedCallarg])
\end_layout

\begin_layout Plain Layout

case class NoArgs() extends Callarg with aCallarg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class StringStatement(val value:String) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IntegerStatement(val value:Int) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class DoubleStatement(val value:Double) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class TrueStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class FalseStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IdentifierStatement(val value:String) extends Statement with
 Callarg with aCallarg with aStatement
\end_layout

\begin_layout Plain Layout

case class FunctionCallStatement(val functionidentifier:String, val args:Either[
Callarg,NamedCallargs]) extends Statement with Callarg
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
parse(in:List[Token]):Either[NoSuccess, List[Definition]] 
\emph default
takes a list of tokens and returns either an error message or an AST
\end_layout

\begin_layout Itemize

\emph on
progParser: Parser[List[Definition]]
\emph default
 is the first of the parsers, from which the parser combinator library will
 generate the final parser
\end_layout

\begin_layout Itemize
x
\emph on
Parser:Parser[X] 
\emph default
parses that particular kind of AST node, for example 
\emph on
defParser:Parser[Definition]
\emph default
.
 Can often be a bit indirect.
 For example, 
\emph on
paddedDefParser:Parser[Definition] 
\emph default
parses a definition with newlines around it, but uses 
\emph on
defParser:Parser[Definition]
\emph default
 to parse the definition part of that.
\end_layout

\begin_layout Paragraph
Classes
\end_layout

\begin_layout Itemize

\emph on
Class TokenReader
\emph default
 is a wrapping around the list of tokens.
 It is required by the parser combinator library and implements the Reader
 interface.
 It has the following functions:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
atEnd
\emph default
 which returns true if the list of tokens is empty
\end_layout

\begin_layout Itemize

\emph on
first
\emph default
, which returns the current first element in the list
\end_layout

\begin_layout Itemize

\emph on
pos
\emph default
, which returns the source text position of the first element in the list
\end_layout

\begin_layout Itemize

\emph on
rest
\emph default
, which returns a new TokenReader wrapping all elements except the first
 in the list
\end_layout

\end_deeper
\begin_layout Itemize
The parser uses AST and token classes.
 These are in the Ast.scala file.
\end_layout

\begin_layout Section
Checker
\end_layout

\begin_layout Standard
The checker, contrary to its in-source name (FumurtTypeChecker) checks more
 than types.
 It does not modify, annotate or otherwise change the abstract syntax tree.
 It simply returns errors found or returns nothing.
 When the implementation of the checker began it was envisaged that the
 basic functions would be treated equally with user defined functions, but
 due to the lack of generics and other abstraction mechanisms, most of the
 basic functions still needed special treatment, with 
\begin_inset Quotes eld
\end_inset

actionPrint
\begin_inset Quotes erd
\end_inset

 being the notable exception.
\end_layout

\begin_layout Standard
This graphic illustrates how the functions in the checker call each other:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename checker.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
check 
\emph default
is the interface to the rest of the program.
 Takes in an AST and returns a list of errors, if there are any.
\end_layout

\begin_layout Itemize

\emph on
checktop 
\emph default
checks the top level of the program.
 The top is special because it contains threads and the program statement,
 though only the program statement need special treatment.
\end_layout

\begin_layout Itemize

\emph on
checkprogram 
\emph default
checks the program statement.
 Uses 
\emph on
checkuseofthread
\emph default
 and checks whether there are any calls to non-threads or definition of
 non-synchronized variables.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
checkuseofthread 
\emph default
checks that the thread given is actually called in the program statement.
 Declaring a thread and failing to call it is an error.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
checkexpressions 
\emph default
checks a list of expressions, such as might be found in the right-hand side
 of a definition.
 Uses 
\emph on
indexleft
\emph default
 to get new in-scope definitions and passes them to 
\emph on
checkexpression
\end_layout

\begin_layout Itemize

\emph on
checkexpression 
\emph default
checks an individual expression.
 Determines if the expression is a statement or a definition, and subsequently
 uses 
\emph on
checkstatement
\emph default
 and 
\emph on
checkdefinition
\end_layout

\begin_layout Itemize

\emph on
checkstatement 
\emph default
checks a statement.
 If it's an identifierStatement, checks that its return value is as expected.
 Uses 
\emph on
checkbasicvaluestatement 
\emph default
for the same for basic values.
 If it's a function call, then it either uses special case functions, such
 as 
\emph on
checkifcall
\emph default
 or finds the function in scope and uses a general approach using checknamedcall
args and/or checkcallarg
\end_layout

\begin_layout Itemize

\emph on
checkifcall
\emph default
 checks calls to if.
 Makes sure the return type of then and else is the same and that condition
 is a boolean.
 Also checks naming.
\end_layout

\begin_layout Itemize

\emph on
checkmutatecall
\emph default
 checks that the variable is a synchronized variable and otherwise has the
 same type as the new value
\end_layout

\begin_layout Itemize

\emph on
checkbasicmathcall 
\emph default
checks the four basic math operators, with special attention to the return
 type when double and int are mixed
\end_layout

\begin_layout Itemize

\emph on
checktostringcall 
\emph default
checks that there is only one argument and that the expected type is String
\end_layout

\begin_layout Itemize

\emph on
checknamedcallargs 
\emph default
checks named call arguments.
 Checks that the correct names are used, that the correct number of arguments
 are given and uses 
\emph on
checkCallarg
\emph default
 to check each argument individually.
\end_layout

\begin_layout Itemize

\emph on
checkCallarg
\emph default
 checks a call argument.
 Makes sure the type is correct.
 Uses checkbasicvaluestatement and checkstatement.
\end_layout

\begin_layout Itemize

\emph on
checkbasicvaluestatement
\emph default
 checks that the type of the basic value is correct.
\end_layout

\begin_layout Itemize

\emph on
checkdefinition
\emph default
 checks a definition.
 makes sure the return type is the one specified, that an action is not
 defined or used from inside a function etc.
\end_layout

\begin_layout Itemize

\emph on
indexlefts(in:List[Expression]):List[DefLhs]
\emph default
 takes a list of expressions and returns a list of all the left sides of
 definitions in that list.
\end_layout

\begin_layout Itemize

\emph on
findinscope 
\emph default
finds a left side of the definition in the current scope with the same name
 as that which is searched for.
\end_layout

\begin_layout Section
Code generator
\end_layout

\begin_layout Standard
The code generator can best be explained step by step:
\end_layout

\begin_layout Enumerate
First the C++ include statements are determined.
 These are currently handwritten.
\end_layout

\begin_layout Enumerate
We scan the program declaration and find the threads that will be started
 in the main thread.
 The statements for those are found in the program declaration.
\end_layout

\begin_layout Enumerate
The main function is determined from the list of thread statements and their
 arguments
\end_layout

\begin_layout Enumerate
The print list declarations are determined from the list of thread statements.
\end_layout

\begin_layout Enumerate
The NUMTHREADS macro is determined from the length of the list of threads.
\end_layout

\begin_layout Enumerate
The abstract syntax tree and a list of the threads are passed to the annotator,
 which returns an annotated tree.
\end_layout

\begin_deeper
\begin_layout Enumerate
The definitions are annotated with their C++ names, and actions called by
 several threads are demultiplexed into one per calling thread.
 Inclusion arguments are removed from the signatures.
 Thread arguments are annotated with their C++ names.
\end_layout

\begin_layout Enumerate
The calls to functions and actions are annotated with the correct C++ name,
 and inclusion call arguments are removed.
\end_layout

\end_deeper
\begin_layout Enumerate
The C++ equivalent of the threads, actions and functions are constructed
 along from the annotated tree, along with their forward declarations.
\end_layout

\begin_layout Enumerate
The global synchronization variables for use in the runtime (for example
 rendezvousCounter) are generated.
 This is currently handwritten.
\end_layout

\begin_layout Enumerate
The synchronized variables are found in the program declaration and the
 C++ equivalents are later determined.
 These are later put in the global scope of the C++ program.
\end_layout

\begin_layout Enumerate
The synchronizer function (waitForRendezvous) is constructed from the synchroniz
ed variables and the thread list.
\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
generate
\emph default
 generates the final C++ code from the Fumurt AST
\end_layout

\begin_layout Itemize

\emph on
getAnnotatedTree 
\emph default
Returns an annotated version of the supplied AST.
 This version has the final C++ names for functions and their arguments
 and function calls
\end_layout

\begin_layout Itemize

\emph on
getCallsAnnotatedTreeInternal 
\emph default
returns an annotated version of the AST with final C++ names for function
 calls.
 Requires that function names have been annotated first
\end_layout

\begin_layout Itemize

\emph on
annotateFunctionCall 
\emph default
annotates a single function call
\end_layout

\begin_deeper
\begin_layout Itemize
annotateCallargs annotates that function calls call arguments.
 Since call arguments can be function calls, this is often recursive.
\end_layout

\begin_layout Itemize

\emph on
removeInclusions 
\emph default
removes inclusion arguments from functions, since these have no purpose
 in C++
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
indexlefts 
\emph default
indexes DefLhs's like in the checker, but with the annotated types.
\end_layout

\begin_layout Itemize

\emph on
findinscope 
\emph default
same as the version in the checker, but with annotated types.
\end_layout

\begin_layout Itemize

\emph on
getAnnotatedTreeInternal 
\emph default
returns an AST with with final C++ names for functions
\end_layout

\begin_layout Itemize

\emph on
getFunctionDeclarations 
\emph default
gets the functions, in C++, from the annotated AST
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
actfunrecursivetranslate 
\emph default
gets function body and signature of a function corresponding to the arguments
 as well as all functions defined in the body of the definition.
\end_layout

\begin_layout Itemize

\emph on
changeNamesToCppOnes
\emph default
 changes all identifiers which are arguments to a thread to their C++ names
 throughout the thread.
 
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
getFunctionSignature 
\emph default
constructs a C++ function signature from the arguments
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
argtranslator
\emph default
 translates an argument as used in defining a function
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
typetranslator 
\emph default
translates Fumurt types to their C++ equivalents.
 Currently there are no user-defined types, so only basic types need to
 be translated.
\end_layout

\begin_layout Itemize

\emph on
callargTranslator 
\emph default
translates a call argument to the C++ equivalent
\end_layout

\begin_layout Itemize

\emph on
functioncalltranslator 
\emph default
translates function calls to C++ syntax
\end_layout

\begin_layout Itemize

\emph on
basicmathcalltranslator 
\emph default
translates calls to plus, minus, divide and multiply into +,-,/, and *
\end_layout

\begin_layout Itemize

\emph on
gettopthreadstatements 
\emph default
gets the C++ statements spawning the threads.
 
\end_layout

\begin_layout Itemize

\emph on
getprintlistdeclarations 
\emph default
gets the printList declarations.
 These are lists in which strings to be printed are kept.
 One for each thread
\end_layout

\begin_layout Itemize

\emph on
getmain 
\emph default
gets the main function.
 The main function only spawns the threads and then goes to sleep
\end_layout

\begin_layout Itemize

\emph on
getsynchronizerfunction 
\emph default
gets the mostly static and hand-written function that performs all actions
 during the communication phase
\end_layout

\begin_layout Itemize

\emph on
getGlobalSynchVariableDeclarations
\emph default
 gets the C++ declarations of the synchronized variables
\end_layout

\begin_layout Itemize

\emph on
getsynchronizedvariables
\emph default
 gets the definitions of the synchronized variables, so that they can later
 be used in 
\emph on
getGlobalSynchVariableDeclarations
\end_layout

\begin_layout Paragraph
Classes
\end_layout

\begin_layout Standard
The generator uses classes needed to annotate the AST, for example 
\emph on
class aDefinition(val leftside:aDefLhs, val rightside:aDefRhs).
 
\emph default
Existing AST classes are used unless extra information needs to be held
 or it is a parent of such a class.
 The most dramatic example is 
\emph on
class aDefLhs(val description:DefDescriptionT, val id:IdT, val cppid:IdT,
 val callingthread:String, val args:Option[Arguments], val returntype:TypeT)
\emph default
.
 Here, we see the new C++ name, as well as which thread is meant to call
 the function.
 These are in the Ast.scala file.
\end_layout

\begin_layout Section
Not Implemented
\begin_inset CommandInset label
LatexCommand label
name "sec:Not-Implemented"

\end_inset


\end_layout

\begin_layout Standard
Considering the nature of languages, the amount left undone could very well
 be infinite.
 The following list are for things that make the current implementation
 feel incomplete.
\end_layout

\begin_layout Itemize
Loops
\end_layout

\begin_layout Itemize
User-defined types
\end_layout

\begin_layout Itemize
Boolean functions
\end_layout

\begin_layout Itemize
Comparison functions (beside equal)
\end_layout

\begin_layout Itemize
Exit function.
 This is not particularly important, as the systems Fumurt is made for are
 not expected to ever exit
\end_layout

\begin_layout Itemize
A check that only the thread with write rights to a synchronized variable
 is allowed to write to that variable
\end_layout

\begin_layout Itemize
Some checks for the 
\emph on
equal
\emph default
 function
\end_layout

\begin_layout Itemize
Any other IO than print to console
\end_layout

\begin_layout Chapter
Testing
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Hello World
\end_layout

\begin_layout Standard
A simple repeating Hello World is written like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program helloworld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  threadPrintHelloWorld()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintHelloWorld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("Hello World
\backslash
n")
\end_layout

\begin_layout Plain Layout

  threadPrintHelloWorld()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which prints Hello World forever:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

/*and so on*/
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multithreaded Hello World
\end_layout

\begin_layout Standard
A dualthreaded hello World is written like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program helloworld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  threadPrintHello()
\end_layout

\begin_layout Plain Layout

  threadPrintWorld()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintWorld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("World
\backslash
n")
\end_layout

\begin_layout Plain Layout

  threadPrintWorld()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintHello:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("Hello ")
\end_layout

\begin_layout Plain Layout

  threadPrintHello()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which also prints Hello World forever:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

Hello World
\end_layout

\begin_layout Plain Layout

/*and so on*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note there is absolutely no performance benefits to dualthreading this,
 as the IO is sequential and this program does nothing but IO.
\end_layout

\begin_layout Section
Synchronized Integer
\end_layout

\begin_layout Standard
Synchronized variables are the same in all threads, and mutations are published
 in the communicative phase.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program helloworld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  synchronized variable synchronizedCounter:Integer = {synchronized(variable=0,
 writer=threadC)}
\end_layout

\begin_layout Plain Layout

  threadA(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

  threadB(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

  threadC(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadA(synchronizedCounter:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedCounter))
\end_layout

\begin_layout Plain Layout

  actionPrint(" == ")
\end_layout

\begin_layout Plain Layout

  threadA(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadB(synchronizedCounter:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedCounter))
\end_layout

\begin_layout Plain Layout

  actionPrint("
\backslash
n")
\end_layout

\begin_layout Plain Layout

  threadB(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadC(synchronizedCounter:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionMutate(newValue=plus(left=synchronizedCounter, right=1), variable=synchr
onizedCounter)
\end_layout

\begin_layout Plain Layout

  threadC(synchronizedCounter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And we can see that the number is consistent across threads: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0 == 0
\end_layout

\begin_layout Plain Layout

1 == 1
\end_layout

\begin_layout Plain Layout

2 == 2
\end_layout

\begin_layout Plain Layout

3 == 3
\end_layout

\begin_layout Plain Layout

4 == 4
\end_layout

\begin_layout Plain Layout

5 == 5
\end_layout

\begin_layout Plain Layout

6 == 6
\end_layout

\begin_layout Plain Layout

7 == 7
\end_layout

\begin_layout Plain Layout

8 == 8
\end_layout

\begin_layout Plain Layout

9 == 9
\end_layout

\begin_layout Plain Layout

/*and so on*/
\end_layout

\end_inset


\end_layout

\begin_layout Section
Functions, Actions, Recursion and the Limitations of Integers
\end_layout

\begin_layout Standard
An example with a single thread, a square and a factorial function and an
 action is presented below.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program helloworld:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  threadA(d=1.0, i=1, actionPrintSquare=actionPrintSquare)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadA(d:Double, i:Integer, actionPrintSquare:Inclusion):Nothing
 =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  function factorial(i:Integer):Integer =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    if(condition=equal(left=1, right=i), then=1, else=multiply(left=i, right=fac
torial(minus(left=i, right=1))))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  actionPrint("The factorial of ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(i))
\end_layout

\begin_layout Plain Layout

  actionPrint(" is ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(factorial(i)))
\end_layout

\begin_layout Plain Layout

  actionPrint("    ")
\end_layout

\begin_layout Plain Layout

  actionPrintSquare(d)
\end_layout

\begin_layout Plain Layout

  threadA(d = plus(left=d, right=0.5), i = plus(left=i, right=1), actionPrintSqua
re=actionPrintSquare)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

action actionPrintSquare(d:Double):Nothing = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  function square(x:Double):Double = {multiply(left=x, right=x)}
\end_layout

\begin_layout Plain Layout

  actionPrint("The square of ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(d))
\end_layout

\begin_layout Plain Layout

  actionPrint(" is ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(square(d)))
\end_layout

\begin_layout Plain Layout

  actionPrint("
\backslash
n")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When run, this example gives the following output:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

The factorial of 1 is 1    The square of 1.000000 is 1.000000
\end_layout

\begin_layout Plain Layout

The factorial of 2 is 2    The square of 1.500000 is 2.250000
\end_layout

\begin_layout Plain Layout

The factorial of 3 is 6    The square of 2.000000 is 4.000000
\end_layout

\begin_layout Plain Layout

The factorial of 4 is 24    The square of 2.500000 is 6.250000
\end_layout

\begin_layout Plain Layout

The factorial of 5 is 120    The square of 3.000000 is 9.000000
\end_layout

\begin_layout Plain Layout

The factorial of 6 is 720    The square of 3.500000 is 12.250000
\end_layout

\begin_layout Plain Layout

The factorial of 7 is 5040    The square of 4.000000 is 16.000000
\end_layout

\begin_layout Plain Layout

The factorial of 8 is 40320    The square of 4.500000 is 20.250000
\end_layout

\begin_layout Plain Layout

The factorial of 9 is 362880    The square of 5.000000 is 25.000000
\end_layout

\begin_layout Plain Layout

The factorial of 10 is 3628800    The square of 5.500000 is 30.250000
\end_layout

\begin_layout Plain Layout

The factorial of 11 is 39916800    The square of 6.000000 is 36.000000
\end_layout

\begin_layout Plain Layout

The factorial of 12 is 479001600    The square of 6.500000 is 42.250000
\end_layout

\begin_layout Plain Layout

The factorial of 13 is 1932053504    The square of 7.000000 is 49.000000
\end_layout

\begin_layout Plain Layout

The factorial of 14 is 1278945280    The square of 7.500000 is 56.250000
\end_layout

\begin_layout Plain Layout

The factorial of 15 is 2004310016    The square of 8.000000 is 64.000000
\end_layout

\begin_layout Plain Layout

The factorial of 16 is 2004189184    The square of 8.500000 is 72.250000
\end_layout

\begin_layout Plain Layout

The factorial of 17 is -288522240    The square of 9.000000 is 81.000000
\end_layout

\begin_layout Plain Layout

The factorial of 18 is -898433024    The square of 9.500000 is 90.250000
\end_layout

\begin_layout Plain Layout

The factorial of 19 is 109641728    The square of 10.000000 is 100.000000
\end_layout

\begin_layout Plain Layout

The factorial of 20 is -2102132736    The square of 10.500000 is 110.250000
\end_layout

\begin_layout Plain Layout

The factorial of 21 is -1195114496    The square of 11.000000 is 121.000000
\end_layout

\begin_layout Plain Layout

The factorial of 22 is -522715136    The square of 11.500000 is 132.250000
\end_layout

\begin_layout Plain Layout

The factorial of 23 is 862453760    The square of 12.000000 is 144.000000
\end_layout

\begin_layout Plain Layout

The factorial of 24 is -775946240    The square of 12.500000 is 156.250000
\end_layout

\begin_layout Plain Layout

The factorial of 25 is 2076180480    The square of 13.000000 is 169.000000
\end_layout

\begin_layout Plain Layout

The factorial of 26 is -1853882368    The square of 13.500000 is 182.250000
\end_layout

\begin_layout Plain Layout

The factorial of 27 is 1484783616    The square of 14.000000 is 196.000000
\end_layout

\begin_layout Plain Layout

The factorial of 28 is -1375731712    The square of 14.500000 is 210.250000
\end_layout

\begin_layout Plain Layout

The factorial of 29 is -1241513984    The square of 15.000000 is 225.000000
\end_layout

\begin_layout Plain Layout

The factorial of 30 is 1409286144    The square of 15.500000 is 240.250000
\end_layout

\begin_layout Plain Layout

The factorial of 31 is 738197504    The square of 16.000000 is 256.000000
\end_layout

\begin_layout Plain Layout

The factorial of 32 is -2147483648    The square of 16.500000 is 272.250000
\end_layout

\begin_layout Plain Layout

The factorial of 33 is -2147483648    The square of 17.000000 is 289.000000
\end_layout

\begin_layout Plain Layout

The factorial of 34 is 0    The square of 17.500000 is 306.250000
\end_layout

\begin_layout Plain Layout

The factorial of 35 is 0    The square of 18.000000 is 324.000000
\end_layout

\begin_layout Plain Layout

/*and so on*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we see a problem with relying on integers of limited size.
 32-bit integer is clearly inadequate for the factorial calculation.
 As for the eventual answer to the factorial calculation being zero, this
 seems to be a result of the C++ compiler's optimizations.
 No optimization gives the stack overflow we expect; running the binary
 results in a segmentation fault when compiled with GCC with -O0 or -O1
 or Clang with -O0.
 Though there are problems with integer wrap-around and stack overflow,
 a recursive factorial function is a classic way to demonstrate the syntax
 of a language.
\end_layout

\begin_layout Section
Full Program Test With C++ Intermediate
\begin_inset CommandInset label
LatexCommand label
name "sec:Full-program-test"

\end_inset


\end_layout

\begin_layout Standard
The following Fumurt code:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program p:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  synchronized variable synchronizedNumber:Integer = {synchronized(variable=0,
 writer=threadPrintHello)}
\end_layout

\begin_layout Plain Layout

  threadPrintHello(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  threadPrintBaz(actionPrintFoo=actionPrintFoo, counter=0.0, integerIdentity=inte
gerIdentity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintWorld(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("world ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedNumber))
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

thread threadPrintHello(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedNumber))
\end_layout

\begin_layout Plain Layout

  actionPrint(" Hello ")
\end_layout

\begin_layout Plain Layout

  actionMutate(variable=synchronizedNumber, newValue=plus(left=synchronizedNumbe
r, right=1))
\end_layout

\begin_layout Plain Layout

  threadPrintHello(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintBaz(actionPrintFoo:Inclusion, integerIdentity:Inclusion,
 counter:Double):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintBaz(counter:Double):Nothing =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  BAZ ")
\end_layout

\begin_layout Plain Layout

    actionPrint(toString(counter))
\end_layout

\begin_layout Plain Layout

    actionPrint("   ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  actionPrintBaz(counter)
\end_layout

\begin_layout Plain Layout

  actionPrintFoo(integerIdentity)
\end_layout

\begin_layout Plain Layout

  threadPrintBaz(counter=minus(right=1.0, left=counter), actionPrintFoo=actionPri
ntFoo, integerIdentity=integerIdentity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

action actionPrintFoo(integerIdentity:Inclusion):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintFooo:Nothing =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  FOOO  ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  actionPrint("  FOO   ")
\end_layout

\begin_layout Plain Layout

  actionPrintFooo()
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(integerIdentity(5)))
\end_layout

\begin_layout Plain Layout

  actionPrint("  ")
\end_layout

\begin_layout Plain Layout

  actionPrint(if(condition=true, then=toString(6), else=toString(3)))
\end_layout

\begin_layout Plain Layout

  actionPrint("
\backslash
n")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {x}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The program gets compiled to the following C++11 code:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=c++}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <thread>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

#include <atomic>
\end_layout

\begin_layout Plain Layout

#include <condition_variable>
\end_layout

\begin_layout Plain Layout

#include <list>
\end_layout

\begin_layout Plain Layout

#include <chrono>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define NUMTOPTHREADS 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintWorld();
\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintHello();
\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintBaz();
\end_layout

\begin_layout Plain Layout

void actionPrintBaz$threadPrintBaz(double counter);
\end_layout

\begin_layout Plain Layout

int integerIdentity$(int x);
\end_layout

\begin_layout Plain Layout

void actionPrintFoo$threadPrintBaz();
\end_layout

\begin_layout Plain Layout

void actionPrintFooo$threadPrintBazactionPrintFoo();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int synchronizedNumber = 0;
\end_layout

\begin_layout Plain Layout

static int writeSynchronizedNumber = 0;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintHello;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintWorld;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintBaz;
\end_layout

\begin_layout Plain Layout

static std::atomic<int> rendezvousCounter;
\end_layout

\begin_layout Plain Layout

static std::mutex rendezvousSyncMutex;
\end_layout

\begin_layout Plain Layout

static std::condition_variable cv;
\end_layout

\begin_layout Plain Layout

static double threadPrintBaz$counter;
\end_layout

\begin_layout Plain Layout

static void waitForRendezvous(std::string name)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  std::unique_lock<std::mutex> lk(rendezvousSyncMutex);
\end_layout

\begin_layout Plain Layout

  ++rendezvousCounter;
\end_layout

\begin_layout Plain Layout

  if(rendezvousCounter.load() < NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cv.wait(lk);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if (rendezvousCounter.load() == NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    while(!printthreadPrintHello.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintHello.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintHello.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

while(!printthreadPrintWorld.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintWorld.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintWorld.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

while(!printthreadPrintBaz.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintBaz.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintBaz.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

synchronizedNumber = writeSynchronizedNumber;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

      cv.notify_all();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    std::cout << "error in wait for " << name << ".
 Rendezvouscounter out of bounds.
 RedezvousCounter = " << rendezvousCounter.load() << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    exit(0);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintWorld()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintWorld.push_back("world ");
\end_layout

\begin_layout Plain Layout

  printthreadPrintWorld.push_back(std::to_string(synchronizedNumber));
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintWorld");
\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintHello()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintHello.push_back(std::to_string(synchronizedNumber));
\end_layout

\begin_layout Plain Layout

  printthreadPrintHello.push_back(" Hello ");
\end_layout

\begin_layout Plain Layout

  writeSynchronizedNumber = (synchronizedNumber + 1);
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintHello");
\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintBaz()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrintBaz$threadPrintBaz(threadPrintBaz$counter);
\end_layout

\begin_layout Plain Layout

  actionPrintFoo$threadPrintBaz();
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintBaz");
\end_layout

\begin_layout Plain Layout

threadPrintBaz$counter = (threadPrintBaz$counter - 1.0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintBaz$threadPrintBaz(double counter)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("  BAZ ");
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back(std::to_string(counter));
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("   ");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int integerIdentity$(int x)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  return x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintFoo$threadPrintBaz()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("  FOO   ");
\end_layout

\begin_layout Plain Layout

  actionPrintFooo$threadPrintBazactionPrintFoo();
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back(std::to_string(integerIdentity$(5)));
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("  ");
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back(std::to_string(6));
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("
\backslash
n");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintFooo$threadPrintBazactionPrintFoo()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintBaz.push_back("  FOOO  ");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

threadPrintBaz$counter = 0.0;
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintHello (threadPrintHello);
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintWorld (threadPrintWorld);
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintBaz (threadPrintBaz);
\end_layout

\begin_layout Plain Layout

while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

std::this_thread::sleep_for(std::chrono::seconds(1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When run in a terminal, this results in the following output:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0 Hello world 0  BAZ 0.000000     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

1 Hello world 1  BAZ -1.000000     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

2 Hello world 2  BAZ -2.000000     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

3 Hello world 3  BAZ -3.000000     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

4 Hello world 4  BAZ -4.000000     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

/*and so on...*/
\end_layout

\end_inset


\end_layout

\begin_layout Section
Error messages
\end_layout

\begin_layout Standard
Error messages are useful to detect errors in the program at compile time.
 Changing the source in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Full-program-test"

\end_inset

 to the following erroneous program allow us to test them:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=fumurt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program p:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  synchronized variable synchronizedNumber:Integer = {synchronized(variable=0,
 writer=threadPrintHello)}
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=integerIdentity, integerIdentity=integerIdentity
yy)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintWorld(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("world ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedNumber))
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

thread threadPrintHello(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  actionPrint(" Hello ")
\end_layout

\begin_layout Plain Layout

  actionMutate(variable=synchronizedNumber, newValue=plus(left=synchronizedNumbe
r, right=1))
\end_layout

\begin_layout Plain Layout

  threadPrintHello(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintLol(actionPrintFoo:Inclusion, integerIdentity:Inclusion):Nothi
ng =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintLol:Nothing =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  LOL   ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  actionPrintLol()
\end_layout

\begin_layout Plain Layout

  actionPrintFoo(integerIdentity)
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=actionPrintFoo, integerIdentity=integerIdentity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function printFoo(integerIdentity:Inclusion):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintFooo:Nothin =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  FOOO  ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  actionPrint("  FOO   ")
\end_layout

\begin_layout Plain Layout

  actionPrintFooo()
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(integerIdentity(5.0)))
\end_layout

\begin_layout Plain Layout

  actionPrint("  ")
\end_layout

\begin_layout Plain Layout

  actionPrint(if(condition=0, then=6, else=toString(3)))
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(if(condition=false, then=6, else=3)))
\end_layout

\begin_layout Plain Layout

  actionPrint("
\backslash
n")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {multiply(left=x, right=1.0)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This causes the Fumurt checker to produce the following errors:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0.0: thread threadPrintHello is declared but not used
\end_layout

\begin_layout Plain Layout

global position
\end_layout

\begin_layout Plain Layout

^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

5.33: Passed inclusion must be the same as the one referenced inside the
 function
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=integerIdentity, integerIdentity=integerIdentity
yy)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

5.66: integerIdentityyy not found
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=integerIdentity, integerIdentity=integerIdentity
yy)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                                                 ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

17.15: Expected type String.
 Got Integer
\end_layout

\begin_layout Plain Layout

  actionPrint(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

              ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

31.3: actionPrintFoo not found
\end_layout

\begin_layout Plain Layout

  actionPrintFoo(integerIdentity)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

32.33: actionPrintFoo not found
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=actionPrintFoo, integerIdentity=integerIdentity)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

39.5: Expected return type Nothin.
 Got Nothing
\end_layout

\begin_layout Plain Layout

    actionPrint("  FOOO  ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

37.3: actions cannot be defined in  functions
\end_layout

\begin_layout Plain Layout

  action actionPrintFooo:Nothin =
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

42.3: Expected return type Nothing.
 Got Nothin
\end_layout

\begin_layout Plain Layout

  actionPrintFooo()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

43.40: Call argument type should be Integer.
 Call argument type was Double
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(integerIdentity(5.0)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

45.28: Call argument type should be Boolean.
 Call argument type was Integer
\end_layout

\begin_layout Plain Layout

  actionPrint(if(condition=0, then=6, else=toString(3)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                           ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

45.36: Call argument type should be String.
 Call argument type was Integer
\end_layout

\begin_layout Plain Layout

  actionPrint(if(condition=0, then=6, else=toString(3)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                   ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

50.48: This call to multiply returns a Double not an Integer
\end_layout

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {multiply(left=x, right=1.0)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                               ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

13 errors found
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Standard
In order to understand the cost of the synchronization in the execution
 model, a test was performed.
 The C++ code generated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Full-program-test"

\end_inset

 was modified to exit when synchronizedNumber was equal to or bigger than
 20000.
 Let this be the 
\emph on
original.

\emph default
 Then all synchronization mechanisms was removed.
 Let this be the 
\emph on
unsynchronized
\emph default
.
 Then the print statements of both was removed, as if the original Fumurt
 program had had no calls to actionPrint.
 Let these be 
\emph on
originalNoPrint
\emph default
 and 
\emph on
unsynchronizedNoPrint
\emph default
.
 The times taken until completion was then measured using the Unix 
\emph on
time
\emph default
 utility.
 The optimizations used were 
\begin_inset Quotes eld
\end_inset

-O3 -march=native
\begin_inset Quotes erd
\end_inset

 on an Intel i5-2500 CPU.
 The results were very interesting:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time until completion (in seconds)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
original
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.399
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsynchronized
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.797
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
originalNoPrint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.179
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsynchronizedNoPrint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The same results are visualized in the plot below:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename perf.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Two things can be concluded from these measurements:
\end_layout

\begin_layout Enumerate
The execution model incurs considerable cost
\end_layout

\begin_layout Enumerate
The execution model can achieve superior performance compared to an unsynchroniz
ed model when the program is dominated by access to terminal output.
 One may speculate that this is due to resource contention and applies equally
 to all inherently sequential IO
\end_layout

\begin_layout Chapter
Conclusion, Discussion and Further Work
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
During the writing of this thesis, a deterministic multithreaded language
 has been designed and a compiler has been built for it.
 In this report it has been shown that creating a programming language that
 eliminates almost all of the difficulties of multithreaded programming
 is possible, while maintaining some of the architectural and performance
 benefits of multithreading.
 Fumurt also presents some new ideas regarding the ways in which code should
 be structured, possibly making it easier to maintain large software projects.
 Yet Fumurt is not near being a usable language, and many questions remain
 unanswered.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
In hindsight, the code generator could have been better written.
 Adding an additional two steps with the annotator was a fairly late decision,
 and the architecture of the module suffered for it.
 There's also numerous bugs and lacking features, as well as corner cases
 where the appropriate behavior simply has not been determined.
 The various features of the language included with the intent of easing
 the maintenance of large programs are not rooted in empirical studies,
 which is clearly unfortunate.
 In the case where a computational phase runs for a long time, the IO buffers
 may grow to be too large to be stored in memory.
 While this is not an issue for desktop and laptop computers where filling
 up the memory takes so long that the program's unresponsiveness is the
 bigger issue, it's a bigger problem for microcontrollers.
 Fixing this problem means that the sequential IO and inter-thread communication
 abstraction which the programming language provides can in extreme cases
 require that the execution itself becomes sequential.
 It seems intuitively possible that this is simply a necessity when providing
 such an abstraction.
 In situations where performance is more important than predictability,
 mechanisms need to be provided to the programmer so that determinism requiremen
ts can be relaxed.
 Similarly, some kinds of recursion have memory use requirements which are
 hard to optimize away.
 The correct way to handle this is yet to be determined.
\end_layout

\begin_layout Standard
More fundamentally, the literature concerning multithreading seems divided
 over what should be required to be deterministic by the language and what
 should require programmer intervention if a deterministic sequence is required.
 It is unclear whether this thesis has the best approach.
\end_layout

\begin_layout Section
Suggestions for Future Work
\begin_inset CommandInset label
LatexCommand label
name "sec:Suggestions-for-Future"

\end_inset


\end_layout

\begin_layout Standard
It is common for programming languages to need a decade of intensive development
 by several contributors before it is ready for serious usage.
 It is therefore not hard to come up with ways in which Fumurt could be
 improved.
 For ideas, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Not-Implemented"

\end_inset

.
 But not all improvements to Fumurt are of academic interest; much of the
 work is simply implementation of pretty mundane things.
 Improvements to the execution model might be more interesting.
 There are many ideas in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

 about how the model might be refined.
 Investigating solutions to employing deterministic Fumurt or Fumurt-like
 systems while accommodating hardware faults and distributed systems is
 another possibility.
 An Erlang/OTP system might be able to serve as a supervisor for several
 networked systems running deterministic code.
 Lastly, there seems to be little empirical work when it comes to programming
 language design.
 Performing empirical studies among programmers investigating what programming
 language ideas are actually helpful seems like a good idea.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "cites"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
System manual
\begin_inset CommandInset label
LatexCommand label
name "chap:System-manual"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
To avoid confusion when discussing compiling the compiler, the Fumurt compiler
 will be referred to as 
\begin_inset Quotes eld
\end_inset

the program
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To compile this code you need the Simple Build Tool (SBT), available at
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.scala-sbt.org/
\end_layout

\end_inset

.
 SBT will download the dependencies required including the compiler and
 the parser combinator library.
 It will also allow you to run the program.
 Depending on the way you install SBT and on which platform, you may have
 to install a Java runtime environment in order to run SBT
\end_layout

\begin_layout Standard
To compile the code using SBT, a certain directory hierarchy is required.
 The directory in which you run SBT must be the same directory that the
 
\begin_inset Quotes eld
\end_inset

build.sbt
\begin_inset Quotes erd
\end_inset

 file and 
\begin_inset Quotes eld
\end_inset

src
\begin_inset Quotes erd
\end_inset

 directory is in.
 
\begin_inset Quotes eld
\end_inset

build.sbt
\begin_inset Quotes erd
\end_inset

 holds dependency and compilation options for SBT.
 The 
\begin_inset Quotes eld
\end_inset

src
\begin_inset Quotes erd
\end_inset

 directory holds all the source code for the project in a structure.
 Since there's only Scala code in this project, the source files shall be
 in 
\begin_inset Quotes eld
\end_inset

src/main/scala
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Once SBT is installed and the directory structure conforms to SBT rules,
 SBT can be started in the directory by using the 
\begin_inset Quotes eld
\end_inset

sbt
\begin_inset Quotes erd
\end_inset

 command in a terminal in the directory holding 
\begin_inset Quotes eld
\end_inset

build.sbt
\begin_inset Quotes erd
\end_inset

 file and 
\begin_inset Quotes eld
\end_inset

src
\begin_inset Quotes erd
\end_inset

.
 SBT will then download the files needed to compile and run the program.
 This usually takes a long while, depending on your Internet connection.
 Once this is done, SBT will present a command prompt.
 The program can then be compiled and run from this SBT command prompt using
 the 
\begin_inset Quotes eld
\end_inset

run [name of Fumurt file]
\begin_inset Quotes erd
\end_inset

 command.
 The compilation (of the compiler) also usually takes a while.
 Note that the Fumurt source file must be in the same directory that you
 launch SBT in, as the the Fumurt compiler does not handle file paths in
 its input.
\end_layout

\begin_layout Standard
The Fumurt compiler uses GCC, and GCC must therefore be installed.
 If GCC is not installed, the user may compile the generated C++ from the
 generated 
\begin_inset Quotes eld
\end_inset

generated.cpp
\begin_inset Quotes erd
\end_inset

 file.
 The options 
\begin_inset Quotes eld
\end_inset

-pthread
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

-std=c++11
\begin_inset Quotes erd
\end_inset

 are required when using Clang/GCC on Linux, but not using the Microsoft
 Visual C++ compiler on Windows.
\end_layout

\begin_layout Standard
If everything goes well, the output will be a binary executable named 
\begin_inset Quotes eld
\end_inset

generated
\begin_inset Quotes erd
\end_inset

, with 
\begin_inset Quotes eld
\end_inset

-O3
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

march=native
\begin_inset Quotes erd
\end_inset

 options.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ ls
\end_layout

\begin_layout Plain Layout

build.sbt src test.fumurt
\end_layout

\begin_layout Plain Layout

$ sbt
\end_layout

\begin_layout Plain Layout

[info] /*current sbt state*/
\end_layout

\begin_layout Plain Layout

> run test.fumurt
\end_layout

\begin_layout Plain Layout

[info] Running fumurtCompiler.Main test.fumurt
\end_layout

\begin_layout Plain Layout

[success] Total time: 2 s, completed May 29, 2015 5:42:18 PM
\end_layout

\begin_layout Plain Layout

> /*ctrl+c*/
\end_layout

\begin_layout Plain Layout

$ ls
\end_layout

\begin_layout Plain Layout

generated.cpp build.sbt generated src test.fumurt
\end_layout

\begin_layout Plain Layout

$ ./generated
\end_layout

\begin_layout Plain Layout

/*program output here*/
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
User manual
\end_layout

\begin_layout Standard
You need to have Scala installed (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.scala-lang.org/download/
\end_layout

\end_inset

) to run the Fumurt compiler from compiled bytecode.
 The current directory must be the one 
\emph on
above
\emph default
 the 
\begin_inset Quotes eld
\end_inset

.class
\begin_inset Quotes erd
\end_inset

 bytecode files.
 Because the starting point of the program is function 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 in object 
\begin_inset Quotes eld
\end_inset

Main
\begin_inset Quotes erd
\end_inset

 in package 
\begin_inset Quotes eld
\end_inset

fumurtCompiler
\begin_inset Quotes erd
\end_inset

, the folder containing the bytecode files must be 
\begin_inset Quotes eld
\end_inset

fumurtCompiler
\begin_inset Quotes erd
\end_inset

 (i.e.
 the name of the package), and the command to run must be 
\begin_inset Quotes eld
\end_inset

scala fumurtCompiler.Main [fumurt source file here]
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The Fumurt compiler uses GCC, and GCC must therefore be installed.
 If GCC is not installed, the user may compile the generated C++ from the
 generated 
\begin_inset Quotes eld
\end_inset

generated.cpp
\begin_inset Quotes erd
\end_inset

 file.
 The options 
\begin_inset Quotes eld
\end_inset

-pthread
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

-std=c++11
\begin_inset Quotes erd
\end_inset

 are required when using Clang/GCC on Linux, but not using the Microsoft
 Visual C++ compiler on Windows.
\end_layout

\begin_layout Standard
Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language={}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ ls
\end_layout

\begin_layout Plain Layout

fumurtCompiler  test.fumurt
\end_layout

\begin_layout Plain Layout

$ ls fumurtCompiler
\end_layout

\begin_layout Plain Layout

aCallarg.class
\end_layout

\begin_layout Plain Layout

FumurtParser$$anonfun$subsequentArgsParser$1$$anonfun$apply$11.class
\end_layout

\begin_layout Plain Layout

ActionT.class
\end_layout

\begin_layout Plain Layout

FumurtParser$$anonfun$subsequentArgsParser$1.class
\end_layout

\begin_layout Plain Layout

ActionT$.class
\end_layout

\begin_layout Plain Layout

FumurtParser$$anonfun$subsequentArgsParser$2.class
\end_layout

\begin_layout Plain Layout

/*more bytecode files here*/
\end_layout

\begin_layout Plain Layout

$
\end_layout

\begin_layout Plain Layout

$ scala fumurtCompiler.Main test.fumurt
\end_layout

\begin_layout Plain Layout

$ ./generated
\end_layout

\begin_layout Plain Layout

/*program output here*/
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Code listing
\begin_inset CommandInset label
LatexCommand label
name "chap:Code-listing"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=scala}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comments and commented-out diagnostics are left in, as they might prove
 useful to anyone improving on the work.
\end_layout

\begin_layout Section
build.sbt
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

name := "solution"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

organization := "NTNU ITK"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

version := "0.1.0"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scalaVersion := "2.11.6"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scalacOptions ++= Seq("-feature", "-optimise", "-Xlint", "-Xfatal-warnings",
 "-deprecation", "-Ywarn-unused", "-Ywarn-infer-any", "-Ywarn-unused-import",
 "-Ywarn-dead-code", "-Ywarn-inaccessible", "-Ywarn-numeric-widen", "-Ywarn-null
ary-override", "-Ywarn-nullary-unit", "-Ywarn-adapted-args")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

libraryDependencies ++= Seq( "org.scala-lang.modules" %% "scala-parser-combinators
" % "1.0.3")
\end_layout

\end_inset


\end_layout

\begin_layout Section
Main.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.io.Source._
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.input.Positional
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object CompileTypeOption extends Enumeration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  type CompileTypeOption = Value
\end_layout

\begin_layout Plain Layout

  val compiledToGo, compiledToC, compiledToCpp, interpreted = Value 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import CompileTypeOption._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Main
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def main(args: Array[String]) :Unit ={
\end_layout

\begin_layout Plain Layout

    if(args.length <1)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        println("no file found in arguments
\backslash
n")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val parts = args(0).split("""
\backslash
.""")
\end_layout

\begin_layout Plain Layout

      if(parts.length==2)
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        if(parts(1)=="fumurt")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          compile(getOptions(args.drop(1), args(0)))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          println("unknown file ending: " + parts(1) + "
\backslash
n")
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        println("too many arguments
\backslash
n")
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getOptions(args:Array[String],file:String): Options =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println(args.toString)
\end_layout

\begin_layout Plain Layout

    new Options(CompileTypeOption.interpreted, true, file)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def compile(opts:Options):Unit =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("Now compiling!")
\end_layout

\begin_layout Plain Layout

    val sourcestring = fromFile(opts.file).mkString
\end_layout

\begin_layout Plain Layout

    FumurtScanner.scan(sourcestring) match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left(error) => println("Error in scanner: " + error.toString)
\end_layout

\begin_layout Plain Layout

      case Right(tokens) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        //println("successful scan.
 Tokens: "+tokens.toString+"
\backslash
n")
\end_layout

\begin_layout Plain Layout

        FumurtParser.parse(tokens) match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Left(error) => println("Error in parser: " + error.toString)
\end_layout

\begin_layout Plain Layout

          case Right(ast) => 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            //println("Success in parser: " + ast.toString)
\end_layout

\begin_layout Plain Layout

            FumurtTypeChecker.check(ast) match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case Some(errors) => 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                errors.map(x=>println(x))
\end_layout

\begin_layout Plain Layout

                val errornum:String = errors.length match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case 1 => "one"
\end_layout

\begin_layout Plain Layout

                  case 2 => "two"
\end_layout

\begin_layout Plain Layout

                  case 3 => "three"
\end_layout

\begin_layout Plain Layout

                  case 4 => "four"
\end_layout

\begin_layout Plain Layout

                  case 5 => "five"
\end_layout

\begin_layout Plain Layout

                  case 6 => "six"
\end_layout

\begin_layout Plain Layout

                  case 7 => "seven"
\end_layout

\begin_layout Plain Layout

                  case 8 => "eight"
\end_layout

\begin_layout Plain Layout

                  case 9 => "nine"
\end_layout

\begin_layout Plain Layout

                  case x => x.toString
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                val singularplural:String = if(errors.length==1){" error"}else{"
 errors"}
\end_layout

\begin_layout Plain Layout

                println(errornum.capitalize + singularplural + " found")
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              case None => 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                //println("
\backslash
nNo errors in checker")
\end_layout

\begin_layout Plain Layout

                val generatedcode = FumurtCodeGenerator.generate(ast)
\end_layout

\begin_layout Plain Layout

                //println("
\backslash
ncode generated: 
\backslash
n" + generatedcode)
\end_layout

\begin_layout Plain Layout

                import java.nio.file.{Paths, Files}
\end_layout

\begin_layout Plain Layout

                import java.nio.charset.StandardCharsets
\end_layout

\begin_layout Plain Layout

                val outname = "generated"
\end_layout

\begin_layout Plain Layout

                val fileending = ".cpp"
\end_layout

\begin_layout Plain Layout

                Files.write(Paths.get("./"+outname+fileending), generatedcode.getByt
es(StandardCharsets.UTF_8))
\end_layout

\begin_layout Plain Layout

                val options = " -pthread -std=c++11 -O3 -march=native"
\end_layout

\begin_layout Plain Layout

                //println("
\backslash
n
\backslash
n===Starting GCC cpp compilation===")
\end_layout

\begin_layout Plain Layout

                //println("options = " + options)
\end_layout

\begin_layout Plain Layout

                import scala.sys.process._
\end_layout

\begin_layout Plain Layout

                val command = "g++ " + outname + fileending + options +
 " -o " + outname
\end_layout

\begin_layout Plain Layout

                //println(command)
\end_layout

\begin_layout Plain Layout

                if( System.getProperty( "os.name" ).startsWith("Windows") )
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  println("OS identified as Windows.
 Please use the Microsoft Visual C++ compiler (included in Visual Studio)
 to compile the generated 
\backslash
"generated.cpp
\backslash
" file")
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                else
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  (command).!
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Options(val compileTypeOption:CompileTypeOption, val debug:Boolean,
 val file:String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Ast.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.util.parsing.input.Positional
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abstract class Token() extends Positional
\end_layout

\begin_layout Plain Layout

abstract class DefDescriptionT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class BasicValueT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class SyntaxT() extends Token
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class EmptyT() extends Token
\end_layout

\begin_layout Plain Layout

case class TrueT() extends BasicValueT {override def toString = "true"}
\end_layout

\begin_layout Plain Layout

case class FalseT() extends BasicValueT {override def toString = "false"}
\end_layout

\begin_layout Plain Layout

case class ProgramT() extends DefDescriptionT {override def toString = "program"
}
\end_layout

\begin_layout Plain Layout

case class ActionT() extends DefDescriptionT {override def toString = "action"}
\end_layout

\begin_layout Plain Layout

case class ThreadT() extends DefDescriptionT {override def toString = "thread"}
\end_layout

\begin_layout Plain Layout

case class FunctionT() extends DefDescriptionT {override def toString =
 "function"}
\end_layout

\begin_layout Plain Layout

case class ValueT() extends DefDescriptionT {override def toString = "value"}
\end_layout

\begin_layout Plain Layout

case class SynchronizedVariableT() extends DefDescriptionT {override def
 toString = "synchronized variable"}
\end_layout

\begin_layout Plain Layout

case class OpenParenthesisT() extends SyntaxT {override def toString = "
\backslash
"(
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class CloseParenthesisT() extends SyntaxT {override def toString =
 "
\backslash
")
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class OpenCurlyBracketT() extends SyntaxT {override def toString =
 "
\backslash
"{
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class CloseCurlyBracketT() extends SyntaxT {override def toString =
 "
\backslash
"}
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class DoubleT(val value:Double) extends BasicValueT {override def toString
 = "decimal number"}
\end_layout

\begin_layout Plain Layout

case class IntegerT(val value:Int) extends BasicValueT {override def toString
 = "integer"}
\end_layout

\begin_layout Plain Layout

case class EqualT() extends SyntaxT {override def toString = "
\backslash
"=
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class ColonT() extends SyntaxT {override def toString = "
\backslash
":
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class CommaT() extends SyntaxT {override def toString = "
\backslash
",
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class NewlineT() extends SyntaxT {override def toString = "newline"}
\end_layout

\begin_layout Plain Layout

case class IdT(val value:String) extends Token {override def toString =
 "identifier(
\backslash
""+value+"
\backslash
")"}
\end_layout

\begin_layout Plain Layout

case class TypeT(val value:String) extends Token {override def toString
 = "type(
\backslash
""+value+"
\backslash
")"}
\end_layout

\begin_layout Plain Layout

case class StringT(val value:String) extends BasicValueT {override def toString
 = "string"}
\end_layout

\begin_layout Plain Layout

case class SpaceT() extends SyntaxT
\end_layout

\begin_layout Plain Layout

case class DummyT() extends Token
\end_layout

\begin_layout Plain Layout

case class EofT() extends SyntaxT {override def toString = "end of file"}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Expression() extends Positional
\end_layout

\begin_layout Plain Layout

trait Callarg extends Positional
\end_layout

\begin_layout Plain Layout

trait Statement extends Expression
\end_layout

\begin_layout Plain Layout

trait BasicValueStatement extends Statement with Callarg with aCallarg with
 aStatement
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class Definition(val leftside:DefLhs, val rightside:DefRhs) extends
 Expression
\end_layout

\begin_layout Plain Layout

case class DefLhs(val description:DefDescriptionT, val id:IdT, val args:Option[A
rguments], val returntype:TypeT)
\end_layout

\begin_layout Plain Layout

/*case class Arguments(val id:IdT, val typestr:TypeT, val args2:Option[Arguments
2])
\end_layout

\begin_layout Plain Layout

case class Arguments2(val id:IdT, val typestr:TypeT, val args2:Option[Arguments2
])*/
\end_layout

\begin_layout Plain Layout

case class Arguments(val args:List[Argument])
\end_layout

\begin_layout Plain Layout

case class Argument(val id:IdT, val typestr:TypeT)
\end_layout

\begin_layout Plain Layout

case class DefRhs(val expressions:List[Expression] )
\end_layout

\begin_layout Plain Layout

case class Empty();
\end_layout

\begin_layout Plain Layout

case class DefDescription(val value:Token)
\end_layout

\begin_layout Plain Layout

case class NamedCallarg(id:IdT, argument:Callarg) //extends Callarg
\end_layout

\begin_layout Plain Layout

case class NamedCallargs(val value:List[NamedCallarg])
\end_layout

\begin_layout Plain Layout

case class NoArgs() extends Callarg with aCallarg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class StringStatement(val value:String) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IntegerStatement(val value:Int) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class DoubleStatement(val value:Double) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class TrueStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class FalseStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IdentifierStatement(val value:String) extends Statement with
 Callarg with aCallarg with aStatement
\end_layout

\begin_layout Plain Layout

case class FunctionCallStatement(val functionidentifier:String, val args:Either[
Callarg,NamedCallargs]) extends Statement with Callarg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

trait aExpression
\end_layout

\begin_layout Plain Layout

trait aCallarg extends Callarg with aStatement
\end_layout

\begin_layout Plain Layout

trait aStatement extends aExpression
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class aDefinition(val leftside:aDefLhs, val rightside:aDefRhs) extends
 aExpression
\end_layout

\begin_layout Plain Layout

case class aDefLhs(val description:DefDescriptionT, val id:IdT, val cppid:IdT,
 val callingthread:String, val args:Option[aArguments], val returntype:TypeT)
\end_layout

\begin_layout Plain Layout

case class aArguments(val args:List[aArgument])
\end_layout

\begin_layout Plain Layout

case class aArgument(val id:IdT, cppid:IdT, val typestr:TypeT)
\end_layout

\begin_layout Plain Layout

case class aDefRhs(val expressions:List[aExpression] )
\end_layout

\begin_layout Plain Layout

case class aNamedCallarg(id:IdT, argument:aCallarg) //extends Callarg
\end_layout

\begin_layout Plain Layout

case class aNamedCallargs(val value:List[aNamedCallarg])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class aFunctionCallStatement(val functionidentifier:String, val cppfunction
identifier:String, val args:Either[aCallarg,aNamedCallargs], val returntype:Stri
ng) extends aStatement with aCallarg
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Scanner.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.language.implicitConversions
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.combinator.RegexParsers
\end_layout

\begin_layout Plain Layout

import scala.util.matching.Regex
\end_layout

\begin_layout Plain Layout

import scala.language.postfixOps
\end_layout

\begin_layout Plain Layout

//import scala.util.parsing.combinator.lexical._
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.input.Positional
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object FumurtScanner extends RegexParsers /*with Parsers*/
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  override val skipWhitespace = false
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def scan(in:String):Either[NoSuccess, List[Token]] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println(in) 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    parseAll((scanInternal*), in) match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Success(result, _) =>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val tokens = result.filter(x=>x match{case SpaceT() => false; case
 _ => true}) :+ EofT()
\end_layout

\begin_layout Plain Layout

        Right(tokens)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case f:Failure => Left(f)
\end_layout

\begin_layout Plain Layout

      case e:Error => Left(e)
\end_layout

\begin_layout Plain Layout

      //case Failure(message, reader) => Left(new FumurtError(reader.pos,
 "Failure: "+message,"
\backslash
n" + in.lines.toList(reader.pos.line) +"
\backslash
n"))
\end_layout

\begin_layout Plain Layout

      //case Error(message,_) => Left(new FumurtError(Global, "Error: "
 + message, ""))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def spaceParser:Parser[SpaceT] = positioned( new Regex(""" """) ^^ {x
 => /*println("scanned space");*/SpaceT()} )
\end_layout

\begin_layout Plain Layout

  def programStrParser: Parser[ProgramT] = positioned( new Regex("program
 ") ^^ {x => /*println("scanned program "+x.toString);*/ProgramT()} )
\end_layout

\begin_layout Plain Layout

  def functionParser: Parser[FunctionT] = positioned( new Regex("function
 ") ^^ {x => /*println("scanned function "+x.toString);*/FunctionT()} )
\end_layout

\begin_layout Plain Layout

  def threadParser: Parser[ThreadT] = positioned( new Regex("thread ") ^^
 {x => /*println("scanned thread "+x.toString);*/ThreadT()} )
\end_layout

\begin_layout Plain Layout

  def synchronizedVariableParser: Parser[SynchronizedVariableT] = positioned(new
 Regex("synchronized variable ") ^^ {x => /*println("scanned synchronized
 variable "+x.toString);*/ SynchronizedVariableT()})
\end_layout

\begin_layout Plain Layout

  def valueParser: Parser[ValueT] = positioned( new Regex("value ") ^^ {x
 => /*println("scanned unsafe value "+x.toString);*/ValueT()} )
\end_layout

\begin_layout Plain Layout

  def actionParser: Parser[ActionT] = positioned( new Regex("action ") ^^
 {x => /*println("scanned action "+x.toString);*/ActionT()} )
\end_layout

\begin_layout Plain Layout

  def trueParser: Parser[TrueT] = positioned( new Regex("true") ^^ {x =>
 /*println("scanned true "+x.toString);*/TrueT()} )
\end_layout

\begin_layout Plain Layout

  def falseParser: Parser[FalseT] = positioned( new Regex("false") ^^ {x
 => /*println("scanned false "+x.toString);*/FalseT()} )
\end_layout

\begin_layout Plain Layout

  def openParenthesisParser: Parser[OpenParenthesisT] = positioned( new
 Regex("""
\backslash
(""") ^^ {x => /*println("scanned ( "+x.toString);*/OpenParenthesisT()} )
\end_layout

\begin_layout Plain Layout

  def closeParenthesisParser: Parser[CloseParenthesisT] = positioned( new
 Regex("""
\backslash
)""") ^^ {x => /*println("scanned ) "+x.toString);*/CloseParenthesisT()}
 )
\end_layout

\begin_layout Plain Layout

  def openCurlyBracketParser: Parser[OpenCurlyBracketT] = positioned( new
 Regex("""
\backslash
{""") ^^ {x => /*println("scanned { "+x.toString);*/OpenCurlyBracketT()}
 )
\end_layout

\begin_layout Plain Layout

  def closeCurlyBracketParser: Parser[CloseCurlyBracketT] = positioned(
 new Regex("""
\backslash
}""") ^^ {x => /*println("scanned } "+x.toString);*/CloseCurlyBracketT()}
 )
\end_layout

\begin_layout Plain Layout

  def doubleParser: Parser[DoubleT] = positioned( new Regex("""[-+]?[0-9]*
\backslash
.[0-9]+""") ^^ {x => /*println("scanned double "+x.toString);*/DoubleT(x.toDouble)}
 )
\end_layout

\begin_layout Plain Layout

  def intParser: Parser[IntegerT] = positioned( new Regex("""[-+]?(0|[1-9]
\backslash
d*)""") ^^ {x => /*println("scanned integer "+x.toString);*/IntegerT(x.toInt)}
 )
\end_layout

\begin_layout Plain Layout

  def equalParser: Parser[EqualT] = positioned( new Regex("=") ^^ {x =>
 /*println("scanned = "+x.toString);*/EqualT()} )
\end_layout

\begin_layout Plain Layout

  def colonParser: Parser[ColonT] = positioned( new Regex(":") ^^ {x =>
 /*println("scanned : "+x.toString);*/ColonT()} )
\end_layout

\begin_layout Plain Layout

  def commaParser: Parser[CommaT] = positioned( new Regex(",") ^^ {x =>
 /*println("scanned , "+x.toString);*/CommaT()} )
\end_layout

\begin_layout Plain Layout

  //def emptyParser: Parser[EmptyT] = new Regex("") ^^ {x => println("scanned
 empty");EmptyT()}
\end_layout

\begin_layout Plain Layout

  def newlineParser: Parser[NewlineT] = positioned( new Regex("
\backslash
n") ^^ {x => /*println("scanned newline ");*/NewlineT()} )
\end_layout

\begin_layout Plain Layout

  def idParser: Parser[IdT] = positioned( new Regex("[a-z]+[a-zA-Z]*") ^^
 {x => /*println("scanned id "+x.toString);*/IdT(x.toString)} )
\end_layout

\begin_layout Plain Layout

  def stringParser: Parser[StringT] = positioned( new Regex("""("[^"]*")""")
 ^^ {x => /*println("scanned string "+x.toString);*/StringT(x.toString)} )
\end_layout

\begin_layout Plain Layout

  def typeParser: Parser[TypeT] = positioned( new Regex("[A-Z][a-zA-Z]*")
 ^^ {x => /*println("scanned type "+x.toString);*/TypeT(x.toString)} )
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def scanInternal: Parser[Token] = 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    (
\end_layout

\begin_layout Plain Layout

      spaceParser               |
\end_layout

\begin_layout Plain Layout

      programStrParser          |
\end_layout

\begin_layout Plain Layout

      threadParser        |
\end_layout

\begin_layout Plain Layout

      actionParser              |
\end_layout

\begin_layout Plain Layout

      synchronizedVariableParser  |
\end_layout

\begin_layout Plain Layout

      functionParser            |
\end_layout

\begin_layout Plain Layout

      trueParser                |
\end_layout

\begin_layout Plain Layout

      falseParser               |
\end_layout

\begin_layout Plain Layout

      openParenthesisParser     |
\end_layout

\begin_layout Plain Layout

      closeParenthesisParser    |
\end_layout

\begin_layout Plain Layout

      openCurlyBracketParser    |
\end_layout

\begin_layout Plain Layout

      closeCurlyBracketParser   |
\end_layout

\begin_layout Plain Layout

      doubleParser              |
\end_layout

\begin_layout Plain Layout

      intParser                 |
\end_layout

\begin_layout Plain Layout

      equalParser               |
\end_layout

\begin_layout Plain Layout

      colonParser               |
\end_layout

\begin_layout Plain Layout

      commaParser               |
\end_layout

\begin_layout Plain Layout

      //emptyParser               |
\end_layout

\begin_layout Plain Layout

      newlineParser             |
\end_layout

\begin_layout Plain Layout

      stringParser              |
\end_layout

\begin_layout Plain Layout

      idParser                  |
\end_layout

\begin_layout Plain Layout

      typeParser  
\end_layout

\begin_layout Plain Layout

    )            
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Parser.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//import scala.util.parsing._
\end_layout

\begin_layout Plain Layout

import scala.language.postfixOps
\end_layout

\begin_layout Plain Layout

import scala.language.implicitConversions
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.input._
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.combinator._
\end_layout

\begin_layout Plain Layout

//import scala.util.parsing.combinator.PackratParsers.PackratReader
\end_layout

\begin_layout Plain Layout

//import scala.util.parsing.combinator.syntactical._
\end_layout

\begin_layout Plain Layout

import scala.util.parsing.combinator.PackratParsers
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object FumurtParser extends Parsers //with PackratParsers
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  override type Elem = Token
\end_layout

\begin_layout Plain Layout

  //type Tokens = Token
\end_layout

\begin_layout Plain Layout

  //type Token = Elem
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def parse(in:List[Token]):Either[NoSuccess, List[Definition]]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //val ast = parseAll((progParser), in)
\end_layout

\begin_layout Plain Layout

    val res = progParser(new TokenReader(in))
\end_layout

\begin_layout Plain Layout

    res match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case ns:NoSuccess=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

         println(res+"
\backslash
n")
\end_layout

\begin_layout Plain Layout

         //Left(new FumurtError(ns.next.pos, ns.msg, ""))
\end_layout

\begin_layout Plain Layout

         Left(ns)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case _=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val ast = res.get
\end_layout

\begin_layout Plain Layout

        //println("
\backslash
n")
\end_layout

\begin_layout Plain Layout

        //println(ast.toString+"
\backslash
n")
\end_layout

\begin_layout Plain Layout

        Right(ast)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def progParser: Parser[List[Definition]] = (paddedDefParser.+) <~ eofParser
\end_layout

\begin_layout Plain Layout

  def paddedDefParser:Parser[Definition] = {/*println("paddeddefparser");*/
 newlineParser.* ~> defParser <~ newlineParser.* }
\end_layout

\begin_layout Plain Layout

  def defParser: Parser[Definition] = {/*println("defparser");*/  positioned((de
flhsParser <~ equalParser ~! newlineParser.*) ~! defrhsParser ^^ {x=>Definition(x.
_1,x._2)}) }
\end_layout

\begin_layout Plain Layout

  def deflhsParser: Parser[DefLhs] = {/*println("deflhsparser");*/  (defdescript
ionParser ~ idParser ~ argsParser ~! (colonParser ~> typeParser)) ^^ {x=>DefLhs(
x._1._1._1, x._1._1._2, x._1._2, x._2)} }
\end_layout

\begin_layout Plain Layout

  def argsParser: Parser[Option[Arguments]] = {/*println("argsparser");*/
 openParenthesisParser ~> ((idParser <~ colonParser) ~ typeParser ~ subsequentAr
gsParser.*) <~ closeParenthesisParser ^^{x=>Some(Arguments( (Argument(x._1._1,
 x._1._2) +: x._2).sortWith((left,right)=>left.id.value<right.id.value) ))} | emptyParse
r ^^ {x=>None} }
\end_layout

\begin_layout Plain Layout

  def subsequentArgsParser: Parser[Argument] = {/*println("args2parserparser");*
/  commaParser ~> (idParser <~ colonParser) ~ typeParser ^^{x=>Argument(x._1,
 x._2)} }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def defrhsParser: Parser[DefRhs] = {/*println("-defrhsparser");*/ (openCurlyBr
acketParser ~ newlineParser.* ~> expressionParser ~ (newlineParser.+ ~> expression
Parser).*) <~ newlineParser.* ~ closeCurlyBracketParser ^^{x=>DefRhs(x._1 +:
 x._2)} }
\end_layout

\begin_layout Plain Layout

  def expressionParser: Parser[Expression] = {/*println("expressionparser");*/
 positioned(defParser | statementParser) }
\end_layout

\begin_layout Plain Layout

  /*
\end_layout

\begin_layout Plain Layout

  def defrhsParser: Parser[DefRhs] = {println("-defrhsparser"); (openCurlyBracke
tParser ~> expressionParser.+) <~ newlineParser.* ~ closeCurlyBracketParser
 ^^{x=>DefRhs(x)} }
\end_layout

\begin_layout Plain Layout

  def expressionParser: Parser[Expression] = {println("expressionparser");
 newlineParser.+ ~> positioned(defParser | statementParser) }
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

  def statementParser: Parser[Statement] = {/*println("statementparser");*/
 functionCallParser | basicStatementParser  | identifierStatementParser
 }
\end_layout

\begin_layout Plain Layout

  def callargsParser: Parser[Either[Callarg,NamedCallargs]] = {/*println("callar
gsparser");*/ openParenthesisParser ~> (namedcallargsParser | callargParser)
 <~ closeParenthesisParser ^^{x=>x match{case x:Callarg => Left(x); case
 x:NamedCallargs=>Right(x)}} }
\end_layout

\begin_layout Plain Layout

  def callargParser: Parser[Callarg] = {/*println("callargparser");*/ positioned
(functionCallParser | identifierStatementParser | basicStatementParser |
 success(NoArgs())) }
\end_layout

\begin_layout Plain Layout

  def namedcallargsParser: Parser[NamedCallargs] = {/*println("namedcallargspars
er");*/ namedcallargParser ~ subsequentnamedcallargsParser.+ ^^ {x => NamedCallar
gs((x._1 +: x._2).sortWith((left,right)=>left.id.value<right.id.value))} }
\end_layout

\begin_layout Plain Layout

  def subsequentnamedcallargsParser: Parser[NamedCallarg] = {/*println("subseque
ntnamedcallargsParser");*/ (commaParser ~! success(Unit)) ~> namedcallargParser
 }
\end_layout

\begin_layout Plain Layout

  def namedcallargParser:Parser[NamedCallarg] = {/*println("namedcallargparser")
;*/ (idParser <~ equalParser) ~ callargParser ^^ {x=>NamedCallarg(x._1, x._2)}
 }
\end_layout

\begin_layout Plain Layout

  def functionCallParser:Parser[FunctionCallStatement] = {/*println("functioncal
lparser");*/ idParser ~ callargsParser ^^ {x=>FunctionCallStatement(x._1
 match{case IdT(str)=>str}, x._2)} }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /*
\end_layout

\begin_layout Plain Layout

  def argsParser: Parser[Option[Arguments]] = {println("argsparser"); openParent
hesisParser ~> ((idParser <~ colonParser) ~ typeParser ~ args2Parser) <~
 closeParenthesisParser ^^{x=>Some(Arguments(x._1._1, x._1._2, x._2))} | emptyParser
 ^^ {x=>None} }
\end_layout

\begin_layout Plain Layout

  def args2Parser: Parser[Option[Arguments2]] = {println("args2parserparser");
  commaParser ~> (idParser <~ colonParser) ~ typeParser ~ args2Parser ^^{x=>Some
(Arguments2(x._1._1, x._1._2, x._2))} | emptyParser ^^^{None} }
\end_layout

\begin_layout Plain Layout

  */
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def equalParser:Parser[Token] = accept(EqualT())
\end_layout

\begin_layout Plain Layout

  def colonParser:Parser[Elem] = accept(ColonT())
\end_layout

\begin_layout Plain Layout

  def commaParser:Parser[Elem] = accept(CommaT())
\end_layout

\begin_layout Plain Layout

  def newlineParser:Parser[Elem] = accept(NewlineT())
\end_layout

\begin_layout Plain Layout

  def emptyParser:Parser[Empty] = success(Empty())
\end_layout

\begin_layout Plain Layout

  def openParenthesisParser:Parser[Elem] = accept(OpenParenthesisT())
\end_layout

\begin_layout Plain Layout

  def closeParenthesisParser:Parser[Elem] = accept(CloseParenthesisT())
\end_layout

\begin_layout Plain Layout

  def openCurlyBracketParser:Parser[Elem] = accept(OpenCurlyBracketT())
\end_layout

\begin_layout Plain Layout

  def closeCurlyBracketParser:Parser[Elem] = accept(CloseCurlyBracketT())
\end_layout

\begin_layout Plain Layout

  def programStrParser:Parser[Elem] = accept(ProgramT())
\end_layout

\begin_layout Plain Layout

  def actionParser:Parser[Elem] = accept(ActionT())
\end_layout

\begin_layout Plain Layout

  def threadParser:Parser[Elem] = accept(ThreadT())
\end_layout

\begin_layout Plain Layout

  def functionParser:Parser[DefDescription] = accept("function", {case FunctionT
() => DefDescription(FunctionT())})
\end_layout

\begin_layout Plain Layout

  def eofParser:Parser[Elem] = accept(EofT())
\end_layout

\begin_layout Plain Layout

  def idParser:Parser[IdT] = accept("identifier", {case IdT(value) => {/*println
("idparser accepted "+value);*/IdT(value)}})
\end_layout

\begin_layout Plain Layout

  def trueParser:Parser[Elem] = accept(TrueT())
\end_layout

\begin_layout Plain Layout

  def falseParser:Parser[Elem] = accept(FalseT())
\end_layout

\begin_layout Plain Layout

  def identifierStatementParser:Parser[IdentifierStatement] ={/*println("identif
ierstatementparser");*/ accept("identifier", {case IdT(str)=>{/*println("identif
ierstatementparser accepted "+str);*/ IdentifierStatement(str)}}) }
\end_layout

\begin_layout Plain Layout

  def basicStatementParser:Parser[BasicValueStatement] = accept("expected
 string, integer, boolean or float", {case StringT(value) => StringStatement(val
ue); 
\end_layout

\begin_layout Plain Layout

                                                                       
                         case IntegerT(value)=> IntegerStatement(value)
\end_layout

\begin_layout Plain Layout

                                                                       
                         case DoubleT(value) => DoubleStatement(value)
\end_layout

\begin_layout Plain Layout

                                                                       
                         case TrueT() => TrueStatement()
\end_layout

\begin_layout Plain Layout

                                                                       
                         case FalseT() => FalseStatement()}
\end_layout

\begin_layout Plain Layout

                                                                       
                         )
\end_layout

\begin_layout Plain Layout

  def typeParser:Parser[TypeT] = accept("expected type.
 Types are written with a leading capital letter", {case x:TypeT => x})
\end_layout

\begin_layout Plain Layout

  def intParser:Parser[Elem] = accept("integer", {case x:IntegerT => x})
\end_layout

\begin_layout Plain Layout

  def doubleParser:Parser[Elem] = accept("double", {case x:DoubleT => x})
\end_layout

\begin_layout Plain Layout

  def defdescriptionParser: Parser[DefDescriptionT] = {/*println("defdescription
Parser");*/ accept("expected function, action, thread or program", {case
 x:DefDescriptionT => x}) }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  class TokenReader(in:List[Token]) extends Reader[Elem]
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    def atEnd:Boolean = in.isEmpty
\end_layout

\begin_layout Plain Layout

    def first:Elem = in.head
\end_layout

\begin_layout Plain Layout

    def pos:Position = in.head.pos;
\end_layout

\begin_layout Plain Layout

    def rest = new TokenReader(in.tail)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Typechecker.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

import scala.collection.mutable.ListBuffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object FumurtTypeChecker
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def check(in:List[Definition]):Option[List[FumurtError]] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val print = DefLhs(ActionT(), IdT("actionPrint"), Some(Arguments(List(Argume
nt(IdT("toPrint"), TypeT("String"))))), TypeT("Nothing"))
\end_layout

\begin_layout Plain Layout

    val basicfunctions = List(print) 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    //all standard library functions available everywhere (maybe also actions).
 
\end_layout

\begin_layout Plain Layout

    //checkexpression(in, DefLhs(UnsafeActionT(), IdT(""), None, TypeT("Nothing"
)), None, List(List():List[Definition]), basics, List():List[DefLhs], List():Lis
t[FumurtErrors])
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    //println()
\end_layout

\begin_layout Plain Layout

    val errors = checktop(in, basicfunctions)
\end_layout

\begin_layout Plain Layout

    //println()
\end_layout

\begin_layout Plain Layout

    if (errors.isEmpty)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      Some(errors)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checktop(in:List[Definition], basicFunctions:List[DefLhs]): List[FumurtErr
or]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val topdefs = indexlefts(in)
\end_layout

\begin_layout Plain Layout

    val programs = in.filter(x=>(x.leftside.description match {case ProgramT()
 => true; case _=> false}))
\end_layout

\begin_layout Plain Layout

    val implicitargs = topdefs.filter(x=>(x.description match {case ProgramT()
 => false; case _=> true}))
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
nimplicitargs is: "+implicitargs)
\end_layout

\begin_layout Plain Layout

    val programerrors = if(programs.length==1)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      checkprogram(programs(0), implicitargs, basicFunctions)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {List(FumurtError(Global, "There must be exactly one program definition.
 "+programs.length+" program definitions detected"))}
\end_layout

\begin_layout Plain Layout

    val program = programs(0)
\end_layout

\begin_layout Plain Layout

    //val synchronizedvars = program.rightside.expressions.filter(x=> x match
 {case Definition(DefLhs(SynchronizedVariableT(),_,_,_),_)=>true; case _=>false}
):List[Definition]
\end_layout

\begin_layout Plain Layout

    val synchronizedvars = program.rightside.expressions.flatMap(x=> x match
 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case deff:Definition=>if(deff.leftside.description == SynchronizedVariable
T()) {Some(deff.leftside)} else {None}; 
\end_layout

\begin_layout Plain Layout

        case _=>None
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    ):List[DefLhs]
\end_layout

\begin_layout Plain Layout

    val nonProgramDefs = in.filter(x=>(x.leftside.description match {case ProgramT(
) => false; case _=> true}))
\end_layout

\begin_layout Plain Layout

    val othererrors = checkexpressions(nonProgramDefs, None, Some(implicitargs++
synchronizedvars), basicFunctions) 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

     programerrors++othererrors 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkprogram(program:Definition, topleveldefs:List[DefLhs], basicFunctions
:List[DefLhs]): List[FumurtError]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    def checkuseofthread(program:Definition, thread:DefLhs):List[FumurtError]=
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      thread.description match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case ThreadT() => program.rightside.expressions.find(y=>y match{case
 FunctionCallStatement(thread.id.value, _) => true; case _=>false}) 
\end_layout

\begin_layout Plain Layout

          match
\end_layout

\begin_layout Plain Layout

          { 
\end_layout

\begin_layout Plain Layout

            case Some(_)=> List(); 
\end_layout

\begin_layout Plain Layout

            case None=> List(FumurtError(Global, "thread "+thread.id.value+"
 is declared but not used"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        case _=> List()
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val unusedthreaderrors:List[FumurtError] = topleveldefs.foldLeft(List():
 List[FumurtError])((x:List[FumurtError], y:DefLhs)=>
\end_layout

\begin_layout Plain Layout

      x++checkuseofthread(program,y)
\end_layout

\begin_layout Plain Layout

    ):List[FumurtError]
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val lefts = indexlefts(program.rightside.expressions)
\end_layout

\begin_layout Plain Layout

    val unsuitableexpressions = program.rightside.expressions.foldLeft(List():
 List[FumurtError])( (x,y)=>
\end_layout

\begin_layout Plain Layout

      y match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case z:Definition=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          z.leftside.description match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case SynchronizedVariableT() => 
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              if(z.rightside.expressions.length != 1){x++List(FumurtError(z.pos,
 "only single call to synchronized permitted"))}
\end_layout

\begin_layout Plain Layout

              else
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val synchcall = z.rightside.expressions(0)
\end_layout

\begin_layout Plain Layout

                val signatureerror = 
\end_layout

\begin_layout Plain Layout

                synchcall match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case FunctionCallStatement( "synchronized", Right(NamedCallarg
s(List( NamedCallarg(IdT("variable"), variablearg:Callarg), NamedCallarg(IdT("wr
iter"),writerarg: Callarg))))) =>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    x++checkCallarg(z.leftside.returntype, variablearg, IdT("varia
ble"), program.leftside, None, basicFunctions, List()) //TODO: make sure
 that writer is a thread that exists.
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case _=>x++List(FumurtError(synchcall.pos, "must be call
 to synchronized with 
\backslash
"variable
\backslash
" and 
\backslash
"writer
\backslash
" arguments"))
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                x++signatureerror
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            case _=> x++List(FumurtError(z.pos,"Do not define functions,
 actions or unsynchronized values in Program"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case z:FunctionCallStatement=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if(!z.functionidentifier.startsWith("thread")) {x ++ List(FumurtError(z.p
os, "Only threads can be called in Program"))} 
\end_layout

\begin_layout Plain Layout

          else
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            x++checkstatement(z, program.leftside, None, basicFunctions,
 lefts++topleveldefs, TypeT("Nothing"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case z:Expression=>x++List(FumurtError(z.pos, "Only definitions and
 thread start statements allowed in Program"))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    //println(program.rightside.expressions)
\end_layout

\begin_layout Plain Layout

    //println("unsuit "+(unusedthreaderrors ++ unsuitabledefinitions.toList))
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    (unusedthreaderrors ++ unsuitableexpressions.toList):List[FumurtError]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkexpressions(tree:List[Expression], containingdefinition:Option[Defini
tion], containingdefinitionarguments:Option[List[DefLhs]], basicFunctions:List[D
efLhs]):List[FumurtError]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val insamedefinition = indexlefts(tree)
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
nin checkexpressions:   insamedefinition is "+insamedefinition+" containingdefin
ition is "+containingdefinition)
\end_layout

\begin_layout Plain Layout

    tree.foldLeft(List():List[FumurtError])((x,y) =>x ++checkexpression(y,
 containingdefinition, containingdefinitionarguments, basicFunctions, insamedefi
nition))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkexpression(tocheck:Expression, containingdefinition:Option[Definition
], arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs], inSameDefinition
:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
nIn checkexpression:   tocheck: "+tocheck+"containingdefinition: "+containingdef
inition+" arguments: "+arguments)
\end_layout

\begin_layout Plain Layout

    tocheck match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case x:Definition=>
\end_layout

\begin_layout Plain Layout

      { 
\end_layout

\begin_layout Plain Layout

        val (newargs, argpropagationerrors) = x.leftside.args match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case None => (List(), List())
\end_layout

\begin_layout Plain Layout

          case Some(Arguments(args)) => 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            val hits = arguments match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case Some(contargs) => args.flatMap(arg => (contargs++inSameDefinit
ion).find(y => y.id.value==arg.id.value))
\end_layout

\begin_layout Plain Layout

              case None => args.flatMap(arg => inSameDefinition.find(y =>
 y.id.value==arg.id.value))
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            if (hits.length == args.length)      //used to be !=.
 Don't know why.
 bug?
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              (hits, List())
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else 
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              
\end_layout

\begin_layout Plain Layout

              //(hits, List(FumurtError(x.pos,"One or more arguments not
 found in local scope"))) TODO: Find better solution than just abandoning
 compile time dependent checking.
 Checking for each function call might be possible...
\end_layout

\begin_layout Plain Layout

              (hits,List())
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        checkdefinition(x, containingdefinition.map(x=>x.leftside), Some(newargs),
 basicFunctions) ++ argpropagationerrors
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case x:Statement => containingdefinition match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case None => List(FumurtError(x.pos, "Statements must be enclosed
 in either Program or another definition"))
\end_layout

\begin_layout Plain Layout

        case Some(contdef) => /*println("
\backslash
n"+x);*/ checkstatement(x, contdef.leftside, arguments, basicFunctions, inSameDef
inition, contdef.leftside.returntype)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkstatement(tocheck:Statement, containingdefinition:DefLhs, arguments:O
ption[List[DefLhs]], basicFunctions:List[DefLhs], inSameDefinition:List[DefLhs],
 expectedreturn:TypeT): List[FumurtError]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
nIn checkstatement:   tocheck: "+tocheck+"containingdefinition: "+containingdefi
nition+" arguments: "+arguments)
\end_layout

\begin_layout Plain Layout

    tocheck match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case b:BasicValueStatement=> checkbasicvaluestatement(expectedreturn,
 b, "Return")
\end_layout

\begin_layout Plain Layout

      case b:IdentifierStatement=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val statedvalue = findinscope(arguments, inSameDefinition, basicFunction
s, Some(containingdefinition), b.value)
\end_layout

\begin_layout Plain Layout

        statedvalue match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Left(string) => List(FumurtError(b.pos, /*"in checkstatement
 "+*/string))
\end_layout

\begin_layout Plain Layout

          case Right(deflhs) => 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            if(containingdefinition.returntype.value != deflhs.returntype.value)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              List(FumurtError(b.pos, "expected: " +expectedreturn.value+
 ".
 Got: " +deflhs.returntype.value))
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              List()
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case y:FunctionCallStatement=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        //println("found "+y)
\end_layout

\begin_layout Plain Layout

        if (y.functionidentifier=="if")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          checkifcall(y, expectedreturn, containingdefinition, arguments,
 basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (y.functionidentifier=="plus" || y.functionidentifier=="minus"
 || y.functionidentifier=="multiply" || y.functionidentifier=="divide")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          checkbasicmathcall(y, expectedreturn, containingdefinition, arguments,
 basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (y.functionidentifier=="toString")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          checktostringcall(y, expectedreturn, containingdefinition, arguments,
 basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (y.functionidentifier=="actionMutate")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          checkmutatecall(y, expectedreturn, containingdefinition, arguments,
 basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (y.functionidentifier=="equal")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val reterror = if(expectedreturn!=TypeT("Boolean")) {List(FumurtError(
tocheck.pos, "Call to equal always returns boolean, not "+expectedreturn.value))}e
lse{List()}
\end_layout

\begin_layout Plain Layout

          val argerrors = y.args match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Right(NamedCallargs(List(NamedCallarg(IdT("left"), leftargument
), NamedCallarg(IdT("right"), rightargument)))) =>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              List()
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            case _=>List(FumurtError(tocheck.pos, "Call to equal requires
 two arguments named left and right"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          reterror++argerrors
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        /*else if (y.functionidentifier=="lessThan" || "biggerthan")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val reterror = if(expectedreturn!=TypeT("Boolean")) {List(FumurtError(
ifcall.pos, "Call to "+y.functionidentifier+" always returns boolean, not
 "+expectedreturn.value))} else{List()}
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (y.functionidentifier=="not")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val reterror = if(expectedreturn!=TypeT("Boolean")) {List(FumurtError(
ifcall.pos, "Call to not always returns boolean, not "+expectedreturn.value))}
 else{List()}
\end_layout

\begin_layout Plain Layout

        }*/
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          findinscope(arguments, inSameDefinition, basicFunctions, Some(containi
ngdefinition), y.functionidentifier) match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Left(string) => List(FumurtError(y.pos, /*"in checkstatement_2
 "+*/string))
\end_layout

\begin_layout Plain Layout

            case Right(calledfunction) => 
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              val argumenterrors:List[FumurtError] = y.args match 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                case Left(NoArgs()) => calledfunction.args match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case None => List()
\end_layout

\begin_layout Plain Layout

                  case Some(_) => List(FumurtError(y.pos, "expected arguments,
 but none were given")) 
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                case Left(callarg) => calledfunction.args match //checkCallarg(,
 callarg, containingdefinition, arguments, basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case Some(Arguments(args)) => 
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    if (args.length != 1) { List(FumurtError(y.pos, "expected
 "+args.length+" arguments, but only one was given")) }
\end_layout

\begin_layout Plain Layout

                    else { checkCallarg(args(0).typestr, callarg, args(0).id,
 containingdefinition, arguments, basicFunctions, inSameDefinition) }
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case None => List(FumurtError(y.pos, "expected no arguments,
 but some were given")) 
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                case Right(NamedCallargs(value)) => 
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  //println("checking namedcallargs "+value)
\end_layout

\begin_layout Plain Layout

                  checknamedcallargs(calledfunction, value, containingdefinition
, arguments, basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              } 
\end_layout

\begin_layout Plain Layout

              val returnerror:List[FumurtError] = if (expectedreturn !=
 calledfunction.returntype)
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                List(FumurtError(y.pos, "Expected return type "+expectedreturn.val
ue+".
 Got "+calledfunction.returntype.value/*+".
 containingdefinition is"+containingdefinition*/))
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              else {List()}
\end_layout

\begin_layout Plain Layout

              returnerror ++ argumenterrors
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkifcall(ifcall:FunctionCallStatement, expectedtype:TypeT, containingde
finition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    ifcall.args match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left(callarg) => List(FumurtError(ifcall.pos, "Call to if needs
 three arguments"))
\end_layout

\begin_layout Plain Layout

      case Right(NamedCallargs(arglist))=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        if (arglist.length != 3)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          List(FumurtError(ifcall.pos, "Call to if needs three arguments"))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          ( if(arglist(0).id.value != "condition"){List(FumurtError(ifcall.pos,
 "Call to if needs a condition argument"))} else {List()} )++
\end_layout

\begin_layout Plain Layout

          ( if(arglist(1).id.value != "else"){List(FumurtError(ifcall.pos,
 "Call to if needs an else argument"))} else {List()} )++
\end_layout

\begin_layout Plain Layout

          ( if(arglist(2).id.value != "then"){List(FumurtError(ifcall.pos,
 "Call to if needs a then argument"))} else {List()} )++
\end_layout

\begin_layout Plain Layout

          checkCallarg(TypeT("Boolean"), arglist(0).argument, IdT("condition"),
 containingdefinition, arguments, basicFunctions, inSameDefinition)++
\end_layout

\begin_layout Plain Layout

          (checkCallarg(expectedtype, arglist(1).argument, IdT("else"), containin
gdefinition, arguments, basicFunctions, inSameDefinition))++
\end_layout

\begin_layout Plain Layout

          (checkCallarg(expectedtype, arglist(2).argument, IdT("then"), containin
gdefinition, arguments, basicFunctions, inSameDefinition))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkmutatecall(call:FunctionCallStatement, expectedtype:TypeT, containing
definition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("mutate call "+call)
\end_layout

\begin_layout Plain Layout

    call.args match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left=>List(FumurtError(call.pos, "call to mutate requires both
 a variable, and a new value to assign to that variable"))
\end_layout

\begin_layout Plain Layout

      case Right(NamedCallargs(List(value:NamedCallarg, variable:NamedCallarg)))
=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val firstnameerror = if(value.id.value != "newValue"){List(FumurtError(cal
l.pos, "call to mutate requires argument 
\backslash
"newValue
\backslash
""))} else{List()}
\end_layout

\begin_layout Plain Layout

        val lastnameerror = if(variable.id.value != "variable"){List(FumurtError(c
all.pos, "call to mutate requires argument 
\backslash
"variable
\backslash
""))} else{List()}
\end_layout

\begin_layout Plain Layout

        val variabletypeerror = variable.argument match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case z:IdentifierStatement=>
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            findinscope(arguments, inSameDefinition, basicFunctions, Some(contai
ningdefinition), z.value) match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case Left(str) => List(FumurtError(z.pos, str))
\end_layout

\begin_layout Plain Layout

              case Right(defl)=>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                (if (defl.description != SynchronizedVariableT()) {List(FumurtErr
or(call.pos, "Variable must be synchronized"))}else{List()})++
\end_layout

\begin_layout Plain Layout

                (checkCallarg(defl.returntype, value.argument, IdT("variable"),
 containingdefinition, arguments, basicFunctions, inSameDefinition))
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          case z:Expression=>List(FumurtError(call.pos, "variable argument
 must be an identifier"))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        firstnameerror++lastnameerror++variabletypeerror
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkbasicmathcall(call:FunctionCallStatement, expectedtype:TypeT,
 containingdefinition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:Lis
t[DefLhs], inSameDefinition:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("in checkbasicmathcall.
 Call is "+call)
\end_layout

\begin_layout Plain Layout

    call.args match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left(callarg) => List(FumurtError(call.pos, "Call to "+call.functionide
ntifier+" needs two arguments"))
\end_layout

\begin_layout Plain Layout

      case Right(NamedCallargs(arglist))=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        if (arglist.length != 2)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          List(FumurtError(call.pos, "Call to "+call.functionidentifier+"
 needs two arguments"))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val leftinterrors = checkCallarg(TypeT("Integer"), arglist(0).argument,
 IdT("left"), containingdefinition, arguments, basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

          val rightinterrors = checkCallarg(TypeT("Integer"), arglist(1).argument
, IdT("right"), containingdefinition, arguments, basicFunctions, inSameDefinitio
n)
\end_layout

\begin_layout Plain Layout

          val leftdoubleerrors = checkCallarg(TypeT("Double"), arglist(0).argumen
t, IdT("left"), containingdefinition, arguments, basicFunctions, inSameDefinitio
n)
\end_layout

\begin_layout Plain Layout

          val rightdoubleerrors = checkCallarg(TypeT("Double"), arglist(1).argume
nt, IdT("right"), containingdefinition, arguments, basicFunctions, inSameDefinit
ion)
\end_layout

\begin_layout Plain Layout

          val (lefterrors, leftdouble) = if (leftinterrors.length < leftdoubleerr
ors.length){(leftinterrors,false)} else {(leftdoubleerrors,true)}
\end_layout

\begin_layout Plain Layout

          val (righterrors, rightdouble) = if (rightinterrors.length < rightdoubl
eerrors.length){(rightinterrors,false)} else {(rightdoubleerrors,true)}
\end_layout

\begin_layout Plain Layout

          val returnsdouble = leftdouble || rightdouble
\end_layout

\begin_layout Plain Layout

          ( if(arglist(0).id.value != "left"){List(FumurtError(call.pos, "Call
 to "+call.functionidentifier+" needs a left argument"))} else {List()} )++
\end_layout

\begin_layout Plain Layout

          ( if(arglist(1).id.value != "right"){List(FumurtError(call.pos, "Call
 to "+call.functionidentifier+" needs a right argument"))} else {List()}
 )++
\end_layout

\begin_layout Plain Layout

          ( lefterrors )++
\end_layout

\begin_layout Plain Layout

          ( righterrors )++
\end_layout

\begin_layout Plain Layout

          ( expectedtype match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case TypeT("Double")=>List(); 
\end_layout

\begin_layout Plain Layout

              case TypeT("Integer") => if(returnsdouble){List(FumurtError(call.po
s, "This call to "+call.functionidentifier+" returns a Double not an Integer"))}
 else{List()} 
\end_layout

\begin_layout Plain Layout

              case TypeT(str)=>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                if(returnsdouble){List(FumurtError(call.pos, "This call to
 "+call.functionidentifier+" returns a Double not "+str))}
\end_layout

\begin_layout Plain Layout

                else{List(FumurtError(call.pos, "This call to "+call.functionident
ifier+" returns an Integer not "+str))}
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checktostringcall(call:FunctionCallStatement, expectedtype:TypeT,
 containingdefinition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:Lis
t[DefLhs], inSameDefinition:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    call.args match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left(callarg) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val integererrors = checkCallarg(TypeT("Integer"), callarg, IdT("none
 needed as not user defined and single argument"), containingdefinition,
 arguments, basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        val doubleerrors = checkCallarg(TypeT("Double"), callarg, IdT("none
 needed as not user defined and single argument"), containingdefinition,
 arguments, basicFunctions, inSameDefinition)
\end_layout

\begin_layout Plain Layout

        val argumenterrors = if(integererrors.length < doubleerrors.length){intege
rerrors} else{doubleerrors}
\end_layout

\begin_layout Plain Layout

        val outerrors = expectedtype match{ case TypeT("String")=>List();
 case TypeT(str)=>List(FumurtError(call.pos, "toString returns String not
 "+str))}
\end_layout

\begin_layout Plain Layout

        argumenterrors++outerrors
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case Right(NamedCallargs(arglist))=>List(FumurtError(call.pos, "Call
 to toString needs one argument"))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checknamedcallargs(calledfunction:DefLhs, namedcallargs:List[NamedCallarg]
, containingdefinition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:Li
st[DefLhs], inSameDefinition:List[DefLhs]):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    calledfunction.args match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None => List(FumurtError(namedcallargs(0).id.pos, "No arguments
 expected, but "+namedcallargs.length+" were given"))
\end_layout

\begin_layout Plain Layout

      case Some(Arguments(defargs)) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        if (defargs.length != namedcallargs.length) 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          List(FumurtError(namedcallargs(0).id.pos, "expected "+defargs.length+"
 arguments.
 Got "+namedcallargs.length+" arguments"))
\end_layout

\begin_layout Plain Layout

        } 
\end_layout

\begin_layout Plain Layout

        else 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if( !namedcallargs.groupBy(x => x.id.value).filter(y => y._2.length>1).isEmpt
y ) //ensure uniqueness of arguments
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            List(FumurtError(namedcallargs(0).id.pos, "two or more arguments
 were given with the same name"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            val individualargumenterrors = ListBuffer():ListBuffer[FumurtError]
\end_layout

\begin_layout Plain Layout

            for(i<-0 until namedcallargs.length)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              individualargumenterrors ++= (if(namedcallargs(i).id.value !=
 defargs(i).id.value) 
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  //println("FOUND INCORRECT NAMES")
\end_layout

\begin_layout Plain Layout

                  List(FumurtError(namedcallargs(i).id.pos, "Wrong argument
 name.
 Argument in definition named "+defargs(i).id.value+".
 In calling named "+namedcallargs(i).id.value ))
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                else 
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  checkCallarg(defargs(i).typestr, namedcallargs(i).argument,
 defargs(i).id, containingdefinition, arguments:Option[List[DefLhs]], basicFuncti
ons:List[DefLhs], inSameDefinition:List[DefLhs])
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              )
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            //println("individualargumenterrors.toList: "+individualargumenterror
s.toList)
\end_layout

\begin_layout Plain Layout

            individualargumenterrors.toList
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkCallarg(expectedtype:TypeT, arg:Callarg, id:IdT, containingdefinition
:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs], inSameDefi
nition:List[DefLhs]):List[FumurtError] = 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("in checkCallarg.
 arg is "+arg)
\end_layout

\begin_layout Plain Layout

    arg match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case c:BasicValueStatement=> checkbasicvaluestatement(expectedtype,
 c, "Call argument")
\end_layout

\begin_layout Plain Layout

      case c:NoArgs => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        println("NoArgs got checked by checkCallarg.
 This is better checked in checkstatement"); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case c:IdentifierStatement => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        findinscope(arguments, inSameDefinition, basicFunctions, Some(containing
definition), c.value) match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Left(str) => List(FumurtError(c.pos, /*"in checkcallarg "+*/str))
\end_layout

\begin_layout Plain Layout

          case Right(thingdef) =>
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            if(expectedtype.value == "Inclusion")
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              if(thingdef.id.value != id.value)
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                List(FumurtError(c.pos, "Passed inclusion must be the same
 as the one referenced inside the function"))
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              else{List()}
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else if(expectedtype.value != thingdef.returntype.value)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              List(FumurtError(c.pos, "Expected type "+expectedtype.value+".
 Got "+thingdef.returntype.value))
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else {List()}
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case c:FunctionCallStatement => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        //check that call end result is correct
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        //check that call itself is correct
\end_layout

\begin_layout Plain Layout

        val callerrors = checkstatement(c, containingdefinition, arguments,
 basicFunctions, inSameDefinition, expectedtype)
\end_layout

\begin_layout Plain Layout

        callerrors //++ resulterrors
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkbasicvaluestatement(expectedtype:TypeT, basicstatement:BasicValueStat
ement, role:String):List[FumurtError] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    basicstatement match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case c:StringStatement => {if (expectedtype.value != "String") List(FumurtE
rror(c.pos, role+" type should be "+expectedtype.value+".
 "+role+" type was String")) else List()}
\end_layout

\begin_layout Plain Layout

      case c:IntegerStatement => {if (expectedtype.value != "Integer") List(Fumur
tError(c.pos, role+" type should be "+expectedtype.value+".
 "+role+" type was Integer")) else List()}
\end_layout

\begin_layout Plain Layout

      case c:DoubleStatement => {if (expectedtype.value != "Double") List(FumurtE
rror(c.pos, role+" type should be "+expectedtype.value+".
 "+role+" type was Double")) else List()}
\end_layout

\begin_layout Plain Layout

      case c:TrueStatement => {if (expectedtype.value != "Boolean") List(FumurtEr
ror(c.pos, role+" type should be "+expectedtype.value+".
 "+role+" type was Boolean")) else List()}
\end_layout

\begin_layout Plain Layout

      case c:FalseStatement => {if (expectedtype.value != "Boolean") List(FumurtE
rror(c.pos, role+" type should be "+expectedtype.value+".
 "+role+" type was Boolean")) else List()}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def checkdefinition(tocheck:Definition, containingdefinition:Option[DefLhs],
 arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs]): List[FumurtError]
=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
nIn checkdefinition:   tocheck: "+tocheck+"containingdefinition: "+containingdef
inition+" arguments: "+arguments)
\end_layout

\begin_layout Plain Layout

    val undererrors = checkexpressions(tocheck.rightside.expressions, Some(tocheck
), arguments, basicFunctions)
\end_layout

\begin_layout Plain Layout

    val threadenderror:List[FumurtError] = tocheck.leftside.description match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case ThreadT() => tocheck.rightside.expressions.last match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case FunctionCallStatement(functionidentifier,_) =>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if(functionidentifier != tocheck.leftside.id.value)
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            List(FumurtError(tocheck.rightside.expressions.last.pos, "A thread
 must recurse on itself (at least until exit() is implemented)"))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            List()
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case _ => List(FumurtError(tocheck.rightside.expressions.last.pos, "A
 thread must recurse on itself (at least until exit() is implemented)"))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case _ => List()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val nameerror = tocheck.leftside.description match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case ActionT() => if(!tocheck.leftside.id.value.startsWith("action"))
 {List(FumurtError(tocheck.pos, "Name of action is not prefixed with 
\backslash
"action
\backslash
""))} else{List()}
\end_layout

\begin_layout Plain Layout

      case ThreadT() => if(!tocheck.leftside.id.value.startsWith("thread"))
 {List(FumurtError(tocheck.pos, "Name of thread is not prefixed with 
\backslash
"thread
\backslash
""))} else{List()}
\end_layout

\begin_layout Plain Layout

      case FunctionT() => List()
\end_layout

\begin_layout Plain Layout

      case ValueT() => List()
\end_layout

\begin_layout Plain Layout

      case ProgramT() => println("Program got checked by checkdefinition.
 This is better checked in checkprogram"); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val permissionerror = tocheck.leftside.description match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case ActionT() => containingdefinition match
\end_layout

\begin_layout Plain Layout

      { 
\end_layout

\begin_layout Plain Layout

        case None=>List()
\end_layout

\begin_layout Plain Layout

        case Some(DefLhs(ValueT(),_,_,_))=> List(FumurtError(tocheck.pos,
 "actions cannot be defined in values"))
\end_layout

\begin_layout Plain Layout

        case Some(DefLhs(FunctionT(),_,_,_))=> List(FumurtError(tocheck.pos,
 "actions cannot be defined in  functions"))
\end_layout

\begin_layout Plain Layout

        case Some(something) => List()
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case ThreadT() => containingdefinition match{ case None => List();
 case Some(_)=>List(FumurtError(tocheck.pos, "threads must be defined on
 top "+containingdefinition))}
\end_layout

\begin_layout Plain Layout

      case FunctionT() => containingdefinition match{ case Some(DefLhs(ValueT(),
_,_,_)) => List(FumurtError(tocheck.pos, "functions cannot be defined in
 values")); case _=> List()}
\end_layout

\begin_layout Plain Layout

      case SynchronizedVariableT() => List(FumurtError(tocheck.pos, "synchronized
 variables must be defined in Program definition"))
\end_layout

\begin_layout Plain Layout

      case ValueT() => List()
\end_layout

\begin_layout Plain Layout

      case ProgramT() => println("Program got checked by checkdefinition.
 This is better checked in checkprogram"); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    undererrors.toList ++ nameerror ++ permissionerror ++ threadenderror
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def indexlefts(in:List[Expression]):List[DefLhs]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    in.foldLeft(List():List[DefLhs]) ((list,y)=> y match
\end_layout

\begin_layout Plain Layout

      { 
\end_layout

\begin_layout Plain Layout

        case Definition(leftside, _)=>list :+ leftside; 
\end_layout

\begin_layout Plain Layout

        case _:Statement=> list
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def findinscope(arguments:Option[List[DefLhs]], inSameDefinition:List[DefLhs],
 basicfunctions:List[DefLhs], enclosingDefinition:Option[DefLhs], searchFor:Stri
ng):Either[String, DefLhs]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val argsres = arguments match{ case Some(args)=>args.filter(y=>y.id.value==sear
chFor); case None=>List():List[DefLhs]}
\end_layout

\begin_layout Plain Layout

    val inscoperes = inSameDefinition.filter(x=>x.id.value==searchFor)
\end_layout

\begin_layout Plain Layout

    //println()
\end_layout

\begin_layout Plain Layout

    //println(basicfunctions)
\end_layout

\begin_layout Plain Layout

    //println()
\end_layout

\begin_layout Plain Layout

    val basicfunctionres = basicfunctions.filter(x=>x.id.value==searchFor)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val enclosingres = enclosingDefinition match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None => List()
\end_layout

\begin_layout Plain Layout

      case Some(deff) => if (deff.id.value == searchFor) {List(deff)} else
 {List()}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val res = argsres ++ inscoperes ++ basicfunctionres ++ enclosingres
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if(res.length == 1)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      Right(res.head)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(res.length>1)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      Left("Ambiguous reference to "+searchFor)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(res.length == 0)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      enclosingDefinition match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case None=>Left(searchFor+" not found" /*+" arguments is: "+arguments+".
 insamedefinition is "+inSameDefinition*/)
\end_layout

\begin_layout Plain Layout

        case Some(DefLhs(_,_,Some(Arguments(internalargs)),_))=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          internalargs.find(x=>x.id.value==searchFor) match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Some(Argument(id, TypeT("Inclusion")))=> Left(searchFor+"
 not found" /*+" arguments is: "+arguments+".
 insamedefinition is "+inSameDefinition*/)
\end_layout

\begin_layout Plain Layout

            case Some(Argument(id, typestr))=> Right(DefLhs(ValueT(),id,None,typ
estr))
\end_layout

\begin_layout Plain Layout

            case None=>Left(searchFor+" not found" /*+" arguments is: "+argument
s+".
 insamedefinition is "+inSameDefinition*/)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case Some(_)=> Left(searchFor+" not found" /*+" arguments is: "+argument
s+".
 insamedefinition is "+inSameDefinition*/)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      Left("error in search for "+searchFor)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//TODO: add type for synchronized variables and use it to pass them around,
 so that it can be controlled that a thread calling actionMutate has write
 rights
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
CodeGenerator.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.collection.mutable.ListBuffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object FumurtCodeGenerator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def generate(ast:List[Definition]):String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val includestatement = "#include <iostream>
\backslash
n#include <thread>
\backslash
n#include <string>
\backslash
n#include <atomic>
\backslash
n#include <condition_variable>
\backslash
n#include <list>
\backslash
n#include <chrono>
\backslash
n
\backslash
n
\backslash
n"
\end_layout

\begin_layout Plain Layout

    val topthreads = gettopthreadstatements(ast)
\end_layout

\begin_layout Plain Layout

    val atree = getAnnotatedTree(ast, topthreads)
\end_layout

\begin_layout Plain Layout

    //println(atree)
\end_layout

\begin_layout Plain Layout

    val numtopthreads = topthreads.length
\end_layout

\begin_layout Plain Layout

    val synchronizationGlobalVars = "static std::atomic<int> rendezvousCounter;
\backslash
nstatic std::mutex rendezvousSyncMutex;
\backslash
nstatic std::condition_variable cv;"
\end_layout

\begin_layout Plain Layout

    val main = getmain(topthreads, atree)
\end_layout

\begin_layout Plain Layout

    val synchvars = getsynchronizedvariables(ast)
\end_layout

\begin_layout Plain Layout

    val syncfunc = getsynchronizerfunction(synchvars, topthreads)
\end_layout

\begin_layout Plain Layout

    val synchvardeclarations = getGlobalSynchVariableDeclarations(synchvars)
\end_layout

\begin_layout Plain Layout

    val printdecs = getprintlistdeclarations(topthreads)
\end_layout

\begin_layout Plain Layout

    //val topthreaddeclarations = gettopthreaddeclarations(ast)
\end_layout

\begin_layout Plain Layout

    val (funSignatures, funDeclarations) = getFunctionDeclarations(atree)
\end_layout

\begin_layout Plain Layout

    val staticthreadargs = getStaticThreadArgs(atree:List[aExpression])
\end_layout

\begin_layout Plain Layout

    val topThreadNumMacroln = "#define NUMTOPTHREADS " + numtopthreads.toString
 + "
\backslash
n"
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    //println(funSignatures)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    includestatement + topThreadNumMacroln + funSignatures + "
\backslash
n" + synchvardeclarations + printdecs + "
\backslash
n" + synchronizationGlobalVars + staticthreadargs + syncfunc + "
\backslash
n
\backslash
n" /*+ topthreaddeclarations*/ + "
\backslash
n"+ funDeclarations + "
\backslash
n
\backslash
n" + main
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getAnnotatedTree(ast:List[Expression], topthreadcalls:List[FunctionCallSta
tement]):List[aExpression] = 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val treeWithAnnotatedDefinitions = getAnnotatedTreeInternal(ast,topthreadcal
ls,"", None)
\end_layout

\begin_layout Plain Layout

    getCallsAnnotatedTreeInternal(treeWithAnnotatedDefinitions, List(),
 None)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getCallsAnnotatedTreeInternal(ast:List[aExpression], arguments:List[aDefLh
s], containingDefinition:Option[aDefinition]):List[aExpression] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val inSameDefinition = indexlefts(ast)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    ast.flatMap(node=>node match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case deff @ aDefinition(aDefLhs(desc, id, cppid, callingthread,
 args, returntype), aDefRhs(expressions))=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val argumentsToDef = args match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case None => List()
\end_layout

\begin_layout Plain Layout

            case Some(aArguments(arglist)) => arglist.flatMap(arg =>
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  val fromargs = arguments.find(x=>x.id.value==arg.id.value)
\end_layout

\begin_layout Plain Layout

                  val fromSame = inSameDefinition.find(x => x.id.value == arg.id.valu
e)
\end_layout

\begin_layout Plain Layout

                  fromargs match
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    case Some(_)=>fromargs
\end_layout

\begin_layout Plain Layout

                    case None=>fromSame
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              )
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          //println("
\backslash
n{deff: "+deff+"
\backslash
nargumentsToDef: "+argumentsToDef+"
\backslash
nargs: "+args+"
\backslash
n
\backslash
nast: "+ast+"
\backslash
n
\backslash
narguments: "+arguments+"}
\backslash
n
\backslash
n
\backslash
n")
\end_layout

\begin_layout Plain Layout

          val aexpressions = getCallsAnnotatedTreeInternal(expressions,
 argumentsToDef, Some(deff))
\end_layout

\begin_layout Plain Layout

          Some(aDefinition(aDefLhs(desc, id, cppid, callingthread, args,
 returntype), aDefRhs(aexpressions)))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case call @ aFunctionCallStatement(fid,_,args,_) => Some(annotateFunctio
nCall(call, arguments, inSameDefinition, containingDefinition))
\end_layout

\begin_layout Plain Layout

        case z:IdentifierStatement=>Some(z)
\end_layout

\begin_layout Plain Layout

        case z:BasicValueStatement=>Some(z)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def annotateFunctionCall( functioncall:aFunctionCallStatement, arguments:List[
aDefLhs], inSameDefinition:List[aDefLhs], containingDefinition:Option[aDefinitio
n] ): aFunctionCallStatement=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def annotateCallargs(args: Either[aCallarg,aNamedCallargs], arguments:List[a
DefLhs], inSameDefinition:List[aDefLhs], containingDefinition:Option[aDefinition
]): Either[aCallarg,aNamedCallargs] =
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      args match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case Left(callarg)=>callarg match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case z:aFunctionCallStatement=>Left(annotateFunctionCall(z, arguments,
 inSameDefinition, containingDefinition))
\end_layout

\begin_layout Plain Layout

          case z:aStatement=>Left(z)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case Right(aNamedCallargs(callargs)) => Right(aNamedCallargs(callargs.map
(namedcallarg => namedcallarg.argument match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case z:aFunctionCallStatement => aNamedCallarg(namedcallarg.id,
 annotateFunctionCall(z, arguments, inSameDefinition, containingDefinition))
\end_layout

\begin_layout Plain Layout

            case aCallarg=>namedcallarg:aNamedCallarg
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        )))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val fid = functioncall.functionidentifier
\end_layout

\begin_layout Plain Layout

    val args = functioncall.args
\end_layout

\begin_layout Plain Layout

    if(fid=="actionPrint" || fid=="toString" || fid=="actionMutate")
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val newargs = annotateCallargs(args, arguments, inSameDefinition,
 containingDefinition)
\end_layout

\begin_layout Plain Layout

      aFunctionCallStatement(fid,fid,newargs,"Nothing")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(fid=="plus" || fid=="minus" || fid=="multiply" || fid=="divide")
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val newargs = annotateCallargs(args, arguments, inSameDefinition,
 containingDefinition)
\end_layout

\begin_layout Plain Layout

      aFunctionCallStatement(fid,fid,newargs,"Number") //TODO: Find actual
 type like in typechecker.
 As it is, it only matters if it is Nothing or not.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(fid=="equal" || fid=="lessThan")
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val newargs = annotateCallargs(args, arguments, inSameDefinition,
 containingDefinition)
\end_layout

\begin_layout Plain Layout

      aFunctionCallStatement(fid,fid,newargs,"Boolean")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(fid=="if")
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val newargs = annotateCallargs(args, arguments, inSameDefinition,
 containingDefinition)
\end_layout

\begin_layout Plain Layout

      aFunctionCallStatement(fid,fid,newargs,"Something") //TODO: Find actual
 type like in typechecker.
 As it is, it only matters if it is Nothing or not.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      def removeInclusions(args: Either[aCallarg,aNamedCallargs],  ldeffargs:Opt
ion[aArguments]): Either[aCallarg,aNamedCallargs] = args match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case Left(callarg)=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          ldeffargs match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Some(aArguments(defargs))=>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              if(defargs.head.typestr.value == "Inclusion") {Left(NoArgs())}
\end_layout

\begin_layout Plain Layout

              else
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                args
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            case None=>Left(NoArgs())
\end_layout

\begin_layout Plain Layout

            //case _=>Left(NoArgs())
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case Right(aNamedCallargs(namedcallargs))=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          ldeffargs match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Some(aArguments(defargs))=>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              val mnewargs = ListBuffer():ListBuffer[aNamedCallarg]
\end_layout

\begin_layout Plain Layout

              for(i<-0 until defargs.length)
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                if(defargs(i).typestr.value!="Inclusion")
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  mnewargs += namedcallargs(i)
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              Right(aNamedCallargs(mnewargs.toList))
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            case None=>println("in getCallsAnnotatedTreeInternal");scala.sys.exit(
)
\end_layout

\begin_layout Plain Layout

            //case _=>Left(NoArgs())
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      val ldeff = findinscope(Some(arguments), inSameDefinition, containingDefin
ition.map(x=>x.leftside), fid)
\end_layout

\begin_layout Plain Layout

      val newargs = annotateCallargs(removeInclusions(args, ldeff.args),
 arguments, inSameDefinition, containingDefinition)
\end_layout

\begin_layout Plain Layout

      //println("ldeff.cppid.value: "+ldeff.cppid.value)
\end_layout

\begin_layout Plain Layout

      aFunctionCallStatement(fid, ldeff.cppid.value, newargs, ldeff.returntype.value
)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def indexlefts(in:List[aExpression]):List[aDefLhs]=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    in.foldLeft(List():List[aDefLhs]) ((list,y)=> y match
\end_layout

\begin_layout Plain Layout

      { 
\end_layout

\begin_layout Plain Layout

        case aDefinition(leftside, _)=>list :+ leftside; 
\end_layout

\begin_layout Plain Layout

        case _=> list
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def findinscope(arguments:Option[List[aDefLhs]], inSameDefinition:List[aDefLhs
], enclosingDefinition:Option[aDefLhs], searchFor:String):aDefLhs=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val argsres = arguments match{ case Some(args)=>args.filter(y=>y.id.value==sear
chFor); case None=>List():List[aDefLhs]}
\end_layout

\begin_layout Plain Layout

    val inscoperes = inSameDefinition.filter(x=>x.id.value==searchFor)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val enclosingres = enclosingDefinition match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None => List()
\end_layout

\begin_layout Plain Layout

      case Some(deff) => if (deff.id.value == searchFor) {List(deff)} else
 {List()}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val res = argsres ++ inscoperes ++ enclosingres
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if(res.length==0){println("{arguments: "+arguments+"
\backslash
n
\backslash
ninSameDefinition: "+inSameDefinition+"
\backslash
n
\backslash
nenclosingDefinition: "+enclosingDefinition+"
\backslash
n
\backslash
nsearchFor: "+searchFor+"}
\backslash
n
\backslash
n
\backslash
n");scala.sys.exit()}
\end_layout

\begin_layout Plain Layout

    res.head
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getAnnotatedTreeInternal(ast:List[Expression], topthreadcalls:List[Functio
nCallStatement], hierarchy:String, callingthread:Option[String]):List[aExpressio
n] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val topactions:List[aExpression] = 
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      if(hierarchy=="")
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val mess = topthreadcalls.map(threadcall=>threadcall.args match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Left(IdentifierStatement(argname)) =>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              val deff = ast.filter(x => x match {case Definition(DefLhs(ActionT(
), IdT(thisargname), _, _),_) =>argname==thisargname; case _=> false})
\end_layout

\begin_layout Plain Layout

              getAnnotatedTreeInternal(deff, List(), threadcall.functionidentifie
r, Some(threadcall.functionidentifier)): List[aExpression]
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            case Left(_)=> List():List[aExpression]
\end_layout

\begin_layout Plain Layout

            case Right(NamedCallargs(namedargs))=>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              val deffs = namedargs.flatMap(namedarg=>
\end_layout

\begin_layout Plain Layout

                namedarg match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case NamedCallarg(_,IdentifierStatement(argname))=>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    ast.find(y=>y match{case Definition(DefLhs(ActionT(),
 IdT(thisargname), _, _) ,_) => argname == thisargname; case _=> false})
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case _=>None
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              )
\end_layout

\begin_layout Plain Layout

              getAnnotatedTreeInternal(deffs,List(), threadcall.functionidentifie
r, Some(threadcall.functionidentifier)): List[aExpression]
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        ):List[List[aExpression]]
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        mess.foldLeft(List(): List[aExpression])((x,y) => x++y): List[aExpression
]
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        List()
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val rest:List[aExpression] = ast.flatMap(x=>x match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case Definition(DefLhs(ThreadT(), id, args, returntype), DefRhs(expressi
ons)) => 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val aexps = getAnnotatedTreeInternal(expressions, topthreadcalls.filter
(x => x.functionidentifier == id.value), id.value, Some(id.value))
\end_layout

\begin_layout Plain Layout

          //println("
\backslash
n"+args+"
\backslash
n
\backslash
n")
\end_layout

\begin_layout Plain Layout

          val newargs = args.map(args=>aArguments(args.args.map(arg=>arg match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case Argument(id, TypeT("Inclusion")) => aArgument(id,
 id, TypeT("Inclusion"))
\end_layout

\begin_layout Plain Layout

                  case Argument(argid, typee) => 
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    if (argid.value.startsWith("synchronized"))
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      aArgument(argid, argid, typee)
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    else
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      aArgument(argid, IdT(id.value+"$"+argid.value), typee)
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              )  
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

          //println(newargs+"
\backslash
n
\backslash
n
\backslash
n") 
\end_layout

\begin_layout Plain Layout

          Some(aDefinition(aDefLhs(ThreadT(), id, id, id.value, newargs,
 returntype),aDefRhs(aexps)))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        case Definition(DefLhs(FunctionT(), id, args, returntype), DefRhs(expres
sions)) => 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val aexps = getAnnotatedTreeInternal(expressions, topthreadcalls,
 hierarchy+id.value, callingthread)
\end_layout

\begin_layout Plain Layout

          val newargs = args.map(args=>aArguments(args.args.map(arg => aArgument(ar
g.id, arg.id, arg.typestr))))
\end_layout

\begin_layout Plain Layout

          Some(aDefinition(aDefLhs(FunctionT(), id, IdT(id.value+"$"+hierarchy),
 "shouldn't matter", newargs, returntype), aDefRhs(aexps)))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case Definition(DefLhs(ProgramT(),_,_,_),_) => None //we don't really
 care about it...
\end_layout

\begin_layout Plain Layout

        case Definition(DefLhs(ActionT(), id, args, returntype), DefRhs(expressi
ons)) => 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if(hierarchy=="")
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            None
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            val aexps = getAnnotatedTreeInternal(expressions, topthreadcalls,
 hierarchy+id.value, callingthread)
\end_layout

\begin_layout Plain Layout

            val newargs = args.map(args=>aArguments(args.args.map(arg => aArgument(
arg.id, arg.id, arg.typestr))))
\end_layout

\begin_layout Plain Layout

            Some(aDefinition(aDefLhs(ActionT(), id, IdT(id.value+"$"+hierarchy),
 callingthread match {case Some(z)=>z; case None=>"not found"}, newargs,
 returntype), aDefRhs(aexps)))
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case FunctionCallStatement(fid,args)=>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          def annotateCallarg(callarg:Callarg):aCallarg=
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            callarg match
\end_layout

\begin_layout Plain Layout

            { 
\end_layout

\begin_layout Plain Layout

              case z:aCallarg => z
\end_layout

\begin_layout Plain Layout

              case FunctionCallStatement(fid,args)=>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val newargs:Either[aCallarg,aNamedCallargs] = args match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case Left(arg)=>Left(annotateCallarg(arg))
\end_layout

\begin_layout Plain Layout

                  case Right(NamedCallargs(arglist)) => Right(aNamedCallargs(arg
list.map(x => aNamedCallarg(x.id, annotateCallarg(x.argument)) )))
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                aFunctionCallStatement(fid,"not filled out",newargs,"not
 filled out")
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          Some(annotateCallarg(FunctionCallStatement(fid, args))): Option[aExpre
ssion]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case z:IdentifierStatement=>Some(z)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    ):List[aExpression]
\end_layout

\begin_layout Plain Layout

    rest++topactions
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getFunctionDeclarations(ast:List[aExpression]):(String,String) =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    def actfunrecursivetranslate(cppid:IdT, callingthread:String, args:Option[aA
rguments], returntype:TypeT, expressions:List[aExpression]):Option[(String,Strin
g)] =
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val signature = getFunctionSignature(cppid, args, returntype)
\end_layout

\begin_layout Plain Layout

      val functionstart = signature+"
\backslash
n{"
\end_layout

\begin_layout Plain Layout

      val functionend = "
\backslash
n}
\backslash
n"
\end_layout

\begin_layout Plain Layout

      val generals = expressions.flatMap(
\end_layout

\begin_layout Plain Layout

        y=> y match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case aDefinition(leftside, rightside)=>None
\end_layout

\begin_layout Plain Layout

          case z:aFunctionCallStatement =>
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            if(z.returntype!="Nothing")
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              Some("return "+functioncalltranslator(z, callingthread) +
 "; //returntype: "+z.returntype)
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              Some(functioncalltranslator(z, callingthread) + ";")
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          case IdentifierStatement(value) => Some("return "+value+";")
\end_layout

\begin_layout Plain Layout

          case StringStatement(value) => Some("return "+value+";")
\end_layout

\begin_layout Plain Layout

          case IntegerStatement(value) => Some("return "+value.toString+";")
\end_layout

\begin_layout Plain Layout

          case DoubleStatement(value) => Some("return "+value.toString+";")
\end_layout

\begin_layout Plain Layout

          case TrueStatement() => Some("return true;")
\end_layout

\begin_layout Plain Layout

          case FalseStatement() => Some("return false;")
\end_layout

\begin_layout Plain Layout

          //case _=> "not implemented" //println("Error in gettopthreaddeclarati
ons.
 Not implemented."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      ).foldLeft("")((x,y)=>x+"
\backslash
n  "+y)
\end_layout

\begin_layout Plain Layout

      val underfunctions = getFunctionDeclarations(expressions)
\end_layout

\begin_layout Plain Layout

      val body = functionstart+generals+functionend
\end_layout

\begin_layout Plain Layout

      //Some((signature+";",body))
\end_layout

\begin_layout Plain Layout

      Some((signature+";"+underfunctions._1, body+underfunctions._2))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val list = ast.flatMap(node=>node match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case aDefinition(aDefLhs(ThreadT(), id, cppid, _, args, _), aDefRhs(expr
essions)) =>
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          val attributeNoreturn = if( System.getProperty("os.name").startsWith("Win
dows") ) {"__declspec(noreturn)"} else{"[[noreturn]]"} //Microsoft Visual
 C++ does not support C++11 attribute syntax
\end_layout

\begin_layout Plain Layout

          val signature = attributeNoreturn+" static void "+cppid.value+"()"
\end_layout

\begin_layout Plain Layout

          val functionstart = signature+"
\backslash
n{"
\end_layout

\begin_layout Plain Layout

          val functionend = "
\backslash
n}
\backslash
n"
\end_layout

\begin_layout Plain Layout

          val (tailrecursestart, tailrecurseend) = ("while(true)
\backslash
n{", "
\backslash
n}")
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

          def changeNamesToCppOnes(in:aCallarg, threadargs:Option[aArguments]):a
Callarg = in match 
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case call:aFunctionCallStatement=>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    val newargs:Either[aCallarg,aNamedCallargs] = call.args
 match
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      case Left(callarg) => Left(changeNamesToCppOnes(callarg,
 threadargs))
\end_layout

\begin_layout Plain Layout

                      case Right(aNamedCallargs(namedcallargs)) => Right(aNamedC
allargs(namedcallargs.map( namedcallarg => aNamedCallarg(namedcallarg.id,
 changeNamesToCppOnes( namedcallarg.argument, threadargs )))) )
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    aFunctionCallStatement(call.functionidentifier, call.cppfuncti
onidentifier, newargs, call.returntype)
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case IdentifierStatement(value)=>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    threadargs match
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      case None => IdentifierStatement(value)
\end_layout

\begin_layout Plain Layout

                      case Some(aArguments(arglist)) =>
\end_layout

\begin_layout Plain Layout

                      {
\end_layout

\begin_layout Plain Layout

                        val arg = arglist.find(arg=>arg.id.value == value)
 match{case Some(x)=>x;case None => println("error in functioncallargmodifier");
 scala.sys.exit()}
\end_layout

\begin_layout Plain Layout

                        IdentifierStatement(arg.cppid.value)
\end_layout

\begin_layout Plain Layout

                      } 
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case _=>in
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

          val generals = expressions.flatMap(
\end_layout

\begin_layout Plain Layout

            y=> y match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case aDefinition(leftside, rightside)=>None
\end_layout

\begin_layout Plain Layout

              case aFunctionCallStatement(id.value,_, callargs,_) => 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val updates = args match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case None => ""
\end_layout

\begin_layout Plain Layout

                  case Some(aArguments(List(aArgument(argid, cppargid, _))))
 =>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    callargs match
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      case Left(callarg) => 
\end_layout

\begin_layout Plain Layout

                      {
\end_layout

\begin_layout Plain Layout

                        val newvalue = callargTranslator(callarg, id.value)
\end_layout

\begin_layout Plain Layout

                        if (argid.value.startsWith("synchronized"))
\end_layout

\begin_layout Plain Layout

                        {
\end_layout

\begin_layout Plain Layout

                          if( argid.value!=newvalue){"
\backslash
nwe haven't figured out the correct way to handle this yet"}
\end_layout

\begin_layout Plain Layout

                          else{""}
\end_layout

\begin_layout Plain Layout

                        }
\end_layout

\begin_layout Plain Layout

                        else{"
\backslash
n"+cppargid.value+" = "+callargTranslator( changeNamesToCppOnes(callarg,
 args), id.value )+";
\backslash
n"}
\end_layout

\begin_layout Plain Layout

                          
\end_layout

\begin_layout Plain Layout

                      }
\end_layout

\begin_layout Plain Layout

                      case Right(_)=>"error in generating updates1"
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  case Some(aArguments(defargslist)) =>
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    callargs match
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      case Right(namedcallargs) =>
\end_layout

\begin_layout Plain Layout

                      {
\end_layout

\begin_layout Plain Layout

                        namedcallargs.value.foldLeft("
\backslash
n")((l,r)=>
\end_layout

\begin_layout Plain Layout

                          {
\end_layout

\begin_layout Plain Layout

                            val newvalue = callargTranslator(r.argument,
 id.value)
\end_layout

\begin_layout Plain Layout

                            if( r.id.value.startsWith( "synchronized" ) )
\end_layout

\begin_layout Plain Layout

                            {
\end_layout

\begin_layout Plain Layout

                              if (r.id.value.startsWith( "synchronized" ) &&
 r.id.value != newvalue) {l + "
\backslash
nwe haven't figured out the correct way to handle this yet"}
\end_layout

\begin_layout Plain Layout

                              else{l}
\end_layout

\begin_layout Plain Layout

                            }
\end_layout

\begin_layout Plain Layout

                            else
\end_layout

\begin_layout Plain Layout

                            {
\end_layout

\begin_layout Plain Layout

                              val defarg = defargslist.find(defarg => defarg.id.val
ue == r.id.value) match{case Some(x) => x; case None => println("error in
 generating updates3"); scala.sys.exit()}
\end_layout

\begin_layout Plain Layout

                              l+defarg.cppid.value +" = "+ callargTranslator(
 changeNamesToCppOnes( r.argument, args ) , id.value) + ";
\backslash
n"
\end_layout

\begin_layout Plain Layout

                            }
\end_layout

\begin_layout Plain Layout

                          }
\end_layout

\begin_layout Plain Layout

                        )
\end_layout

\begin_layout Plain Layout

                      }
\end_layout

\begin_layout Plain Layout

                      case Left(_)=>"error in generating updates2"
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                Some("waitForRendezvous(
\backslash
""+ cppid.value+"
\backslash
");" +updates+ "
\backslash
n  continue;") 
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              case z:aFunctionCallStatement =>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val modified = changeNamesToCppOnes(z, args) match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case a:aFunctionCallStatement => a
\end_layout

\begin_layout Plain Layout

                  case _=> println("eror when modifying function call");scala.sys.
exit()
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                Some(functioncalltranslator(modified, id.value) + ";")
\end_layout

\begin_layout Plain Layout

              } 
\end_layout

\begin_layout Plain Layout

              //case z:aFunctionCallStatement => Some(functioncalltranslator(z,
 id.value) + ";")
\end_layout

\begin_layout Plain Layout

              //case _=> "not implemented" //println("Error in gettopthreaddecla
rations.
 Not implemented."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          ).foldLeft("")((x,y)=>x+"
\backslash
n  "+y)
\end_layout

\begin_layout Plain Layout

          val underfunctions = getFunctionDeclarations(expressions)
\end_layout

\begin_layout Plain Layout

          val body = functionstart + tailrecursestart + generals + tailrecurseen
d + functionend
\end_layout

\begin_layout Plain Layout

          Some((signature+";"+underfunctions._1, body+underfunctions._2))
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case z:aFunctionCallStatement=>None
\end_layout

\begin_layout Plain Layout

        case z:IdentifierStatement=>None
\end_layout

\begin_layout Plain Layout

        case aDefinition(aDefLhs(ActionT(), id, cppid, callingthread, args,
 returntype), aDefRhs(expressions)) => actfunrecursivetranslate(cppid, callingth
read, args, returntype, expressions)
\end_layout

\begin_layout Plain Layout

        case aDefinition(aDefLhs(FunctionT(), id, cppid, callingthread,
 args, returntype),aDefRhs(expressions)) => actfunrecursivetranslate(cppid,
 callingthread, args, returntype, expressions)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    ):List[(String,String)]
\end_layout

\begin_layout Plain Layout

    list.foldLeft(("",""))((x,y)=>(x._1+"
\backslash
n"+y._1,x._2+"
\backslash
n"+y._2))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getFunctionSignature(cppid:IdT, optargs:Option[aArguments], returntype:Typ
eT):String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    def argtranslator(arg:aArgument):String=
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      typetranslator(arg.typestr)+" "+arg.id.value
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val argsString = optargs match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None=>""
\end_layout

\begin_layout Plain Layout

      case Some(aArguments(List(arg)))=>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        if(arg.typestr.value!="Inclusion")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          argtranslator(arg)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else{""}
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case Some(aArguments(args))=>argtranslator(args.head) + args.tail.foldLeft(""
)((x,y)=>
\end_layout

\begin_layout Plain Layout

        if(y.typestr.value!="Inclusion"){x+", "+argtranslator(y)} else{x}
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    typetranslator(returntype)+" "+cppid.value+"("+argsString+")"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def typetranslator(in:TypeT):String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    in.value match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case "Integer"=>"int"
\end_layout

\begin_layout Plain Layout

      case "Double"=>"double"
\end_layout

\begin_layout Plain Layout

      case "String"=>"std::string"
\end_layout

\begin_layout Plain Layout

      case "Nothing"=>"void"
\end_layout

\begin_layout Plain Layout

      case "Inclusion"=>"shouldn't be here"
\end_layout

\begin_layout Plain Layout

      case "Boolean"=>"bool"
\end_layout

\begin_layout Plain Layout

      case _=>"not implemented"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def callargTranslator(callarg:aCallarg, callingthread:String):String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    callarg match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case StringStatement(value)=>value
\end_layout

\begin_layout Plain Layout

      case IntegerStatement(value)=>value.toString
\end_layout

\begin_layout Plain Layout

      case DoubleStatement(value)=>value.toString
\end_layout

\begin_layout Plain Layout

      case TrueStatement()=>"true"
\end_layout

\begin_layout Plain Layout

      case FalseStatement()=>"false"
\end_layout

\begin_layout Plain Layout

      case IdentifierStatement(value)=>value
\end_layout

\begin_layout Plain Layout

      case call:aFunctionCallStatement => functioncalltranslator(call: aFunction
CallStatement, callingthread:String)
\end_layout

\begin_layout Plain Layout

      case NoArgs()=>""
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def functioncalltranslator(call:aFunctionCallStatement, callingthread:String):
String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    //println("in functioncalltranslator.
 call is "+call)
\end_layout

\begin_layout Plain Layout

    //if(call.functionidentifier=="plus"){println("found")}
\end_layout

\begin_layout Plain Layout

    //println("
\backslash
n
\backslash
n"+call)
\end_layout

\begin_layout Plain Layout

    call match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("actionPrint",_, Left(StringStatement(value)),
_) => "print" + callingthread + ".push_back(" + value + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("actionPrint",_, Left(IdentifierStatement(valu
e)),_) => "print" + callingthread + ".push_back(std::to_string(" + value
 + "))"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("actionPrint",_, Left(x:aFunctionCallStatement
),_) => "print" + callingthread + ".push_back(" + functioncalltranslator(x,callin
gthread) + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(x:aFunctionCallStatement),_
) => "std::to_string(" + functioncalltranslator(x,callingthread) + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(IdentifierStatement(value))
,_) => "std::to_string(" + value + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(IntegerStatement(value)),_)
 => "std::to_string(" + value.toString + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(DoubleStatement(value)),_)
 => "std::to_string(" + value.toString + ")"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(TrueStatement()),_)
 => "true"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("toString",_, Left(FalseStatement()),_)
 => "false"
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IntegerStatement(left)), aNamedCallarg(IdT("right"),
 IdentifierStatement(right))))), _) => left.toString +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IdentifierStatement(left)), aNamedCallarg(IdT("right"),
 IntegerStatement(right))))),_) => left.toString +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), StringStatement(left)), aNamedCallarg(IdT("right"), Identifie
rStatement(right))))), _) => left.toString +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IdentifierStatement(left)), aNamedCallarg(IdT("right"),String
Statement(right))))),_) => left.toString+" == "+right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IdentifierStatement(left)), aNamedCallarg(IdT("right"),
 IdentifierStatement(right))))),_) => left.toString+" == "+right.toString
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IntegerStatement(left)), aNamedCallarg(IdT("right"),x:
 aFunctionCallStatement)))),_) => left.toString+" == "+functioncalltranslator(x,
 callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), x: aFunctionCallStatement), aNamedCallarg(IdT("right"),
 IntegerStatement(right))))), _) => functioncalltranslator(x, callingthread)
 +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), StringStatement(left)),  aNamedCallarg(IdT("right"),
 x:aFunctionCallStatement)))), _) => left.toString+" == "+functioncalltranslator(
x, callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), x:aFunctionCallStatement), aNamedCallarg(IdT("right"),
 StringStatement(right))))), _) => functioncalltranslator(x, callingthread)
 +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), x:aFunctionCallStatement), aNamedCallarg(IdT("right"),
 IdentifierStatement(right))))), _) => functioncalltranslator(x, callingthread)
 +" == "+ right.toString
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), IdentifierStatement(left)), aNamedCallarg(IdT("right"),
 x:aFunctionCallStatement)))),_) => left.toString+" == "+functioncalltranslator(x
, callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("equal", _, Right(aNamedCallargs(List(aNamedCa
llarg(IdT("left"), x:aFunctionCallStatement), aNamedCallarg(IdT("right"),
 y:aFunctionCallStatement)))),_) => functioncalltranslator(x, callingthread)
 +" == "+ functioncalltranslator(y, callingthread)
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("lessThan", _, Right(aNamedCallargs(List(aName
dCallarg(IdT("left"), IntegerStatement(left)), aNamedCallarg(IdT("right"),
 IntegerStatement(right))))),_) => left.toString +" < "+right.toString
\end_layout

\begin_layout Plain Layout

      //TODO: Make better solution for commutative functions
\end_layout

\begin_layout Plain Layout

      //TODO: add more types that the comparison functions can accept
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("actionMutate", _,  Right(aNamedCallargs(List(
aNamedCallarg(IdT("newValue"), IdentifierStatement(newval)), aNamedCallarg(IdT("
variable"), IdentifierStatement(vari))))),_) => vari + " = " + newval
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("actionMutate", _,  Right(aNamedCallargs(List(
aNamedCallarg(IdT("newValue"), x:aFunctionCallStatement), aNamedCallarg(IdT("var
iable"), IdentifierStatement(vari))))), _) =>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        "write" + vari.capitalize + " = " + functioncalltranslator(x, callingthre
ad)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("plus",_,_,_) => basicmathcalltranslator(call,
 callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("minus",_,_,_) => basicmathcalltranslator(call
, callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("multiply",_,_,_) => basicmathcalltranslator(c
all, callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("divide",_,_,_) => basicmathcalltranslator(cal
l, callingthread)
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement("if",_, Right(aNamedCallargs(List(aNamedCallar
g(IdT("condition"), condstat), aNamedCallarg(IdT("else"), elsestat), aNamedCalla
rg(IdT("then"), thenstat)))), _) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        def translator(in:aStatement):String=
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          in match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case TrueStatement()=>"true"
\end_layout

\begin_layout Plain Layout

            case FalseStatement()=>"false"
\end_layout

\begin_layout Plain Layout

            case StringStatement(value)=>value
\end_layout

\begin_layout Plain Layout

            case IntegerStatement(value)=>value.toString
\end_layout

\begin_layout Plain Layout

            case DoubleStatement(value)=>value.toString
\end_layout

\begin_layout Plain Layout

            case IdentifierStatement(value)=>value //Correct behaviour?
 .....
\end_layout

\begin_layout Plain Layout

            case z:aFunctionCallStatement=>functioncalltranslator(z, callingthre
ad)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        condstat match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case TrueStatement()=>translator(thenstat)
\end_layout

\begin_layout Plain Layout

          case FalseStatement()=>translator(elsestat)
\end_layout

\begin_layout Plain Layout

          case _=> 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            translator(condstat)+" ? "+translator(thenstat)+" : "+translator(els
estat)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement(funcid,cppfuncid,args,_) =>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val argstr = args match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case Left(callarg)=>callargTranslator(callarg, callingthread)
\end_layout

\begin_layout Plain Layout

            case Right(aNamedCallargs(args)) =>
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              val first = callargTranslator(args.head.argument, callingthread)
\end_layout

\begin_layout Plain Layout

              val subsequent = args.foldLeft("")((x,y)=>x+", "+callargTranslator(
y.argument, callingthread))
\end_layout

\begin_layout Plain Layout

              first+subsequent
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        cppfuncid+"("+argstr+")"
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      case _=> "not implemented"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def basicmathcalltranslator(call:aFunctionCallStatement, callingthread:String)
:String=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val operator = if(call.functionidentifier=="plus"){" + "}else if(call.function
identifier=="minus"){" - "}else if(call.functionidentifier=="multiply"){"
 * "}else if(call.functionidentifier=="minus"){" / "}
\end_layout

\begin_layout Plain Layout

    call match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case aFunctionCallStatement(_,_, Right(aNamedCallargs(callargs)),_)
 =>
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val argstr = callargs.map(arg=>
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            arg match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case aNamedCallarg(_, IdentifierStatement(value)) => value
\end_layout

\begin_layout Plain Layout

              case aNamedCallarg(_, IntegerStatement(value)) => value.toString
\end_layout

\begin_layout Plain Layout

              case aNamedCallarg(_, DoubleStatement(value)) => value.toString
\end_layout

\begin_layout Plain Layout

              case aNamedCallarg(_, f:aFunctionCallStatement) => functioncalltra
nslator(f, callingthread)
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        ):List[String]
\end_layout

\begin_layout Plain Layout

        "(" + argstr(0) + operator + argstr(1) + ")"
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def gettopthreadstatements(ast:List[Definition]): List[FunctionCallStatement]
 =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    ast.find(x => (x.leftside.description match {case ProgramT() => true; case
 _=> false})) match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None => println("Error in getthreads.
 Should be caught by checker."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

      case Some(res) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        res.rightside.expressions.flatMap(x => x match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case x:FunctionCallStatement => if (x.functionidentifier.startsWith("thr
ead")) {Some(x)} else {None}
\end_layout

\begin_layout Plain Layout

          case _ => None
\end_layout

\begin_layout Plain Layout

        })
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getprintlistdeclarations(topthreads: List[FunctionCallStatement]):
 String=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val topthreadnames = topthreads.map(x=>x.functionidentifier)
\end_layout

\begin_layout Plain Layout

    var out = ""
\end_layout

\begin_layout Plain Layout

    for(i<-topthreadnames)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      out += "
\backslash
nstatic std::list<std::string> print"+i+";"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    out
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getStaticThreadArgs(atree:List[aExpression]):String =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    atree.flatMap(exp=>exp match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case aDefinition(aDefLhs(ThreadT(), _, _, _, Some(aArguments(args)),
 _), _) => Some(args.flatMap(arg =>
\end_layout

\begin_layout Plain Layout

            if (arg.typestr.value == "Inclusion" || arg.id.value.startsWith("synchron
ized"))
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              None
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              Some("static "+typetranslator(arg.typestr)+" "+arg.cppid.value+";
\backslash
n")
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          ).fold("")((l,r)=>l+r)
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

        case _=> None
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    ).fold("
\backslash
n")((l,r)=>l+r)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getmain(topthreads:List[FunctionCallStatement], atree:List[aExpression]):S
tring =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val threaddefls:List[aDefLhs] = atree.flatMap(exp=>exp match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case aDefinition(a @ aDefLhs(ThreadT(),_,_,_,_,_),_) => Some(a)
\end_layout

\begin_layout Plain Layout

        case _=>None
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    val threadargsSet:String = topthreads.map(topthreadcall => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        val threaddefl = threaddefls.find(threaddefl => threaddefl.id.value
 == topthreadcall.functionidentifier) match {case Some(x)=>x; case None=>println(
"error in getmain");scala.sys.exit()}
\end_layout

\begin_layout Plain Layout

        topthreadcall.args match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Left(callarg) => 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            threaddefl.args match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case None=>List("")
\end_layout

\begin_layout Plain Layout

              case Some(aArguments(List(defarg)))=>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                if (defarg.typestr.value == "Inclusion" || defarg.id.value.startsWith
("synchronized"))
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  List("")
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                else
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  val modcallarg:aCallarg = callarg match
\end_layout

\begin_layout Plain Layout

                  {
\end_layout

\begin_layout Plain Layout

                    case a:aCallarg => a
\end_layout

\begin_layout Plain Layout

                    case _=>println("error in getmain2(should be forbidden)");sc
ala.sys.exit() //function calls in assignment in program statement doesn't
 make much sense and should be forbidden
\end_layout

\begin_layout Plain Layout

                  }
\end_layout

\begin_layout Plain Layout

                  List(defarg.cppid.value+" = "+callargTranslator(modcallarg:aCall
arg, "shouldn't be here")+";")
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              case _=>println("error in getmain3");scala.sys.exit()
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          case Right(NamedCallargs(namedarglist)) =>
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            val defarglist = threaddefl.args match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case None => println("error in getmain4");scala.sys.exit()
\end_layout

\begin_layout Plain Layout

              case Some(aArguments(defarglist))=>defarglist
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            namedarglist.foldLeft(List():List[String])((list, namedarg)=>
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val modcallarg:aCallarg = namedarg.argument match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case a:aCallarg => a
\end_layout

\begin_layout Plain Layout

                  case _=>println("error in getmain5(should be forbidden)");scal
a.sys.exit() //function calls in assignment in program statement doesn't make
 much sense and should be forbidden
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                val defarg = defarglist.find(defarg => defarg.id.value==namedarg.id.v
alue) match {case Some(x)=>x; case None=>println("error in getmain6");scala.sys.ex
it()}
\end_layout

\begin_layout Plain Layout

                if (defarg.typestr.value == "Inclusion" || defarg.id.value.startsWith
("synchronized"))
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  list
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                else
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  list :+ (defarg.cppid.value+" = "+callargTranslator(modcallarg:a
Callarg, "shouldn't be here")+";")
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    ).fold(List(): List[String]) ((llist,rlist) => llist ++ rlist).foldLeft("
\backslash
n") ((str,sublist) => if(sublist!="") {str+"
\backslash
n"+sublist} else{str})
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    var threadsStart = ""
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    for(i<-topthreads)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      threadsStart = threadsStart + "
\backslash
n" + "std::thread t" + i.functionidentifier + " (" + i.functionidentifier
 + ");"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    "int main()
\backslash
n{
\backslash
nrendezvousCounter.store(0);" + threadargsSet + threadsStart + "
\backslash
nwhile(true)
\backslash
n {
\backslash
n std::this_thread::sleep_for(std::chrono::seconds(1)); 
\backslash
n}" + "
\backslash
n}"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getsynchronizerfunction(synchvariables:List[Definition], topthreads:List[F
unctionCallStatement]):String=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    var synchvariablestrings = ""
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    for(i<-synchvariables)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val name = i.leftside.id.value
\end_layout

\begin_layout Plain Layout

      synchvariablestrings += name + " = write" + name.capitalize + ";
\backslash
n"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    var printstatements = ""
\end_layout

\begin_layout Plain Layout

    for(i<-topthreads)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val currentprintqueuename = "print" + i.functionidentifier
\end_layout

\begin_layout Plain Layout

      printstatements += "while(!"+currentprintqueuename+".empty()) {
\backslash
nstd::cout << "+currentprintqueuename + ".front(); 
\backslash
n"+currentprintqueuename+".pop_front(); 
\backslash
n}
\backslash
n"
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ("""static void waitForRendezvous(std::string name)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  std::unique_lock<std::mutex> lk(rendezvousSyncMutex);
\end_layout

\begin_layout Plain Layout

  ++rendezvousCounter;
\end_layout

\begin_layout Plain Layout

  if(rendezvousCounter.load() < NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cv.wait(lk);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if (rendezvousCounter.load() == NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    """
\end_layout

\begin_layout Plain Layout

     + printstatements + synchvariablestrings + """
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

      cv.notify_all();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    std::cout << "error in wait for " << name << ".
 Rendezvouscounter out of bounds.
 RedezvousCounter = " << rendezvousCounter.load() << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    exit(0);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}""")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getGlobalSynchVariableDeclarations(synchvariables: List[Definition]):
 String=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    var synchdeclares = ""
\end_layout

\begin_layout Plain Layout

    for(i<-synchvariables)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      val fumurttype = i.leftside.returntype.value
\end_layout

\begin_layout Plain Layout

      val initialValue = i.rightside.expressions(0) match
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        case FunctionCallStatement(functionidentifier, args) => args match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Right(namedcallargs) => namedcallargs.value(0).argument match
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            case IntegerStatement(value) => value
\end_layout

\begin_layout Plain Layout

            //case DoubleStatement(value) => value
\end_layout

\begin_layout Plain Layout

            case _=> println("Error in getGlobalSynchVariableDeclarations.
 Should be caught by checker."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          case _=> println("Error in getGlobalSynchVariableDeclarations.
 Should be caught by checker."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        case _=> println(i.rightside.expressions(0).toString); println("Error
 in getGlobalSynchVariableDeclarations.
 Should be caught by checker."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (fumurttype == "Integer")
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        synchdeclares += "
\backslash
nstatic int " + i.leftside.id.value + " = " + initialValue + ";"
\end_layout

\begin_layout Plain Layout

        synchdeclares += "
\backslash
nstatic int write" + i.leftside.id.value.capitalize + " = " + initialValue +
 ";"
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    synchdeclares
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def getsynchronizedvariables(ast: List[Definition]): List[Definition]
 =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    ast.find(x => (x.leftside.description match {case ProgramT() => true; case
 _=> false})) match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case None => println("Error in getthreads.
 Should be caught by checker."); scala.sys.exit()
\end_layout

\begin_layout Plain Layout

      case Some(res) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        res.rightside.expressions.flatMap(x => x match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case x:Definition => x.leftside.description match {case SynchronizedVari
ableT() => Some(x); case _=> None}
\end_layout

\begin_layout Plain Layout

          case _=> None
\end_layout

\begin_layout Plain Layout

        })
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Error.scala
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package fumurtCompiler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.util.parsing.input.Position
\end_layout

\begin_layout Plain Layout

//import scala.util.parsing.input.NoPosition
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case object Global extends Position
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def column:Int = 0
\end_layout

\begin_layout Plain Layout

  def line:Int = 0
\end_layout

\begin_layout Plain Layout

  protected def lineContents:String = "global position"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

case class Source(val line:Int, val column:Int, val lineContents:String)
 extends Position
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class FumurtError(val position:Position, val message:String)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  override def toString:String=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    position.toString + ": " + message + "
\backslash
n" + position.longString + "
\backslash
n"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
