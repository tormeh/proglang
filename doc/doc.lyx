#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{url}

\lstset{
numbers=left,
breaklines=true,
frame=single,
basicstyle=\footnotesize\ttfamily,
showspaces=false,
showstringspaces=false,
showtabs=false}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Fumurt: A programming language with deterministic threading
\end_layout

\begin_layout Author
Tormod Gjeitnes Hellen
\end_layout

\begin_layout Standard
http://www.cs.ucl.ac.uk/teaching_learning/msc_cgvi/projects/project_report_structure
/
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
First and foremost, you should write about the most interesting or important
 parts of your project.
 Devote most space and time to this.
 For example:
\end_layout

\begin_layout Standard

\emph on
What design choices did you have along the way, and why did you make the
 choices you made? What was the most difficult part of the project? Why
 was it difficult? How did you overcome the difficulties? Did you discover
 anything novel? What did you learn?
\end_layout

\begin_layout Standard

\emph on
Set the scene and problem statement/specification.
 Provide the motivation for reading this report.
 Introduce the structure of report (what you will cover in which chapters).
 
\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard

\emph on
You should provide enough background to the reader for them to understand
 what the project is all about.
 For example:
\end_layout

\begin_layout Standard

\emph on
What the reader needs to know in order to understand the rest of the report.
 Examiners like to know that you have done some background research and
 that you know what else has been done in the field (where relevant).
 Try to include some references.
 Related work (if you know of any) What problem are you solving? Why are
 you solving it? How does this relate to other work in this area? What work
 does it build on?
\end_layout

\begin_layout Standard

\emph on
For 'research-style' projects - ones in which a computational technique
 (for example neural networks, genetic algorithms, finite element analysis,
 ray tracing) is used to explore or extend the properties of a mathematical
 model, or to make predictions of some kind - it may be a good idea to split
 this chapter into two shorter ones, one covering the computational technique
 itself and one the area of application.
\end_layout

\begin_layout Standard

\emph on
The Examiners are just as interested in the process you went through in
 performing your project work as the results you finally produced.
 So, make sure your reports concentrate on why you made the particular choices
 and decisions that you did.
 We are looking for reasoned arguments and for critical assessment.
 This is especially so where design, implementation and engineering decisions
 have been made not just on technical merit but under pressure of non-functional
 requirements and external influences.
\end_layout

\begin_layout Section
Prior Knowledge
\end_layout

\begin_layout Standard
The inner workings of the compiler are heavily influenced by a course the
 author took on compilers at the Technische UniversitÃ¤t Berlin under Peter
 Pepper and Judith Rohloff.
 While no code is reused, the structure of the compiler is very similar.
\begin_inset CommandInset label
LatexCommand label
name "sec:TUB course"

\end_inset


\end_layout

\begin_layout Section
Concurrency Paradigms
\end_layout

\begin_layout Standard
It is commonly understood that writing software is hard.
 The development of programming languages is a response to this problem.
 The common pattern is that flexible features that are easily used to write
 code that is hard to reason about are replaced by, often several, less
 flexible features.
 After all, the less flexible a feature is, the more predictable its use
 is.
 Three examples: 
\end_layout

\begin_layout Itemize
goto replaced by sequence, selection and iteration 
\begin_inset CommandInset citation
LatexCommand cite
key "bohm1966flowStructuredProgramming"

\end_inset


\end_layout

\begin_layout Itemize
pointers replaced by indexes and references 
\end_layout

\begin_layout Itemize
mutable variables replaced by immutable values 
\end_layout

\begin_layout Standard
Interestingly, one can observe that as each feature becomes easier to reason
 about, the total number of features increase.
 For example, to eliminate mutation, one needs to also eliminate iteration.
 One way to do this is by using recursion, which is a full replacement for
 iteration.
 But recursion, while allowing immutability, is often harder for humans
 to understand [citation needed].
 To ameliorate this problem, a variety of machanisms have been implemented,
 for example map and fold, which performs common functions previously performed
 utilizing iteration.
 In this manner, the number of features often increase in the interest of
 analysability.
 Is this generally true? And if so, at what point does the drawbacks of
 increasing feature number outweigh the benefit of increased analyzability
 and predictability? Answering these questions is outside the scope of this
 report.
 Much progress has been made in making programs easier to understand and
 analyze in this fashion, yet there is always room for improvement.
 In later years, one feature in particular has risen to notability: Concurrency.
 In the past, concurrency has not been an issue for most programmers but
 as multi-processor (or multi-core) systems have gone mainstream, so has
 multithreaded programming
\begin_inset CommandInset citation
LatexCommand cite
key "sutter2005freeLunch"

\end_inset

.
 The problems inherent to concurrency can roughly be divided into two categories
: Communication and scheduling; making sure the correct information is shared
 between threads in a correct way and making sure tasks are done at correct
 times, respectively[citation needed].
 One possibility is to let the programmer deal with these problems in an
 application-specific way.
 This is notoriously error-prone, however.
 Several abstractions have been deviced for dealing with the two concurrency
 problems in a systematic manner, to the author's knowledge:
\end_layout

\begin_layout Itemize
Actors 
\begin_inset CommandInset citation
LatexCommand cite
key "hewitt1973universalActors"

\end_inset


\end_layout

\begin_layout Itemize
CSP 
\begin_inset CommandInset citation
LatexCommand cite
key "hoare1978communicatingCSP"

\end_inset


\end_layout

\begin_layout Itemize
Transactional memory[citation needed]
\end_layout

\begin_layout Itemize
Synchronous programming
\begin_inset CommandInset citation
LatexCommand cite
key "berry1992esterel"

\end_inset


\end_layout

\begin_layout Standard
In the end we decided on using the synchronous programming paradigm.
 There are tradeoffs associated with chosing synchronous programming, but
 they were determined to be preferable to the alternatives.
 The main problems with synchronous programming are 
\end_layout

\begin_layout Enumerate
Difficulty in scaling beyond one physical machine.
 The cost of global synchronization grows with latency.
\end_layout

\begin_layout Enumerate
Performance loss due to processing resources idling as the synchronicity
 abstraction requires all operations to use the same amount of time.
\end_layout

\begin_layout Standard
Synchronous programming therefore has substantial problems, yet for single-machi
ne systems it presents a way to achieve multi-threaded performance and achitectu
re but with single-threaded predictability and therefore debugability.
 While the other abstractions place the responsibility for correct concurrent
 behaviour on the programmer, synchronous programming takes care of that
 and replaces it with the responsibility for performance, as the program
 performs best if all threads has an equal amount of work.
 Let us discuss the problems of the other abstractions
\end_layout

\begin_layout Itemize
Actors assume infinite message queues, with the failure mode being a loss
 of information.
 In a producer-consumer relationship, producer actors can overwhelm consumer
 actors.
 Actors are designed to mimic distributed systems and create a unified abstracti
on over these.
 Distributed systems have to correctly handle hardware failures, so loss
 of information is an acceptible failure mode for actors.
 However, this makes actors unsuitable for real-time systems as recovering
 from data loss and unpredictable memory usage are unacceptable tradeoffs.
 Ordering of IO is also unpredictable.
\end_layout

\begin_layout Itemize
CSP systems use synchronous communication and therefore avoid the message
 queue problem of actors entirely.
 In exchange, they are open to deadlock, and the ordering of IO is unpredictable.
 CSP therefore requires brute force search for deadlocks, and debugging
 is harder than for single-threaded systems.
 Despite this, it is regarded as a solid choice for real time systems.
\end_layout

\begin_layout Itemize
Transactional memory, though it makes it look as if thread communication
 is easy, has its own problems.
 The unpredictability of the sequence of writing is a problem, as well as
 the unpredictable time it takes.
\end_layout

\begin_layout Section
Compilers
\end_layout

\begin_layout Standard
A compiler is a program (one may regard it as a function) that accepts a
 program in a source format and outputs a corresponding program in a target
 format.
 The source and target format may differ in terms of encoding, language
 and any other way one may imagine.
 
\end_layout

\begin_layout Standard
This figure, reconstructed from 
\begin_inset CommandInset citation
LatexCommand cite
key "cooper2011engineering"

\end_inset

, illustrates the structure of a typical compiler:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename textbookcompiler.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Consider the steps:
\end_layout

\begin_layout Enumerate
The front end accepts source text and transforms it into an intermediate
 representation that is easier to work with.
 It is generally independent of the target format.
\end_layout

\begin_layout Enumerate
The optimizer improves the code as encoded in the intermediate representation.
 The improvement is usually done with regards to performance, code size
 or memory usage .
\end_layout

\begin_layout Enumerate
The back end accepts the intermediate representation and outputs the the
 program encoded therein translated to the target format.
 It can be independent of the source format, depending on how general and
 flexible the intermediate representation is.
\end_layout

\begin_layout Standard
Since the compiler described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Implementation"

\end_inset

 does not deal with optimization and conversion to binary itself, but rather
 outsources this to a C++ compiler, all of the difficult material on instruction
 selection, scheduling and register allocation is of no relevance.
 The parts of relevance to this report is the front end and a relatively
 simple back end.
\end_layout

\begin_layout Standard
Consider the parts of the front end:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename textbookfrontend.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Itemize
Scanner: Transforms source text into a list of tokens (simple objects),
 possibly ignoring some symbols (such as spaces, comments, indentation etc.)
\end_layout

\begin_layout Itemize
Parser: Transforms a list of tokens into an abstract syntax tree.
 In the process, it checks whether the syntax of the program is correct.
\end_layout

\begin_layout Itemize
Context Sensitive Analysis: Checks the correctness of program semantics.
 Most interpreted languages skip this step and deal with semantic errors
 at runtime.
 The correct time to do semantic analysis is not a settled matter, but in
 a static compiler such as the one in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Implementation"

\end_inset

 it is done here.
 In the case where a language has type inference, this step may emit a modified
 intermediate representation.
\end_layout

\begin_layout Standard
The back end is composed of successive passes, of which every step transform
 the input intermediate representation into an output that is closer to
 the target format.
 The number of passes required vary greatly and depend on the differences
 between the source and ouput formats.
 In the trivial case, where the input and output format is identical (for
 example C to C) the number of necessary passes would be zero.
\end_layout

\begin_layout Subsection
Grammars
\end_layout

\begin_layout Standard
A grammar is a formal and complete description of the syntax of a language.
 It is mostly used for programming languages.
 It consists of the confusingly named 
\begin_inset Quotes eld
\end_inset

production rules
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Example:
\end_layout

\begin_layout Standard
Consider a notion of a lower case letter can be described like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i"
 | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u"
 | "v" | "w" | "x" | "y" | "z" ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 signify the two sides of the production rule, 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 signify alternation (intuitively 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

), quotes signify a string and 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 signify the end of the rule.
 Let us expand the example by describing a lower case word:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case word = lower case letter, {lower case letter};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the correctness of the word as it pertains to English is ignored.
 The comma signify a sequence, and the curly brackets signify that their
 contents can be repeated one or more time.
 A lower case word, as it has been defined here, is simply one lower case
 letter, followed by zero or more lower case letters.
 Next we can do the same for sentences, again ignoring rules for English:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case sentence = lower case word, {(", ", lower case word) | (" ",
 lower case word)}, ".
 ";
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Parentheses allows grouping of sequences.
 Here, it allows us to alternate between sequences of symbols rather than
 just single symbols.
 Finally we say that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lower case text = lower case sentence, {lower case sentence}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we have a very simple grammar, which allows us to partition up a text
 into sentences and words.
\end_layout

\begin_layout Subsubsection
Abstract Syntax Trees
\end_layout

\begin_layout Standard
Now suppose we wanted to systematize a string of characters according to
 the grammar above.
 A data structure corresponding to the grammar would be appropriate.
 Consider the following figure:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Abstract Syntax Tree.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
This is an abstract syntax tree, often abreviated AST.
 An abstract syntax tree is a tree, in the computer science sense, that
 represents the production of the source string from the grammar.
 In code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Text(val sentences:List[Sentence])
\end_layout

\begin_layout Plain Layout

class Sentence(val words:List[Word])
\end_layout

\begin_layout Plain Layout

class Word(val letters:List[Char])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parser Combinators
\end_layout

\begin_layout Standard
A parser combinator is a higher order function that accepts parsers as input
 and returns a new parser
\begin_inset CommandInset citation
LatexCommand cite
key "Parser combinators"

\end_inset

.
 The overall effect is similar to a domain specific language for constructing
 recursive descent parsers.
 
\end_layout

\begin_layout Standard
A parser is a function that converts one data structure to a more sensible
 data structure.
 Usually, the output data structure is more restricted and systematic than
 the input one.
 
\end_layout

\begin_layout Paragraph
Example:
\end_layout

\begin_layout Standard
Consider a function that accepts the string 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 and returns an object of class equalToken or, if the string it is given
 is not 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, returns an error object.
 Such a function is then a parser.
 Such parsers can be combined to form a larger parser that can work as a
 scanner, that is a parser that converts a list of characters to a list
 of tokens (very simple objects).
 Let the previously discussed function be called the equalParser.
 Let a parser that works exactly the same, save for exchanging 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 be called the minusParser and let it return a minusToken upon success.
 Consider combining the equalParser with the minusParser using an 
\emph on
alternate parser combinator
\emph default
 (the 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 operator in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

).
 The resulting function would then first try the equalParser, and if that
 returned an error object, it would try the minusParser, returning an error
 object if both of these parsers fail.
 This new parser would not need to return a minusToken or equalToken, but
 can process the results from equalParser and minusParser into something
 new.
 In this example, we have formed two parsers and combined them into a new
 parser using a parser combinator.
 This new parser can be part of a scanner.
 Indeed, the Fumurt scanner is formed like this (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "scanner combined"

\end_inset

).
\end_layout

\begin_layout Paragraph
Conflicting terminology:
\end_layout

\begin_layout Standard
Unfortunately there is a case of conflicting terminology concerning the
 term 
\begin_inset Quotes eld
\end_inset

parser
\begin_inset Quotes erd
\end_inset

.
 Here we refer to parser in two senses: 
\end_layout

\begin_layout Enumerate
The parser as defined above.
 A function that converts one data structure to a more sensible data structure.
\end_layout

\begin_layout Enumerate
A parser as a compilation step that converts a list of tokens into an abstract
 syntax tree
\end_layout

\begin_layout Subsection
The Scala Standard Parser Combinator Library
\begin_inset CommandInset label
LatexCommand label
name "sub:The-Scala-Parser"

\end_inset


\end_layout

\begin_layout Standard
All the information here is also available at 
\begin_inset CommandInset citation
LatexCommand cite
key "ScalaParserCombinatorDoc"

\end_inset

.
\end_layout

\begin_layout Standard
The Scala Standard Parser Combinator Library introduces many parser combinators,
 most of whom are formulated as operators.
\end_layout

\begin_layout Standard
Let's discuss these operators:
\end_layout

\begin_layout Itemize
~ is used to combine parsers sequentially
\end_layout

\begin_layout Itemize
~> is used to combine parsers sequentially but ignore the result of the
 left parser
\end_layout

\begin_layout Itemize
~! is used to combine parsers sequentially but dissallow backtracking.
\end_layout

\begin_layout Itemize
* applies the parser to the left as many times as it is succesful, moving
 on at failure
\end_layout

\begin_layout Itemize
+ applies the parser to the left as many times as it is succesful, moving
 on at failure.
 Must be applied at least once
\end_layout

\begin_layout Itemize
? applies the parser to the left zero or one time
\end_layout

\begin_layout Itemize
| used to combine parsers in a manner similar to logical 
\begin_inset Quotes eld
\end_inset

||
\begin_inset Quotes erd
\end_inset

.
 Tries to apply the left parser first.
 If the left parser fails, it will backtrack and attempt the right parser.
 If none work then an error is returned.
\end_layout

\begin_layout Itemize
^^ is used to apply a function to the succesful result of the parser.
\end_layout

\begin_layout Itemize
^^^ is used to apply a function to the result of the parser, successful
 or not.
\end_layout

\begin_layout Section
Knowledge Dividends
\end_layout

\begin_layout Standard
Regex, C++11, advanced Scala/functional programming, parser combinators,
\end_layout

\begin_layout Chapter
Specification
\end_layout

\begin_layout Standard

\emph on
Elaboration of the problem
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Initially, the goal of this thesis was to create a fundamentally new approach
 to managing concurrency, wherein the programmer would manually schedule
 the execution of tasks at compile time.
 Tasks would be allowed to write to special variables which would be used
 in lieu of final ones if the task could not finish in the alloted time
 frame.
 This effort was abandoned because of the burden it would impose on the
 programmer, the perceived difficulty of implementation and the unsatisfactory
 failure modes.
 Instead, it was decided that an approach belonging to the tradition of
 synchronous programming would be preferable.
 Given the importance of a familiar superficialities for language adoption
\begin_inset CommandInset citation
LatexCommand cite
key "meyerovich2013empiricalProgrammingLanguageAdoption"

\end_inset

, it was decided that the language should have a familiar C/Algol-style
 syntax, rather than invent or adopt something less common.
\end_layout

\begin_layout Section
Language Design Goals
\end_layout

\begin_layout Standard
It is the goals of Fumurt to aid in producing correct programs suitable
 for real-time applications in general, and such multithreaded programs
 in particular.
\end_layout

\begin_layout Section
Runtime Execution Model
\begin_inset CommandInset label
LatexCommand label
name "sec:Runtime-Execution-Model"

\end_inset


\end_layout

\begin_layout Standard
The goal of the programming language is to make a multithreaded program
 behave as predictably as were it singlethreaded and, more generally, to
 help create reliable applications A corollary of this is that only changes
 of state that are visible to a single thread can happen concurrently.
 All IO and inter-thread communication are required happen in a statically
 determined sequence.
 One way to do this is to have the program have two alternating phases:
\end_layout

\begin_layout Itemize
Computational phase: In which computations local to a thread are performed.
\end_layout

\begin_layout Itemize
Communicative phase: In which IO is effected and shared variables are updated,
 all in a single-threaded manner.
\end_layout

\begin_layout Standard
In the computational phase, the order in which computations are performed
 on the processor is irrelevant as nothing is shared between the thread
 and the rest of the world.
 Since the threads have no effect on each other or the outside world in
 this phase, the only difference between concurrent execution and sequential
 execution is speed.
 In the communicative phase, however, execution has to be single threaded.
 Using this scheme, the application appears to be single threaded both to
 itself and to the rest of the world, all the while enabling separation
 of concerns and better utilization of multi-core systems.
 The following figure illustrates the principle:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename architecture.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
In terms of the actual execution a more detailed figure is offered:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailed.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Observe that in the computational stage we can make available parallel list
 transformations like map and fold or even futures, without affecting the
 outward behaviour of the system, except for performance:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailedwithmap.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Futures and parallel list comprehensions are together applicable to all
 problems which can be divided into subproblems that can be done in parallel
 without communication.
 Futures are a bit of extra work to deal with, but the map-and-fold pattern,
 sometimes called mapReduce
\begin_inset CommandInset citation
LatexCommand cite
key "mapReduce"

\end_inset

, is easy to use and widely applicative to many problems.
\begin_inset CommandInset citation
LatexCommand cite
key "borthakur2011apache"

\end_inset

 Indeed, map-and-fold is intensely used in the Fumurt compiler.
 Supporting map-and-fold and futures reduces the performance problems of
 all threads waiting on each other significantly as long as it can be applied
 to the most time-consuming task.
\end_layout

\begin_layout Section
Inter-thread communication
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
Syntax is by definition somewhat arbitrary, but as Brainfuck demonstrates,
 some syntaxes are better than others.
 We settled on the following goals:
\end_layout

\begin_layout Itemize
Look modern and familiar.
 This is supposed to make it easier to learn, as well as more appealing
 to someone evaluating whether to learn it.
 
\end_layout

\begin_layout Itemize
Be simple.
 For ease of implementation.
\end_layout

\begin_layout Itemize
Be predictable, and aid the programmer in the understanding of the program.
\end_layout

\begin_layout Subsection
Modern and Familiar
\end_layout

\begin_layout Standard
Fumurt adopts several conventions from contemporary languages:
\end_layout

\begin_layout Itemize
Separating expressions with line endings instead of special characters (for
 example semicolon).
\end_layout

\begin_layout Itemize
Employ 
\begin_inset Quotes eld
\end_inset

instanceOfType:Type
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

Type instanceOfType
\begin_inset Quotes erd
\end_inset

 when declaring the type of something.
\end_layout

\begin_layout Itemize
We use 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 to perform definitions and mark the boundaries of blocks with brackets
\end_layout

\begin_layout Standard
This results in syntax with a distinctly modern look:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {x}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One might wish for brackets to be optional in such one-liners, though, 
\end_layout

\begin_layout Subsection
Predictable and Helpful
\end_layout

\begin_layout Standard
We observe that although modern languages and their type systems have made
 the use of functions safe, the syntax of modern languages insufficiently
 aid the programmer in understanding what a function does, as it is called:
\end_layout

\begin_layout Itemize
Functions that perform IO or mutate shared variables are called actions
 and their names must begin with 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

, like so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionPrintFoo:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("  FOO   ")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Similarly thread names begin with 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 and synchronized variable names begin with 
\begin_inset Quotes eld
\end_inset

synchronized
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Function arguments, if there are more than one, are distinguished not by
 relative position, but by name (as is optionally available in Python).
 Here we see a call to the if function and some calls to the toString function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(condition=true, then=toString(1), else=toString(0))
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Standard
Among the goals of this programming language is to help the programmer understan
d the program.
 One way we do this is to make dependencies between functions explicit via
 
\emph on
inclusions
\emph default
.
 It is common among languages for changes in one function to affect the
 correctness of seemingly unrelated parts of the program.
 In the following example, changing the definition of function c affects
 the output of function a:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionA:Nothing = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  b()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionB:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  c()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionC:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("string")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While the above example is a bit contrived, it illustrates the problem.
 Using inclusions, the dependencies become explicit:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

action actionA(b:Inclusion, c:Inclusion):Nothing = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  b(c=c)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionB(c:Inclusion):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  c()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

action actionC:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("string")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that inclusions are not functions as arguments - the passed function
 and the name of the inclusion must have the same name; it is simply there
 to make dependencies between functions explicit.
\end_layout

\begin_layout Standard
In keeping with our goal of being modern and familiar, we allow definitions
 of functions inside other definitions of functions.
 Recursive function definitions, that is.
 This means that developers can hide functions inside other functions when
 they are not needed outside them.
\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
Operators are functions with two arguments and the function name in between
 the arguments.
 There are multiple problems with them:
\end_layout

\begin_layout Enumerate
Convention suggests that their names should be information-anemically short,
 often one character.
 This is obviously problematic
\end_layout

\begin_layout Enumerate
Their arguments are nameless, which kind of sabotages the point of having
 named arguments for functions a little
\end_layout

\begin_layout Enumerate
How to define operator precedence? For math operators there's convention,
 but otherwise this may be confusing for users of operators
\end_layout

\begin_layout Standard
A prime example of unhelpful operator behaviour is found in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

.
\end_layout

\begin_layout Standard
We haven't found any good solutions to this, but it's hard to argue with
 the convenience of operators.
 We provide some predictability to operators by enforcing the following
 rules:
\end_layout

\begin_layout Enumerate
Either the types of the two arguments has to be the same or one of the types
 have to be a container type of the other.
 For example Int and Int or List[Int] and Int.
\end_layout

\begin_layout Enumerate
There's no operator precedence, it has to be defined on a case-by-case basis
 using parentheses.
 Ambiguous use of operators are not allowed.
\end_layout

\begin_layout Section
Immutability
\end_layout

\begin_layout Standard
Mutable variables are a major source of bugs, and even experienced developers
 create bugs when a variable that would have held the correct information
 previously no longer holds that information.
 At the same time we need mutable values in some ways in order to share
 information across threads.
 So we disallow mutable variables, except the synchronized variables that
 are shared across threads.
 
\end_layout

\begin_layout Subsection
Loops
\end_layout

\begin_layout Standard
Loops are familiar for many people, yet are usually not included in languages
 with only immutable values, because their utility is pretty limited.
 However, they are convenient and they are equivalent to tail-recursion.
 The major advantages of tail recursion over looping is that the assignment
 and dependencies are explicit.
 We decided we could make loops that are as safe as tail recursion while
 being almost as friendly as loops:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

value y:Int = 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

value x:Int = loop(y=y,x=y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if(
\end_layout

\begin_layout Plain Layout

  condition=(y>0), 
\end_layout

\begin_layout Plain Layout

  then=
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

  x = x*y 
\end_layout

\begin_layout Plain Layout

  y = y-1
\end_layout

\begin_layout Plain Layout

  continue
\end_layout

\begin_layout Plain Layout

  }, 
\end_layout

\begin_layout Plain Layout

  else=break)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All variables passed to the loop would then need to be copied.
 In the example above, the y modified inside the loop cannot be the same
 that is defined outside it.
 Such scoping of variables are common in function calls, and a similar mechanism
 can be used for loops.
\end_layout

\begin_layout Standard
An additional benefit of loops is that their use has constant memory consumption
 independent of number of iterations.
 While the same can be achieved using tail recursion with optimizing compilers,
 such compilers are still not the norm.
 Mutual tail recursion optimization is particularly rare.
 Since optimizations are not an immediate goal for the Fumurt compiler,
 loops would offer an important guarantee.
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
Because we try to be familiar we want to provide types along with their
 popular object oriented nomenclature.
 So we have classes, just that they are immutable.
 They are defined by their constructors:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class IntAndString(int:Integer, string:String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

value x = IntAndString(int=3, string="something")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We do not have inheritance, because while inheritance means you get code
 reuse, it also obscures the class that inherits.
 When one class inherits from a hierarchy, one needs to understand not only
 what's written about that class but also the entire hierarchy in order
 to understand the end result.
\end_layout

\begin_layout Standard
In order to aid the programmer in understanding their own and others' code,
 the names of types always lead with a capital letter.
 Conversely, leading with a capital letter for anything else is illegal.
\end_layout

\begin_layout Subsection
Interfaces
\end_layout

\begin_layout Standard
All classes are interfaces, but one can also create interfaces that aren't
 classes using the 
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 keyword.
 When implementing an interface one explicitly have to note what interfaces
 the class is implementing.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

interface IntAndString(int:Integer, string:String)
\end_layout

\begin_layout Plain Layout

//or
\end_layout

\begin_layout Plain Layout

class IntAndString(int:Integer, string:String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class IntAndStringAndBool(int:Integer, string:String, bool:Boolean) implements
 IntAndString
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Standard
Modules are singletons containing only immutable values, actions and functions.
\end_layout

\begin_layout Section
Program Declaration
\end_layout

\begin_layout Chapter
Analysis and Design
\end_layout

\begin_layout Standard

\emph on
If your project involves designing a system, give a good high-level overview
 of your design.
\end_layout

\begin_layout Standard

\emph on
In many projects, the initial design and the final design differ somewhat.
 If the differences are interesting, write about them, and why the changes
 were made.
\end_layout

\begin_layout Standard

\emph on
If your design was not implemented fully, describe which parts you did implement
, and which you didn't.
 If the reason you didn't implement everything is interesting (eg it turned
 out to be difficult for unexpected reasons), write about it.
\end_layout

\begin_layout Section
Choice of Intermediate Target
\end_layout

\begin_layout Standard
For easy debugging and wide selection of binary targets we chose to first
 compile to an intermediate language and then let an external compiler perform
 the final transformation to binary form.
 This is a well-trodden path
\begin_inset CommandInset citation
LatexCommand cite
key "hall1993glasgowHaskellToC"

\end_inset

, and C is often used.
 Though many modern languages would be suitable for this, we had a wishlist
 of features that determined which language to choose:
\end_layout

\begin_layout Enumerate
No garbage collection or other other source of run-to-run variability.
\end_layout

\begin_layout Enumerate
Wide selection of final targets, including embedded.
\end_layout

\begin_layout Enumerate
Low overhead, whether in performance or memory.
 
\end_layout

\begin_layout Enumerate
A solid set of features to make transformation into the language easier.
 
\end_layout

\begin_layout Enumerate
Mature standard that is unlikely to break backwards compatibility.
\end_layout

\begin_layout Standard
C++ seems to satisfy all these criteria, and were therefore selected as
 the intermediate language.
 In particular, C has too few features, which means a compiler would have
 to make more difficult transformations and/or things like linked lists
 would have to be manually implemented.
 Such difficulties seem unnecessary.
\end_layout

\begin_layout Section
Choice of Compiler Implementation Language
\end_layout

\begin_layout Standard
Scala was chosen as the implementation language for the compiler partly
 because it's what the author used in the TU Berlin compiler bau course
 (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TUB course"

\end_inset

) and already had lots of experience in, but it also has some highly attractive
 qualities for making a compiler:
\end_layout

\begin_layout Itemize
A solid type checking which makes the code easier to work with, especially
 when refactoring
\end_layout

\begin_layout Itemize
A wide selection of functional abstractions, which allows compact code and
 eliminates simple but irritating bugs as well as access to imperative construct
s like loops etc.
 when this is more convenient
\end_layout

\begin_layout Itemize
A parser combinator library
\end_layout

\begin_layout Itemize
Fast execution time
\end_layout

\begin_layout Section
Synchronization Mechanisms in The Intermediate Language
\end_layout

\begin_layout Standard
Our execution model formulated in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Runtime-Execution-Model"

\end_inset

 needs be formulated in the compiled C++ code.
\end_layout

\begin_layout Itemize
Each thread gets its own printList (type std::list<std::string>), and actionPrin
ts are translated into printList.push_back.
 The same principle can be used for future output as well.
 When the threads are finished with the computational phase, the last thread
 to finish will print printList.pop_front until the printList is empty.
 The thread started first in the program statement gets its printList emptied
 first, and so on.
\end_layout

\begin_layout Itemize
We use a rendezvous pattern:
\end_layout

\begin_deeper
\begin_layout Enumerate
We define a macro NUMTOPTHREADS, with the number of threads defined in the
 program statement
\end_layout

\begin_layout Enumerate
We define a static std::atomic<int> rendezvousCounter, which holds the number
 of threads that have arrived at the rendezvous point.
\end_layout

\begin_layout Enumerate
We define a static std::mutex rendezvousSyncMutex and a static std::condition_va
riable cv.
\end_layout

\begin_layout Enumerate
For each synchronized variable in the source code, we define one variable
 which holds the global state of this variable and one which holds the local
 state of this variable in the thread that is allowed to write to it.
\end_layout

\begin_layout Enumerate
We define a [[noreturn]] static void threadName() for each thread, holding
 its values.
 All arguments to thread in the source code are converted to static global
 variables.
\end_layout

\begin_layout Enumerate
We define a main function, inside of which:
\end_layout

\begin_deeper
\begin_layout Enumerate
rendezvousCounter is set to 0, std::thread are started with the thread functions
 (defined in previous step) as arguments and finally the main function enters
 a loop executing std::this_thread::sleep_for(std::chrono::seconds(1)).
\end_layout

\end_deeper
\begin_layout Enumerate
We define a static void waitForRendezvous(std::string name) which a thread
 calls when it is ready to wait.
 Inside of which:
\end_layout

\begin_deeper
\begin_layout Enumerate
The thread locks the rendezvousSyncMutex
\end_layout

\begin_layout Enumerate
Increments the rendezvousCounter
\end_layout

\begin_layout Enumerate
If the value in the rendezvousCounter is less than NUMTOPTHREADS, the thread
 waits using cv.wait, at which point rendezvousSyncMutex will be automatically
 unlocked.
 If the rendezvousCounter equals NUMTOPTHREADS, the thread prints all strings
 held in the printLists as described above, sets any global synchronized
 variables to its local values, sets rendezvousCounter to 0 and finally
 notifies all other threads using cv.notify_all before exiting the function.
 rendezvousSyncMutex is unlocked on function exit.
 Consider the salient details:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static void waitForRendezvous(std::string name)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  std::unique_lock<std::mutex> lk(rendezvousSyncMutex);
\end_layout

\begin_layout Plain Layout

  ++rendezvousCounter;
\end_layout

\begin_layout Plain Layout

  if(rendezvousCounter.load() < NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cv.wait(lk);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if (rendezvousCounter.load() == NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    while(!printthreadPrintHello.empty())
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      std::cout << printthreadPrintHello.front();
\end_layout

\begin_layout Plain Layout

      printthreadPrintHello.pop_front();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	/*similarly for other thread print lists*/
\end_layout

\begin_layout Plain Layout

    synchronizedNumber = writeSynchronizedNumber;
\end_layout

\begin_layout Plain Layout

    rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

    cv.notify_all();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  /*abnormal situation diagnostics mechanism here*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
A Need for Annotation
\end_layout

\begin_layout Standard
Technically, the finished code can always be determined directly from the
 AST, but it was discovered that in order to do this in the Fumurt case,
 the same rules would have to be encoded into the code in several different
 places.
 In the current state of implementation, the only rule that required annotation
 was the rule for determining the C++ names of function.
 There are three aspects to the naming: 
\end_layout

\begin_layout Enumerate
Actions and functions that are in other functions need to get new names
 and the hierarchy needs to be flattened
\end_layout

\begin_layout Enumerate
Actions need to be demultiplexed, as their C++ code needs to be different
 depending on which thread calls that action.
 For instance, an actionPrint needs to be transformed to a push to a list
 whose name depends on the calling thread
\end_layout

\begin_layout Enumerate
Function calls need to be changed so they refer to the new names
\end_layout

\begin_layout Chapter
Implementation
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Give code details (not a complete listing, but descriptions of key parts).
 Discuss the most important/interesting aspects.
 It probably won't be possible to discuss everything - give a rationale
 for what you do discuss.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The compiler consists of four parts: The scanner, parser, checker and code
 generator.
 There is no optimizer, although the requirement for no dynamic destruction
 or creation allows us to use a loop in threads instead of just recursion.
 This is necessary because neither Clang nor GCC could correctly optimize
 that tail recursion into a loop in testing, leading to a stack overflow.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename compiler.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Section
The Glue
\end_layout

\begin_layout Standard
It is instructive to first take a view at how the pieces fit together:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  def getOptions(args:Array[String],file:String): Options =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    println(args.toString)
\end_layout

\begin_layout Plain Layout

    new Options(CompileTypeOption.interpreted, true, file)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def compile(opts:Options):Unit =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    println("Now compiling!")
\end_layout

\begin_layout Plain Layout

    val sourcestring = fromFile(opts.file).mkString
\end_layout

\begin_layout Plain Layout

    FumurtScanner.scan(sourcestring) match
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      case Left(error) => println("Error in scanner: " + error.toString)
\end_layout

\begin_layout Plain Layout

      case Right(tokens) => 
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        FumurtParser.parse(tokens) match
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          case Left(error) => println("Error in parser: " + error.toString)
\end_layout

\begin_layout Plain Layout

          case Right(ast) => 
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            FumurtTypeChecker.check(ast) match
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              case Some(errors) => 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                errors.map(x=>println(x))
\end_layout

\begin_layout Plain Layout

                val errornum:String = errors.length match
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  case 1 => "one"
\end_layout

\begin_layout Plain Layout

                  /*[...]*/
\end_layout

\begin_layout Plain Layout

                  case x => x.toString
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                println(errornum.capitalize+" errors found")
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

              case None => 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                val generatedcode = FumurtCodeGenerator.generate(ast)
\end_layout

\begin_layout Plain Layout

                import java.nio.file.{Paths, Files}
\end_layout

\begin_layout Plain Layout

                import java.nio.charset.StandardCharsets
\end_layout

\begin_layout Plain Layout

                val outname = "generated"
\end_layout

\begin_layout Plain Layout

                val fileending = ".cpp"
\end_layout

\begin_layout Plain Layout

                Files.write(Paths.get("./"+outname+fileending), generatedcode.getByt
es(StandardCharsets.UTF_8))
\end_layout

\begin_layout Plain Layout

                val options = " -pthread -std=c++11 -O3"
\end_layout

\begin_layout Plain Layout

                println("
\backslash
n
\backslash
n===Starting Clang cpp compilation===")
\end_layout

\begin_layout Plain Layout

                import scala.sys.process._
\end_layout

\begin_layout Plain Layout

                val command = "clang++ " + outname + fileending + options
 + " -o " + outname
\end_layout

\begin_layout Plain Layout

                (command).!
\end_layout

\begin_layout Plain Layout

              }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the steps:
\end_layout

\begin_layout Enumerate
The code is scanned.
 If there is an error it's printed and compilation ended.
 Note that neither scanner nor parser are advanced enough to detect more
 than one error.
 
\end_layout

\begin_layout Enumerate
The tokens from the scanner is parsed.
 If there is an error it's printed and compilation ended.
 
\end_layout

\begin_layout Enumerate
The AST from the parser is handed to the checker, which looks for any semantic
 errors.
 If there are any, they are printed out and compilation ended.
\end_layout

\begin_layout Enumerate
The AST from from the parser is given to the code generator, which produces
 C++ code conforming to the C++11 standard.
\end_layout

\begin_layout Enumerate
The Clang C family compiler
\begin_inset CommandInset citation
LatexCommand cite
key "clang2005language"

\end_inset

 is used to compile the C++ code to native binaries.
\end_layout

\begin_layout Section
Scanner
\end_layout

\begin_layout Standard
Drawing on experience from the TU Berlin course
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TUB course"

\end_inset

, the Scala Standard Parser Combinator Library was chosen.
\end_layout

\begin_layout Standard
Parsers for individual tokens are formed like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def intParser: Parser[IntegerT] = positioned( new Regex("""(0|[1-9]
\backslash
d*)""") ^^ {x => IntegerT(x.toInt)} )
\end_layout

\begin_layout Plain Layout

def equalParser: Parser[EqualT] = positioned( new Regex("=") ^^ {x => EqualT()}
 )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parsers are then combined into the final scanner using the alternate
 operator
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "scala parser combinator doc"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "scanner combined"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def scanInternal: Parser[Token] = 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  (
\end_layout

\begin_layout Plain Layout

    spaceParser                 |
\end_layout

\begin_layout Plain Layout

    programStrParser            |
\end_layout

\begin_layout Plain Layout

    /*more here*/
\end_layout

\begin_layout Plain Layout

    functionParser              |
\end_layout

\begin_layout Plain Layout

    trueParser                  |
\end_layout

\begin_layout Plain Layout

    /*more here*/
\end_layout

\begin_layout Plain Layout

    doubleParser                |
\end_layout

\begin_layout Plain Layout

    intParser                   |
\end_layout

\begin_layout Plain Layout

    equalParser                 |
\end_layout

\begin_layout Plain Layout

    /*more here*/                   
\end_layout

\begin_layout Plain Layout

    idParser                    |
\end_layout

\begin_layout Plain Layout

    typeParser  
\end_layout

\begin_layout Plain Layout

  )            
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It all goes into a list of tokens.
 The tokens are defined like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

abstract class Token() extends Positional
\end_layout

\begin_layout Plain Layout

abstract class DefDescriptionT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class BasicValueT() extends Token
\end_layout

\begin_layout Plain Layout

abstract class SyntaxT() extends Token
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class EmptyT() extends Token
\end_layout

\begin_layout Plain Layout

case class TrueT() extends BasicValueT {override def toString = "true"}
\end_layout

\begin_layout Plain Layout

case class ProgramT() extends DefDescriptionT {override def toString = "program"
}
\end_layout

\begin_layout Plain Layout

case class ActionT() extends DefDescriptionT {override def toString = "action"}
\end_layout

\begin_layout Plain Layout

case class OpenParenthesisT() extends SyntaxT {override def toString = "
\backslash
"(
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class DoubleT(val value:Double) extends BasicValueT {override def toString
 = "decimal number"}
\end_layout

\begin_layout Plain Layout

case class EqualT() extends SyntaxT {override def toString = "
\backslash
"=
\backslash
""}
\end_layout

\begin_layout Plain Layout

case class IdT(val value:String) extends Token {override def toString =
 "identifier(
\backslash
""+value+"
\backslash
")"}
\end_layout

\begin_layout Plain Layout

case class SpaceT() extends SyntaxT
\end_layout

\begin_layout Plain Layout

case class EofT() extends SyntaxT {override def toString = "end of file"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Positional
\begin_inset CommandInset citation
LatexCommand cite
key "ScalaParserPositional"

\end_inset

 is a trait that gives the token a Position.
 The 
\begin_inset Quotes eld
\end_inset

positioned
\begin_inset Quotes erd
\end_inset

 call in the parsers assigns the Position to the token.
 This is all inherited from the parser combinator library, so it's hard
 to understand what's going on from looking at the source alone.
 The 
\begin_inset Quotes eld
\end_inset

positioned
\begin_inset Quotes erd
\end_inset

 call assigns the source code position of the input text to the token object
 produced by the parser, which allows us to output really nice error messages
 later on.
\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
scan(in:String):Either[NoSuccess, List[Token]] 
\emph default
Takes the source file as a string and either outputs a list of tokens or
 an error message
\end_layout

\begin_layout Itemize

\emph on
scanInternal:Parser[Token]
\emph default
 Is the internal scanner.
 The parser combinator library will use this to create a sparser to serve
 as scanner at compile time
\end_layout

\begin_layout Itemize
x
\emph on
Parser: Parser[XT] 
\emph default
Parses that particular type of token, for example 
\emph on
newlineParser: Parser[NewlineT]
\end_layout

\begin_layout Section
Parser
\end_layout

\begin_layout Standard
Like in the scanner, the Scala Standard Parser Combinator Library was used.
 Unfortunately, the tasks of the parser is a bit more complicated than those
 of the scanner, and the code reflects this.
\end_layout

\begin_layout Subsection
Grammar
\end_layout

\begin_layout Standard
Here's the EBNF (ISO/IEC 14977) for the grammar, as implemented:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prog = paddedDef, {paddedDef}, EoF;
\end_layout

\begin_layout Plain Layout

paddedDef = {"
\backslash
n"}, def, {"
\backslash
n"};
\end_layout

\begin_layout Plain Layout

def = deflhs, "=", {"
\backslash
n"}, defrhs;
\end_layout

\begin_layout Plain Layout

deflhs = defdescription, id, args, ":", type;
\end_layout

\begin_layout Plain Layout

args = ("(", id, ":", type, {subsequentArg}) | "";
\end_layout

\begin_layout Plain Layout

subsequentArg = ",", id, ":", type;
\end_layout

\begin_layout Plain Layout

defrhs = "{", {"
\backslash
n"}, expression, {("
\backslash
n", {"
\backslash
n"}, expression)}, {"
\backslash
n"}, "}";
\end_layout

\begin_layout Plain Layout

expression = def | statement;
\end_layout

\begin_layout Plain Layout

statement = functionCall | basicStatement | identifierStatement;
\end_layout

\begin_layout Plain Layout

callargs = "(", (namedcallargs|callarg), ")";
\end_layout

\begin_layout Plain Layout

callarg = statement | "";
\end_layout

\begin_layout Plain Layout

namedcallargs = namedcallarg, subsequentnamedcallarg, {subsequentnamedcallarg};
\end_layout

\begin_layout Plain Layout

subsequentnamedcallarg = ",", namedcallarg;
\end_layout

\begin_layout Plain Layout

namedcallarg = id, "=", callarg;
\end_layout

\begin_layout Plain Layout

functionCall = id, callargs;
\end_layout

\begin_layout Plain Layout

identifierStatement = id;
\end_layout

\begin_layout Plain Layout

defdescription = "program" | "action" | "thread" | "function" | "value";
\end_layout

\begin_layout Plain Layout

basicStatement = boolean | string | integer | float;
\end_layout

\begin_layout Plain Layout

float = integer, ".", digit, {digit};
\end_layout

\begin_layout Plain Layout

integer = "0" | (digit excluding zero, {digit});
\end_layout

\begin_layout Plain Layout

digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
 ;
\end_layout

\begin_layout Plain Layout

digit = "0" | digit excluding zero ;
\end_layout

\begin_layout Plain Layout

upper case = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" |
 "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" |
 "W" | "X" | "Y" | "Z" ;
\end_layout

\begin_layout Plain Layout

lower case = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
 "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" |
 "w" | "x" | "y" | "z" ;
\end_layout

\begin_layout Plain Layout

id = lower case, {(upper case | lower case)}
\end_layout

\begin_layout Plain Layout

type = upper case, {(upper case | lower case)}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Code
\end_layout

\begin_layout Standard
This is where the grammar is encoded into the program:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def progParser: Parser[List[Definition]] = (paddedDefParser.+) <~ eofParser
\end_layout

\begin_layout Plain Layout

def paddedDefParser:Parser[Definition] = { newlineParser.* ~> defParser <~
 newlineParser.* }
\end_layout

\begin_layout Plain Layout

def defParser: Parser[Definition] = {positioned((deflhsParser <~ equalParser
 ~! newlineParser.*) ~! defrhsParser ^^ {x=>Definition(x._1,x._2)}) }
\end_layout

\begin_layout Plain Layout

def deflhsParser: Parser[DefLhs] = {(defdescriptionParser ~ idParser ~ argsParse
r ~! (colonParser ~> typeParser)) ^^ {x=>DefLhs(x._1._1._1, x._1._1._2, x._1._2,
 x._2)} }
\end_layout

\begin_layout Plain Layout

def argsParser: Parser[Option[Arguments]] = {openParenthesisParser ~> ((idParser
 <~ colonParser) ~ typeParser ~ subsequentArgsParser.*) <~ closeParenthesisParser
 ^^{x=>Some(Arguments( (Argument(x._1._1, x._1._2) +: x._2).sortWith((left,right)=>lef
t.id.value<right.id.value) ))} | emptyParser ^^ {x=>None} }
\end_layout

\begin_layout Plain Layout

def subsequentArgsParser: Parser[Argument] = {commaParser ~> (idParser <~
 colonParser) ~ typeParser ^^{x=>Argument(x._1, x._2)} }
\end_layout

\begin_layout Plain Layout

/*more here*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The relevant values are extracted from the result by using the 
\begin_inset Quotes eld
\end_inset

._x
\begin_inset Quotes erd
\end_inset

 methods, where x is a number.
 This is because the result of several consecutive parsers are combined
 into sets.
 
\begin_inset Quotes eld
\end_inset

._1
\begin_inset Quotes erd
\end_inset

 is then the first value of the set, etc.
 The structure of these sets are sometimes not immediately obvious.
 For the operators refer back to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Scala-Parser"

\end_inset

.
\end_layout

\begin_layout Standard
There are also a number of somewhat less exciting helper parsers, of which
 we provide an example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def equalParser:Parser[Token] = accept(EqualT())
\end_layout

\begin_layout Plain Layout

def colonParser:Parser[Elem] = accept(ColonT())
\end_layout

\begin_layout Plain Layout

def commaParser:Parser[Elem] = accept(CommaT())
\end_layout

\begin_layout Plain Layout

def basicStatementParser:Parser[BasicValueStatement] = accept("expected
 string, integer, boolean or float", {case StringT(value) => StringStatement(val
ue);                                                                   
                               case IntegerT(value)=> IntegerStatement(value)
                                                                       
                          case DoubleT(value) => DoubleStatement(value)
                                                                       
                          case TrueT() => TrueStatement()              
                                                                       
            case FalseT() => FalseStatement()}                         
                                                                       
 )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can here see some of how the parser error messages are generated.
\end_layout

\begin_layout Standard
The entirety produces an abstract syntax tree defined as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Expression() extends Positional
\end_layout

\begin_layout Plain Layout

trait Callarg extends Positional
\end_layout

\begin_layout Plain Layout

trait Statement extends Expression
\end_layout

\begin_layout Plain Layout

trait BasicValueStatement extends Statement with Callarg with aCallarg with
 aStatement
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class Definition(val leftside:DefLhs, val rightside:DefRhs) extends
 Expression
\end_layout

\begin_layout Plain Layout

case class DefLhs(val description:DefDescriptionT, val id:IdT, val args:Option[A
rguments], val returntype:TypeT)
\end_layout

\begin_layout Plain Layout

case class Arguments(val args:List[Argument])
\end_layout

\begin_layout Plain Layout

case class Argument(val id:IdT, val typestr:TypeT)
\end_layout

\begin_layout Plain Layout

case class DefRhs(val expressions:List[Expression] )
\end_layout

\begin_layout Plain Layout

case class Empty();
\end_layout

\begin_layout Plain Layout

case class DefDescription(val value:Token)
\end_layout

\begin_layout Plain Layout

case class NamedCallarg(id:IdT, argument:Callarg) //extends Callarg
\end_layout

\begin_layout Plain Layout

case class NamedCallargs(val value:List[NamedCallarg])
\end_layout

\begin_layout Plain Layout

case class NoArgs() extends Callarg with aCallarg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case class StringStatement(val value:String) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IntegerStatement(val value:Int) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class DoubleStatement(val value:Double) extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class TrueStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class FalseStatement() extends BasicValueStatement
\end_layout

\begin_layout Plain Layout

case class IdentifierStatement(val value:String) extends Statement with
 Callarg with aCallarg with aStatement
\end_layout

\begin_layout Plain Layout

case class FunctionCallStatement(val functionidentifier:String, val args:Either[
Callarg,NamedCallargs]) extends Statement with Callarg
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
parse(in:List[Token]):Either[NoSuccess, List[Definition]] 
\emph default
takes a list of tokens and returns either an error message or an AST
\end_layout

\begin_layout Itemize

\emph on
progParser: Parser[List[Definition]]
\emph default
 is the head of the parsers, from which the parser combinator library will
 generate the final parser
\end_layout

\begin_layout Itemize
x
\emph on
Parser:Parser[X] 
\emph default
parses that particular kind of AST node, for example 
\emph on
defParser:Parser[Definition]
\emph default
.
 Can often be a bit indirect.
 For example, 
\emph on
paddedDefParser:Parser[Definition] 
\emph default
parses a definition with newlines around it, but using 
\emph on
defParser:Parser[Definition]
\emph default
 to parse the definition part.
\end_layout

\begin_layout Paragraph
Class List
\end_layout

\begin_layout Itemize

\emph on
Class TokenReader
\emph default
 is a wrapping around the list of tokens.
 It is required by the parser combinator library and implements the Reader
 interface.
 It has the following functions:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
atEnd
\emph default
 which returns true if the list of tokens is empty
\end_layout

\begin_layout Itemize

\emph on
first
\emph default
, which returns the current first element in the list
\end_layout

\begin_layout Itemize

\emph on
pos
\emph default
, which returns the source text position of the first element in the list
\end_layout

\begin_layout Itemize

\emph on
rest
\emph default
, which returns a new TokenReader wrapping all elements except the first
 in the list
\end_layout

\end_deeper
\begin_layout Itemize
Different classes forming parts of the AST, for example 
\emph on
class Definition(val leftside:DefLhs, val rightside:DefRhs).
\end_layout

\begin_layout Section
Checker
\end_layout

\begin_layout Standard
The checker, contrary to its in-source name (FumurtTypeChecker) checks more
 than types.
 It does not modify, annotate or otherwise change the abstract syntax tree.
 It simply returns errors found or returns nothing.
 When the implementation of the checker began it was envisaged that the
 basic functions would be treated equally with user defined functions, but
 due to the lack of generics and other abstraction mechanisms, most of the
 basic functions still needed special treatment, with 
\begin_inset Quotes eld
\end_inset

actionPrint
\begin_inset Quotes erd
\end_inset

 being the notable exception.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object FumurtTypeChecker
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  def check(in:List[Definition]):Option[List[FumurtError]] =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    val providedTypes = List("Integer", "Double", "Boolean", "String", "Nothing"
)
\end_layout

\begin_layout Plain Layout

    val print = DefLhs(ActionT(), IdT("actionPrint"), Some(Arguments(List(Argume
nt(IdT("toPrint"), TypeT("String"))))), TypeT("Nothing"))
\end_layout

\begin_layout Plain Layout

    val basicfunctions = List(print)
\end_layout

\begin_layout Plain Layout

    val errors = checktop(in, basicfunctions)
\end_layout

\begin_layout Plain Layout

    if (errors.isEmpty)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      Some(errors)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  //the rest goes here
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This graphic illustrates how the functions in the checker call each other:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename checker.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
check(in:List[Definition]):Option[List[FumurtError]] 
\emph default
is the interface to the rest of the program.
 Takes in a AST and returns a list of errors, if there are any.
\end_layout

\begin_layout Itemize

\emph on
checktop(in:List[Definition], basicFunctions:List[DefLhs]): List[FumurtError]
 
\emph default
checks the top level of the program.
 The top is special because it contains threads and the program statement,
 though only the program statement need special treatment.
\end_layout

\begin_layout Itemize

\emph on
checkprogram(program:Definition, topleveldefs:List[DefLhs], basicFunctions:List[
DefLhs]): List[FumurtError] 
\emph default
checks the program statement.
 Uses checkuseofthread and checks whether there are any calls to non-threads
 or definition of non-synchronized variables.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
checkuseofthread(program:Definition, thread:DefLhs):List[FumurtError] 
\emph default
checks that the thread given is actually called in the program statement.
 Declaring a thread and failing to call it is an error.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
checkexpressions(tree:List[Expression], containingdefinition:Option[Definition],
 containingdefinitionarguments:Option[List[DefLhs]], basicFunctions:List[DefLhs]
):List[FumurtError] 
\emph default
checks a list of expressions, such as might be found in the right-hand side
 of a definition.
 Uses 
\emph on
indexleft
\emph default
 to get new in-scope definitions and passes them to 
\emph on
checkexpression
\end_layout

\begin_layout Itemize

\emph on
checkexpression(tocheck:Expression, containingdefinition:Option[Definition],
 arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs], inSameDefinition:L
ist[DefLhs]):List[FumurtError] 
\emph default
checks an individual expression.
 Uses 
\emph on
checkstatement
\emph default
 and 
\emph on
checkdefinition
\end_layout

\begin_layout Itemize

\emph on
checkstatement(tocheck:Statement, containingdefinition:DefLhs, arguments:Option[
List[DefLhs]], basicFunctions:List[DefLhs], inSameDefinition:List[DefLhs],
 expectedreturn:TypeT): List[FumurtError] 
\emph default
checks a statement.
 If it's an identifierStatement, checks that its return value is as expected.
 Uses 
\emph on
checkbasicvaluestatement 
\emph default
for the same for basic values.
 If it's a function call, then it either uses special case functions, such
 as 
\emph on
checkifcall
\emph default
 or finds the function in scope and uses a general approach using checknamedcall
args and/or checkcallarg
\end_layout

\begin_layout Itemize

\emph on
checkifcall(ifcall:FunctionCallStatement, expectedtype:TypeT, containingdefiniti
on:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError]
\emph default
 checks calls to if.
 Makes sure the return type of then and else is the same and that condition
 is a boolean.
 Also checks naming, of course.
\end_layout

\begin_layout Itemize

\emph on
checkmutatecall(call:FunctionCallStatement, expectedtype:TypeT, containingdefini
tion:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError]
\emph default
 checks that the variable is a synchronized variable and otherwise has the
 same type as the new value
\end_layout

\begin_layout Itemize

\emph on
checkbasicmathcall(call:FunctionCallStatement, expectedtype:TypeT, containingdef
inition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError] 
\emph default
checks the four basic math operators, with special attention to the return
 type when double and int are mixed
\end_layout

\begin_layout Itemize

\emph on
checktostringcall(call:FunctionCallStatement, expectedtype:TypeT, containingdefi
nition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs],
 inSameDefinition:List[DefLhs]):List[FumurtError] 
\emph default
checks that there is only one argument and that the expected type is String
\end_layout

\begin_layout Itemize

\emph on
checknamedcallargs(calledfunction:DefLhs, namedcallargs:List[NamedCallarg],
 containingdefinition:DefLhs, arguments:Option[List[DefLhs]], basicFunctions:Lis
t[DefLhs], inSameDefinition:List[DefLhs]):List[FumurtError] 
\emph default
checks named call arguments.
 Checks that the correct names are used, that the correct number of arguments
 are given and uses checkcallarg to check each argument individually.
\end_layout

\begin_layout Itemize

\emph on
checkCallarg(expectedtype:TypeT, arg:Callarg, containingdefinition:DefLhs,
 arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs], inSameDefinition:L
ist[DefLhs]):List[FumurtError]
\emph default
 checks a call argument.
 Makes sure the type is correct.
 Uses checkbasicvaluestatement and checkstatement.
\end_layout

\begin_layout Itemize

\emph on
checkbasicvaluestatement(expectedtype:TypeT, basicstatement:BasicValueStatement,
 role:String):List[FumurtError]
\emph default
 checks that the type is correct.
\end_layout

\begin_layout Itemize

\emph on
checkdefinition(tocheck:Definition, containingdefinition:Option[DefLhs],
 arguments:Option[List[DefLhs]], basicFunctions:List[DefLhs]): List[FumurtError]
\end_layout

\begin_layout Itemize

\emph on
indexlefts(in:List[Expression]):List[DefLhs]
\emph default
 takes a list of expressions and returns a list of all the left sides of
 definitions in that list.
\end_layout

\begin_layout Itemize

\emph on
findinscope(arguments:Option[List[DefLhs]], inSameDefinition:List[DefLhs],
 basicfunctions:List[DefLhs], enclosingDefinition:Option[DefLhs], searchFor:Stri
ng):Either[String, DefLhs] 
\emph default
finds a left side of the definition in the current scope with the same name
 as that which is searched for.
\end_layout

\begin_layout Section
Code generator
\end_layout

\begin_layout Paragraph
Function List
\end_layout

\begin_layout Itemize

\emph on
generate(ast:List[Definition]):String
\emph default
 generates the final C++ code from the Fumurt AST
\end_layout

\begin_layout Itemize

\emph on
getAnnotatedTree(ast:List[Expression], topthreadcalls:List[FunctionCallStatement
]):List[aExpression] 
\emph default
Returns an annotated version of the supplied AST.
 This version has the final C++ names for functions and function calls
\end_layout

\begin_layout Itemize

\emph on
getCallsAnnotatedTreeInternal(ast:List[aExpression], arguments:List[aDefLhs],
 containingDefinition:Option[aDefinition]):List[aExpression] 
\emph default
returns an annotated version of the AST with final C++ names for function
 calls.
 Requires that function names have been annotated first
\end_layout

\begin_layout Itemize

\emph on
annotateFunctionCall(functioncall:aFunctionCallStatement, arguments:List[aDefLhs
], inSameDefinition:List[aDefLhs], containingDefinition:Option[aDefinition]):aFu
nctionCallStatement 
\emph default
annotates a single function call
\end_layout

\begin_deeper
\begin_layout Itemize
annotateCallargs(args:Either[aCallarg,aNamedCallargs], arguments:List[aDefLhs],
 inSameDefinition:List[aDefLhs], containingDefinition:Option[aDefinition]):Eithe
r[aCallarg,aNamedCallargs] annotates that function calls call arguments.
 Since call arguments can be function calls, this is often recursive.
\end_layout

\begin_layout Itemize

\emph on
removeInclusions(args:Either[aCallarg,aNamedCallargs], ldeffargs:Option[Argument
s]):Either[aCallarg,aNamedCallargs] 
\emph default
removes inclusion arguments from functions, since these have no purpose
 in C++
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
indexlefts(in:List[aExpression]):List[aDefLhs] 
\emph default
indexes DefLhs's like in the checker, but with the annotated types.
\end_layout

\begin_layout Itemize

\emph on
findinscope(arguments:Option[List[aDefLhs]], inSameDefinition:List[aDefLhs],
 enclosingDefinition:Option[aDefLhs], searchFor:String):aDefLhs 
\emph default
same as the version in the checker, but with annotated types.
\end_layout

\begin_layout Itemize

\emph on
getAnnotatedTreeInternal(ast:List[Expression], topthreadcalls:List[FunctionCallS
tatement], hierarchy:String, callingthread:Option[String]):List[aExpression]
 
\emph default
returns an AST with with final C++ names for functions
\end_layout

\begin_layout Itemize

\emph on
getFunctionDeclarations(ast:List[aExpression]):(String,String) 
\emph default
gets the functions, in C++, from the AST
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
actfunrecursivetranslate(cppid:IdT, callingthread:String, args:Option[Arguments]
, returntype:TypeT, expressions:List[aExpression]):Option[(String,String)]
 
\emph default
gets function body and signature of a function corresponding to the arguments
 as well as all functions defined in the body of the definition.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
getFunctionSignature(cppid:IdT, optargs:Option[Arguments], returntype:TypeT):Str
ing 
\emph default
constructs a C++ function signature from the arguments
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
argtranslator(arg:Argument):String
\emph default
 translates an argument as used in defining a function
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
typetranslator(in:TypeT):String 
\emph default
translates (basic) Fumurt types to their C++ equivalents
\end_layout

\begin_layout Itemize

\emph on
callargTranslator(callarg:aCallarg, callingthread:String):String 
\emph default
translates a call argument to C++ equivalent
\end_layout

\begin_layout Itemize

\emph on
functioncalltranslator(call:aFunctionCallStatement, callingthread:String):String
 
\emph default
translates function call
\end_layout

\begin_layout Itemize

\emph on
basicmathcalltranslator(call:aFunctionCallStatement, callingthread:String):Strin
g
\end_layout

\begin_layout Itemize

\emph on
gettopthreadstatements(ast:List[Definition]):List[FunctionCallStatement]
 
\emph default
gets the C++ statements spawning the threads.
 
\end_layout

\begin_layout Itemize

\emph on
getprintlistdeclarations(topthreads:List[FunctionCallStatement]):String
 
\emph default
gets the printList declarations.
 These are lists in which strings to be printed are kept.
\end_layout

\begin_layout Itemize

\emph on
getmain(topthreads:List[FunctionCallStatement]):String 
\emph default
gets the main function.
 This only spawns the threads and then goes to sleep
\end_layout

\begin_layout Itemize

\emph on
getsynchronizerfunction(synchvariables:List[Definition], topthreads:List[Functio
nCallStatement]):String 
\emph default
gets the mostly static and hand-written function that performs all actions
 during the communication phase
\end_layout

\begin_layout Itemize

\emph on
getGlobalSynchVariableDeclarations(synchvariables:List[Definition]):String
\emph default
 gets the C++ declarations of the synchronized variables
\end_layout

\begin_layout Itemize

\emph on
getsynchronizedvariables(ast:List[Definition]):List[Definition]
\emph default
 gets the definitions of the synchronized variables, so that they can later
 be used in 
\emph on
getGlobalSynchVariableDeclarations
\end_layout

\begin_layout Paragraph
Classes
\end_layout

\begin_layout Standard
The generator holds classes needed to annotate the AST, for example 
\emph on
class aDefinition(val leftside:aDefLhs, val rightside:aDefRhs).
 
\emph default
Existing AST classes are used unless extra information needs to be held
 or it is a parent of such a class.
 The most dramatic example is 
\emph on
class aDefLhs(val description:DefDescriptionT, val id:IdT, val cppid:IdT,
 val callingthread:String, val args:Option[Arguments], val returntype:TypeT)
\emph default
.
 In cases where functions need to be demultiplexed, the new AST will be
 modified to hold those as well.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename codegenerator.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Subsection
Annotator
\end_layout

\begin_layout Chapter
Testing
\end_layout

\begin_layout Standard

\emph on
Test plan -- how the program/system was verified.
 Put the actual test results in the Appendix.
 This section is useful if your project is more on the software engineering
 side than research focused.
\end_layout

\begin_layout Section
Full program test
\begin_inset CommandInset label
LatexCommand label
name "sec:Full-program-test"

\end_inset


\end_layout

\begin_layout Standard
The following Fumurt code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

program p:Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  synchronized variable synchronizedNumber:Integer = {synchronized(variable=0,
 writer=threadPrintHello)}
\end_layout

\begin_layout Plain Layout

  threadPrintHello(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=actionPrintFoo, integerIdentity=integerIdentity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintWorld(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint("world ")
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedNumber))
\end_layout

\begin_layout Plain Layout

  threadPrintWorld(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

thread threadPrintHello(synchronizedNumber:Integer):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(synchronizedNumber))
\end_layout

\begin_layout Plain Layout

  actionPrint(" Hello ")
\end_layout

\begin_layout Plain Layout

  actionMutate(variable=synchronizedNumber, newValue=plus(left=synchronizedNumbe
r, right=1))
\end_layout

\begin_layout Plain Layout

  threadPrintHello(synchronizedNumber)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread threadPrintLol(actionPrintFoo:Inclusion, integerIdentity:Inclusion):Nothi
ng =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintLol:Nothing =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  LOL   ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  actionPrintLol()
\end_layout

\begin_layout Plain Layout

  actionPrintFoo(integerIdentity)
\end_layout

\begin_layout Plain Layout

  threadPrintLol(actionPrintFoo=actionPrintFoo, integerIdentity=integerIdentity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

action actionPrintFoo(integerIdentity:Inclusion):Nothing =
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  action actionPrintFooo:Nothing =
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    actionPrint("  FOOO  ")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  actionPrint("  FOO   ")
\end_layout

\begin_layout Plain Layout

  actionPrintFooo()
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(integerIdentity(5)))
\end_layout

\begin_layout Plain Layout

  actionPrint("  ")
\end_layout

\begin_layout Plain Layout

  actionPrint(if(condition=true, then=toString(6), else=toString(3)))
\end_layout

\begin_layout Plain Layout

  actionPrint("
\backslash
n")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function integerIdentity(x:Integer):Integer = {x}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gets compiled to the following C++11 code:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <thread>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

#include <atomic>
\end_layout

\begin_layout Plain Layout

#include <condition_variable>
\end_layout

\begin_layout Plain Layout

#include <list>
\end_layout

\begin_layout Plain Layout

#include <chrono>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define NUMTOPTHREADS 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintWorld();
\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintHello();
\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintLol();
\end_layout

\begin_layout Plain Layout

void actionPrintLol$threadPrintLol();
\end_layout

\begin_layout Plain Layout

int integerIdentity$(int x);
\end_layout

\begin_layout Plain Layout

void actionPrintFoo$threadPrintLol();
\end_layout

\begin_layout Plain Layout

void actionPrintFooo$threadPrintLolactionPrintFoo();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int synchronizedNumber = 0;
\end_layout

\begin_layout Plain Layout

static int writeSynchronizedNumber = 0;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintHello;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintWorld;
\end_layout

\begin_layout Plain Layout

static std::list<std::string> printthreadPrintLol;
\end_layout

\begin_layout Plain Layout

static std::atomic<int> rendezvousCounter;
\end_layout

\begin_layout Plain Layout

static std::mutex rendezvousSyncMutex;
\end_layout

\begin_layout Plain Layout

static std::condition_variable cv;static void waitForRendezvous(std::string
 name)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  std::unique_lock<std::mutex> lk(rendezvousSyncMutex);
\end_layout

\begin_layout Plain Layout

  ++rendezvousCounter;
\end_layout

\begin_layout Plain Layout

  if(rendezvousCounter.load() < NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cv.wait(lk);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if (rendezvousCounter.load() == NUMTOPTHREADS)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    while(!printthreadPrintHello.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintHello.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintHello.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

while(!printthreadPrintWorld.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintWorld.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintWorld.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

while(!printthreadPrintLol.empty()){
\end_layout

\begin_layout Plain Layout

std::cout << printthreadPrintLol.front();
\end_layout

\begin_layout Plain Layout

printthreadPrintLol.pop_front();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

synchronizedNumber = writeSynchronizedNumber;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

      cv.notify_all();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    std::cout << "error in wait for " << name << ".
 Rendezvouscounter out of bounds.
 RedezvousCounter = " << rendezvousCounter.load() << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    exit(0);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintWorld()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintWorld.push_back("world ");
\end_layout

\begin_layout Plain Layout

  printthreadPrintWorld.push_back(std::to_string(synchronizedNumber));
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintWorld");
\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintHello()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintHello.push_back(std::to_string(synchronizedNumber));
\end_layout

\begin_layout Plain Layout

  printthreadPrintHello.push_back(" Hello ");
\end_layout

\begin_layout Plain Layout

  writeSynchronizedNumber = (synchronizedNumber + 1);
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintHello");
\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[noreturn]] static void threadPrintLol()
\end_layout

\begin_layout Plain Layout

{while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  actionPrintLol$threadPrintLol();
\end_layout

\begin_layout Plain Layout

  actionPrintFoo$threadPrintLol();
\end_layout

\begin_layout Plain Layout

  waitForRendezvous("threadPrintLol");
\end_layout

\begin_layout Plain Layout

  continue;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintLol$threadPrintLol()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back("  LOL   ");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int integerIdentity$(int x)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  return x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintFoo$threadPrintLol()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back("  FOO   ");
\end_layout

\begin_layout Plain Layout

  actionPrintFooo$threadPrintLolactionPrintFoo();
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back(std::to_string(integerIdentity$(5)));
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back("  ");
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back(std::to_string(6));
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back("
\backslash
n");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void actionPrintFooo$threadPrintLolactionPrintFoo()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printthreadPrintLol.push_back("  FOOO  ");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

rendezvousCounter.store(0);
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintHello (threadPrintHello);
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintWorld (threadPrintWorld);
\end_layout

\begin_layout Plain Layout

std::thread tthreadPrintLol (threadPrintLol);
\end_layout

\begin_layout Plain Layout

while(true)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

std::this_thread::sleep_for(std::chrono::seconds(1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When run in a terminal, this results in the following output:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0 Hello world 0  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

1 Hello world 1  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

2 Hello world 2  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

3 Hello world 3  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

4 Hello world 4  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

5 Hello world 5  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

6 Hello world 6  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

7 Hello world 7  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

8 Hello world 8  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

9 Hello world 9  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

10 Hello world 10  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

11 Hello world 11  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

12 Hello world 12  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

13 Hello world 13  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

14 Hello world 14  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

15 Hello world 15  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

16 Hello world 16  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

17 Hello world 17  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

18 Hello world 18  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

19 Hello world 19  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

20 Hello world 20  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

21 Hello world 21  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

22 Hello world 22  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

23 Hello world 23  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

24 Hello world 24  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

25 Hello world 25  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

26 Hello world 26  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

27 Hello world 27  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

28 Hello world 28  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

29 Hello world 29  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

30 Hello world 30  LOL     FOO     FOOO  5  6
\end_layout

\begin_layout Plain Layout

/*and so on...*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We observe that all output is deterministic.
 Multithreading is an implementation detail here.
\end_layout

\begin_layout Section
Error messages
\end_layout

\begin_layout Standard
Changing the source in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Full-program-test"

\end_inset

 to have 5.0 instead of 5 as an argument to integerIdentity we get the following
 type error:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

44.40: Call argument type should be Integer.
 Call argument type was Double
\end_layout

\begin_layout Plain Layout

  actionPrint(toString(integerIdentity(5.0)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

One errors found
\end_layout

\end_inset


\end_layout

\begin_layout Section
Not Implemented
\end_layout

\begin_layout Itemize
Loops
\end_layout

\begin_layout Itemize
User-defined types
\end_layout

\begin_layout Itemize
Boolean functions and logic
\end_layout

\begin_layout Chapter
Results
\end_layout

\begin_layout Standard

\emph on
This covers different areas to the 'Testing' chapter, and is appropriate
 for 'research style' projects.
 For such projects this chapter should detail the types of experiments/simulatio
ns that were carried out with the code written.
 Why were certain experiments carried out but not others? What were the
 important parameters in the simulation and how did they affect the results?
 If there are very many graphs and tables associated with this chapter they
 may be put in the Appendix, but it is generally better to keep these close
 to the text they illustrate, as this is easier for the reader.
\end_layout

\begin_layout Chapter
Conclusion, Evaluation and Further Work
\end_layout

\begin_layout Standard

\emph on
What have you achieved? Give a critical appraisal (evaluation) of your own
 work - how could the work be taken further (perhaps by another student
 next year)?
\end_layout

\begin_layout Section
Further Work
\end_layout

\begin_layout Subsection
Further Grammar Development
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

defRhs
\begin_inset Quotes erd
\end_inset

 in the current grammar is essentially a multiline statement.
 It would be beneficial if the line between statement and defRhs could be
 eliminated.
 For instance, multiline statements could replace function calls in if-calls
 or a single line statement without brackets could serve as right hand side
 in a definition.
\end_layout

\begin_layout Standard
Adding operators seem beneficial, as do 
\end_layout

\begin_layout Subsection
More IO
\end_layout

\begin_layout Standard
At the time of writing, print is the only type of IO that Fumurt has.
 It goes without saying that this is inadequate for serious usage.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "cites"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
System manual
\end_layout

\begin_layout Standard

\emph on
This should include all the technical details (where is the code? what do
 you type to compile it? etc) that would enable a student to continue your
 project next year, to be able to amend your code and extend it.
\end_layout

\begin_layout Chapter
User manual
\end_layout

\begin_layout Standard

\emph on
This should give enough information for someone to use what you have designed
 and implemented.
\end_layout

\begin_layout Chapter
Code listing
\end_layout

\begin_layout Standard

\emph on
Your code should be well commented.
 In order not to use up too many pages of your maximum 120 on code, you
 may like to use the 'a2ps' Unix facility, which allows you to put two pages
 of code onto one side of paper - see the Unix 'man' pages for details.
 If you have a great deal of code, and including all of it would take you
 over the page limit, you can make the rest available on a floppy disk or
 CD-ROM.
 You will need to bring in two copies of any disks or CDs you include when
 you hand in your project report, one to go with each copy of your project.
\end_layout

\end_body
\end_document
