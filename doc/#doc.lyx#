#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Fumurt: A programming language with deterministic threading
\end_layout

\begin_layout Author
Tormod Gjeitnes Hellen
\end_layout

\begin_layout Standard
http://www.cs.ucl.ac.uk/teaching_learning/msc_cgvi/projects/project_report_structure
/
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
First and foremost, you should write about the most interesting or important
 parts of your project.
 Devote most space and time to this.
 For example:
\end_layout

\begin_layout Standard

\emph on
What design choices did you have along the way, and why did you make the
 choices you made? What was the most difficult part of the project? Why
 was it difficult? How did you overcome the difficulties? Did you discover
 anything novel? What did you learn?
\end_layout

\begin_layout Standard

\emph on
Set the scene and problem statement/specification.
 Provide the motivation for reading this report.
 Introduce the structure of report (what you will cover in which chapters).
 
\end_layout

\begin_layout Standard
Fumurt
\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard

\emph on
You should provide enough background to the reader for them to understand
 what the project is all about.
 For example:
\end_layout

\begin_layout Standard

\emph on
What the reader needs to know in order to understand the rest of the report.
 Examiners like to know that you have done some background research and
 that you know what else has been done in the field (where relevant).
 Try to include some references.
 Related work (if you know of any) What problem are you solving? Why are
 you solving it? How does this relate to other work in this area? What work
 does it build on?
\end_layout

\begin_layout Standard

\emph on
For 'research-style' projects - ones in which a computational technique
 (for example neural networks, genetic algorithms, finite element analysis,
 ray tracing) is used to explore or extend the properties of a mathematical
 model, or to make predictions of some kind - it may be a good idea to split
 this chapter into two shorter ones, one covering the computational technique
 itself and one the area of application.
\end_layout

\begin_layout Standard

\emph on
The Examiners are just as interested in the process you went through in
 performing your project work as the results you finally produced.
 So, make sure your reports concentrate on why you made the particular choices
 and decisions that you did.
 We are looking for reasoned arguments and for critical assessment.
 This is especially so where design, implementation and engineering decisions
 have been made not just on technical merit but under pressure of non-functional
 requirements and external influences.
\end_layout

\begin_layout Standard
It is commonly understood that writing software is hard.
 The development of programming languages is a response to this problem.
 The common pattern is that flexible features that are easily used to write
 code that is hard to reason about are replaced by, often several, less
 flexible features.
 After all, the less flexible a feature is, the more predictable its use
 is.
 Three examples: 
\end_layout

\begin_layout Itemize
goto replaced by sequence, selection and iteration 
\begin_inset CommandInset citation
LatexCommand cite
key "structured proof"

\end_inset


\end_layout

\begin_layout Itemize
pointers replaced by indexes and references 
\end_layout

\begin_layout Itemize
mutable variables replaced by immutable values 
\end_layout

\begin_layout Standard
Interestingly, one can observe that as each feature becomes easier to reason
 about, the total number of features increase.
 For example, to eliminate mutation, one needs to also eliminate iteration.
 One way to do this is by using recursion, which is a full replacement for
 iteration.
 But recursion, while allowing immutability, is often harder for humans
 to understand [citation needed].
 To ameliorate this problem, a variety of machanisms have been implemented,
 for example map and fold, which performs common functions previously performed
 utilizing iteration.
 In this manner, the number of features often increase in the interest of
 analysability.
 Is this generally true? And if so, at what point does the drawbacks of
 increasing feature number outweigh the benefit of increased analyzability
 and predictability? Answering these questions is outside the scope of this
 report.
 Much progress has been made in making programs easier to understand and
 analyze in this fashion, yet there is always room for improvement.
 In later years, one feature in particular has risen to notability: Concurrency.
 In the past, concurrency has not been an issue for most programmers but
 as multi-processor (or multi-core) systems have gone mainstream, so has
 multithreaded programming
\begin_inset CommandInset citation
LatexCommand cite
key "free lunch over"

\end_inset

.
 The problems inherent to concurrency can roughly be divided into two categories
: Communication and scheduling; making sure the correct information is shared
 between threads in a correct way and making sure tasks are done at correct
 times, respectively[citation needed].
 One possibility is to let the programmer deal with these problems in an
 application-specific way.
 This is notoriously error-prone, however.
 Several abstractions have been deviced for dealing with the two concurrency
 problems in a systematic manner, to the author's knowledge:
\end_layout

\begin_layout Itemize
Actors 
\begin_inset CommandInset citation
LatexCommand cite
key "actors"

\end_inset


\end_layout

\begin_layout Itemize
CSP 
\begin_inset CommandInset citation
LatexCommand cite
key "CSP"

\end_inset


\end_layout

\begin_layout Itemize
Transactional memory[citation needed]
\end_layout

\begin_layout Itemize
Synchronous programming
\begin_inset CommandInset citation
LatexCommand cite
key "Esterel"

\end_inset


\end_layout

\begin_layout Standard
Initially, the goal of this thesis was to create another alternative to
 these, wherein the programmer would manually schedule the execution of
 tasks at compile time.
 Tasks would be allowed to write to special variables which would be used
 in lieu of final ones if the task could not finish in the alloted time
 frame.
 This effort was abandoned because of the burden it would impose on the
 programmer, the perceived difficulty of implementation and the unsatisfactory
 failure modes.
 Instead, it was decided that an approach belonging to the tradition of
 synchronous programming would be preferable.
 Given the importance of a familiar superficialities for language adoption
\begin_inset CommandInset citation
LatexCommand cite
key "Language adoption"

\end_inset

, it was decided that the language should have a familiar C/Algol-style
 syntax, rather than invent or adopt something less common.
\end_layout

\begin_layout Standard
There are tradeoffs associated with chosing synchronous programming, but
 they were determined to be preferable to the alternatives.
 The main problems with synchronous programming are 
\end_layout

\begin_layout Enumerate
Difficulty in scaling beyond one physical machine.
 The cost of global synchronization grows with latency.
\end_layout

\begin_layout Enumerate
Performance loss due to processing resources idling as the synchronicity
 abstraction requires all operations to use the same amount of time.
\end_layout

\begin_layout Standard
Synchronous programming therefore has substantial problems, yet for single-machi
ne systems it presents a way to achieve multi-threaded performance and achitectu
re but with single-threaded predictability and therefore debugability.
 While the other abstractions place the responsibility for correct concurrent
 behaviour on the programmer, synchronous programming takes care of that
 and replaces it with the responsibility for performance, as the program
 performs best if all threads has an equal amount of work.
 Let us discuss the problems of the other abstractions
\end_layout

\begin_layout Itemize
Actors assume infinite message queues, with the failure mode being a loss
 of information.
 In a producer-consumer relationship, producer actors can overwhelm consumer
 actors.
 Actors are designed to mimic distributed systems and create a unified abstracti
on over these.
 Distributed systems have to correctly handle hardware failures, so loss
 of information is an acceptible failure mode for actors.
 However, this makes actors unsuitable for real-time systems as recovering
 from data loss and unpredictable memory usage are unacceptable tradeoffs.
 Ordering of IO is alse unpredictable.
\end_layout

\begin_layout Itemize
CSP systems use synchronous communication and therefore avoid the message
 queue problem of actors entirely.
 In exchange, they are open to deadlock, and the ordering of IO is unpredictable.
 CSP therefore requires brute force search for deadlocks, and debugging
 is harder than for single-threaded systems.
 despite this, it is regarded as a solid choice for real time systems.
\end_layout

\begin_layout Itemize
Transactional memory, though it makes it look as if thread communication
 is easy, has its own problems.
 
\end_layout

\begin_layout Chapter
Analysis and Design
\end_layout

\begin_layout Standard

\emph on
If your project involves designing a system, give a good high-level overview
 of your design.
\end_layout

\begin_layout Standard

\emph on
In many projects, the initial design and the final design differ somewhat.
 If the differences are interesting, write about them, and why the changes
 were made.
\end_layout

\begin_layout Standard

\emph on
If your design was not implemented fully, describe which parts you did implement
, and which you didn't.
 If the reason you didn't implement everything is interesting (eg it turned
 out to be difficult for unexpected reasons), write about it.
\end_layout

\begin_layout Standard
The goal of the programming language is to make a multithreaded program
 behave as predictably as were it singlethreaded.
 A corollary of this is that only changes of state that are visible to a
 single thread can happen concurrently.
 All IO and inter-thread communication are required happen in a statically
 determined sequence.
 One way to do this is to have the program have two alternating phases:
\end_layout

\begin_layout Itemize
Computational phase: In which computations local to a thread are performed.
\end_layout

\begin_layout Itemize
Communicative phase: In which IO is effected and shared variables are updated,
 all in a single-threaded manner.
\end_layout

\begin_layout Standard
In the computational phase, the order in which computations are performed
 on the processor is irrelevant as nothing is shared between the thread
 and the rest of the world.
 Since the threads have no effect on each other or the outside world in
 this phase, the only difference between concurrent execution and sequential
 execution is speed.
 In the communicative phase, however, execution has to be single threaded.
 Using this scheme, the application appears to be single threaded both to
 itself and to the rest of the world, all the while enabling separation
 of concerns and better utilization of multi-core systems.
 The following figure illustrates the principle:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename architecture.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
In terms of the actual execution a more detailed figure is offered:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailed.eps
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Observe that in the computational stage we can make available parallel list
 transformations like map and fold, without affecting the outward behaviour
 of the system, except for performance:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename archdetailedwithmap.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Given that the map-and-fold pattern, commonly called mapReduce, is widely
 applicative to many problems (indeed, it is intensely used in the Fumurt
 compiler!) 
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard

\emph on
Give code details (not a complete listing, but descriptions of key parts).
 Discuss the most important/interesting aspects.
 It probably won't be possible to discuss everything - give a rationale
 for what you do discuss.
\end_layout

\begin_layout Chapter
Testing
\end_layout

\begin_layout Standard

\emph on
Test plan -- how the program/system was verified.
 Put the actual test results in the Appendix.
 This section is useful if your project is more on the software engineering
 side than research focused.
\end_layout

\begin_layout Chapter
Results
\end_layout

\begin_layout Standard

\emph on
This covers different areas to the 'Testing' chapter, and is appropriate
 for 'research style' projects.
 For such projects this chapter should detail the types of experiments/simulatio
ns that were carried out with the code written.
 Why were certain experiments carried out but not others? What were the
 important parameters in the simulation and how did they affect the results?
 If there are very many graphs and tables associated with this chapter they
 may be put in the Appendix, but it is generally better to keep these close
 to the text they illustrate, as this is easier for the reader.
\end_layout

\begin_layout Chapter
Conclusion, Evaluation and Further Work
\end_layout

\begin_layout Standard

\emph on
What have you achieved? Give a critical appraisal (evaluation) of your own
 work - how could the work be taken further (perhaps by another student
 next year)?
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "1"
key "structured proof"

\end_inset

 Böhm et Jacopini, 1966
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "2"
key "free lunch over"

\end_inset

 Sutter, 2005
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "3"
key "Esterel"

\end_inset

Berry et Gonthier, 1992
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "4"
key "Language adoption"

\end_inset

Meyerovich et Rabkin, 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "5"
key "actors"

\end_inset

Hewitt, Bishop et Steiger, 1973
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "6"
key "CSP"

\end_inset

Hoare, 1978
\end_layout

\begin_layout Chapter
\start_of_appendix
System manual
\end_layout

\begin_layout Standard

\emph on
This should include all the technical details (where is the code? what do
 you type to compile it? etc) that would enable a student to continue your
 project next year, to be able to amend your code and extend it.
\end_layout

\begin_layout Chapter
User manual
\end_layout

\begin_layout Standard

\emph on
This should give enough information for someone to use what you have designed
 and implemented.
\end_layout

\begin_layout Chapter
Test results
\end_layout

\begin_layout Standard

\emph on
If you have test results that add to the value of the report, but which
 would not fit within the page limit of the main report, you can include
 then as an appendix.
 Don't add them just to pad the report though.
\end_layout

\begin_layout Chapter
Code listing
\end_layout

\begin_layout Standard

\emph on
Your code should be well commented.
 In order not to use up too many pages of your maximum 120 on code, you
 may like to use the 'a2ps' Unix facility, which allows you to put two pages
 of code onto one side of paper - see the Unix 'man' pages for details.
 If you have a great deal of code, and including all of it would take you
 over the page limit, you can make the rest available on a floppy disk or
 CD-ROM.
 You will need to bring in two copies of any disks or CDs you include when
 you hand in your project report, one to go with each copy of your project.
\end_layout

\end_body
\end_document
